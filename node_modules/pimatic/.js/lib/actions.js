
/*
Action Provider
=================
A Action Provider can parse a action of a rule string and returns an Action Handler for that.
The Action Handler offers a `executeAction` method to execute the action. 
For actions and rule explanations take a look at the [rules file](rules.html).
 */
var M, Promise, S, _, __, assert,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

__ = require("i18n").__;

Promise = require('bluebird');

assert = require('cassert');

_ = require('lodash');

S = require('string');

M = require('./matcher');

module.exports = function(env) {

  /*
  The ActionProvider
  ----------------
  The base class for all Action Providers. If you want to provide actions in your plugin then 
  you should create a sub class that implements the `parseAction` function.
   */
  var AVPlayerNextActionHandler, AVPlayerNextActionProvider, AVPlayerPauseActionHandler, AVPlayerPauseActionProvider, AVPlayerPlayActionHandler, AVPlayerPlayActionProvider, AVPlayerPrevActionHandler, AVPlayerPrevActionProvider, AVPlayerStopActionHandler, AVPlayerStopActionProvider, AVPlayerVolumeActionHandler, AVPlayerVolumeActionProvider, ActionHandler, ActionProvider, ButtonActionHandler, ButtonActionProvider, ContactActionHandler, ContactActionProvider, DimmerActionHandler, DimmerActionProvider, HeatingThermostatModeActionHandler, HeatingThermostatModeActionProvider, HeatingThermostatSetpointActionHandler, HeatingThermostatSetpointActionProvider, LogActionHandler, LogActionProvider, PresenceActionHandler, SetPresenceActionProvider, SetVariableActionHandler, SetVariableActionProvider, ShutterActionHandler, ShutterActionProvider, StopShutterActionHandler, StopShutterActionProvider, SwitchActionHandler, SwitchActionProvider, TimerActionHandler, TimerActionProvider, ToggleActionHandler, ToggleActionProvider, exports;
  ActionProvider = (function() {
    function ActionProvider() {
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    This function should parse the given input string `input` and return an ActionHandler if 
    handled by the input of described action, otherwise it should return `null`.
     */

    ActionProvider.prototype.parseAction = function(input, context) {
      throw new Error("Your ActionProvider must implement parseAction");
    };

    return ActionProvider;

  })();

  /*
  The Action Handler
  ----------------
  The base class for all Action Handler. If you want to provide actions in your plugin then 
  you should create a sub class that implements a `executeAction` function.
   */
  ActionHandler = (function(superClass) {
    extend(ActionHandler, superClass);

    function ActionHandler() {
      this.executeRestoreAction = bind(this.executeRestoreAction, this);
      this.hasRestoreAction = bind(this.hasRestoreAction, this);
      this.executeAction = bind(this.executeAction, this);
      return ActionHandler.__super__.constructor.apply(this, arguments);
    }


    /*
    ÃŒt should return a promise that gets fulfilled with describing string, that explains what was 
    done or would be done.
    
    If `simulate` is `true` the Action Handler should not execute the action. It should just
    return a promise fulfilled with a descriptive string like "would _..._".
    
    Take a look at the Log Action Handler for a simple example.
     */

    ActionHandler.prototype.executeAction = function(simulate) {
      throw new Error("Should be implemented by a subclass");
    };

    ActionHandler.prototype.hasRestoreAction = function() {
      return false;
    };

    ActionHandler.prototype.setup = function() {
      if (this._setupCalled) {
        throw new Error("Setup already called!");
      }
      return this._setupCalled = true;
    };

    ActionHandler.prototype.destroy = function() {
      if (!this._setupCalled) {
        throw new Error("Destroy called, but setup was not called!");
      }
      delete this._setupCalled;
      this.emit("destroy");
      return this.removeAllListeners();
    };

    ActionHandler.prototype.executeRestoreAction = function(simulate) {
      throw new Error("executeRestoreAction must be implemented when hasRestoreAction returns true");
    };

    ActionHandler.prototype.dependOnDevice = function(device) {
      var recreateEmitter;
      recreateEmitter = ((function(_this) {
        return function() {
          return _this.emit("recreate");
        };
      })(this));
      device.on("changed", recreateEmitter);
      device.on("destroyed", recreateEmitter);
      return this.on('destroy', (function(_this) {
        return function() {
          device.removeListener("changed", recreateEmitter);
          return device.removeListener("destroyed", recreateEmitter);
        };
      })(this));
    };

    ActionHandler.prototype.dependOnVariable = function(variableManager, varName) {
      var recreateEmitter;
      recreateEmitter = ((function(_this) {
        return function(variable) {
          if (variable.name !== varName) {
            return;
          }
          return _this.emit("recreate");
        };
      })(this));
      variableManager.on("variableRemoved", recreateEmitter);
      return this.on('destroy', (function(_this) {
        return function() {
          return variableManager.removeListener("variableRemoved", recreateEmitter);
        };
      })(this));
    };

    return ActionHandler;

  })(require('events').EventEmitter);

  /*
  The Log Action Provider
  -------------
  Provides log action, so that rules can use `log "some string"` in the actions part. It just prints
  the given string to the logger.
   */
  LogActionProvider = (function(superClass) {
    extend(LogActionProvider, superClass);

    function LogActionProvider(framework) {
      this.framework = framework;
    }

    LogActionProvider.prototype.parseAction = function(input, context) {
      var fullMatch, m, match, setLogString, stringToLogTokens;
      stringToLogTokens = null;
      fullMatch = false;
      setLogString = (function(_this) {
        return function(m, tokens) {
          return stringToLogTokens = tokens;
        };
      })(this);
      m = M(input, context).match("log ").matchStringWithVars(setLogString);
      if (m.hadMatch()) {
        match = m.getFullMatch();
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new LogActionHandler(this.framework, stringToLogTokens)
        };
      } else {
        return null;
      }
    };

    return LogActionProvider;

  })(ActionProvider);
  LogActionHandler = (function(superClass) {
    extend(LogActionHandler, superClass);

    function LogActionHandler(framework, stringToLogTokens1) {
      this.framework = framework;
      this.stringToLogTokens = stringToLogTokens1;
    }

    LogActionHandler.prototype.executeAction = function(simulate, context) {
      return this.framework.variableManager.evaluateStringExpression(this.stringToLogTokens).then((function(_this) {
        return function(strToLog) {
          if (simulate) {
            return __("would log \"%s\"", strToLog);
          } else {
            return strToLog;
          }
        };
      })(this));
    };

    return LogActionHandler;

  })(ActionHandler);

  /*
  The SetVariable ActionProvider
  -------------
  Provides log action, so that rules can use `log "some string"` in the actions part. It just prints
  the given string to the logger.
   */
  SetVariableActionProvider = (function(superClass) {
    extend(SetVariableActionProvider, superClass);

    function SetVariableActionProvider(framework) {
      this.framework = framework;
    }

    SetVariableActionProvider.prototype.parseAction = function(input, context) {
      var i, len, ref, result, v, variables, varsAndFunsWriteable;
      result = null;
      varsAndFunsWriteable = this.framework.variableManager.getVariablesAndFunctions({
        readonly: false
      });
      M(input, context).match("set ", {
        optional: true
      }).matchVariable(varsAndFunsWriteable, (function(_this) {
        return function(next, variableName) {
          return next.match([" to ", " := ", " = "], function(next) {
            return next.or([
              (function(next) {
                return next.matchNumericExpression(function(next, rightTokens) {
                  var match;
                  match = next.getFullMatch();
                  variableName = variableName.substring(1);
                  return result = {
                    variableName: variableName,
                    rightTokens: rightTokens,
                    match: match
                  };
                });
              }), (function(next) {
                return next.matchStringWithVars(function(next, rightTokens) {
                  var match;
                  match = next.getFullMatch();
                  variableName = variableName.substring(1);
                  return result = {
                    variableName: variableName,
                    rightTokens: rightTokens,
                    match: match
                  };
                });
              })
            ]);
          });
        };
      })(this));
      if (result != null) {
        variables = this.framework.variableManager.extractVariables(result.rightTokens);
        if (!this.framework.variableManager.isVariableDefined(result.variableName)) {
          context.addError("Variable $" + result.variableName + " is not defined.");
          return null;
        }
        ref = variables != null;
        for (i = 0, len = ref.length; i < len; i++) {
          v = ref[i];
          if (!this.framework.variableManager.isVariableDefined(v)) {
            context.addError("Variable $" + v + " is not defined.");
            return null;
          }
        }
        return {
          token: result.match,
          nextInput: input.substring(result.match.length),
          actionHandler: new SetVariableActionHandler(this.framework, result.variableName, result.rightTokens)
        };
      } else {
        return null;
      }
    };

    return SetVariableActionProvider;

  })(ActionProvider);
  SetVariableActionHandler = (function(superClass) {
    extend(SetVariableActionHandler, superClass);

    function SetVariableActionHandler(framework, variableName1, rightTokens1) {
      this.framework = framework;
      this.variableName = variableName1;
      this.rightTokens = rightTokens1;
    }

    SetVariableActionHandler.prototype.setup = function() {
      this.dependOnVariable(this.framework.variableManager, this.variableName);
      return SetVariableActionHandler.__super__.setup.call(this);
    };

    SetVariableActionHandler.prototype.executeAction = function(simulate, context) {
      if (simulate) {
        return Promise.resolve(__("would set $%s to value of %s", this.variableName, _(this.rightTokens).reduce((function(_this) {
          return function(left, right) {
            return left + " " + right;
          };
        })(this))));
      } else {
        return this.framework.variableManager.evaluateExpression(this.rightTokens).then((function(_this) {
          return function(value) {
            _this.framework.variableManager.setVariableToValue(_this.variableName, value);
            return Promise.resolve("set $" + _this.variableName + " to " + value);
          };
        })(this));
      }
    };

    return SetVariableActionHandler;

  })(ActionHandler);

  /*
  The SetPresence ActionProvider
  -------------
  Provides set presence action, so that rules can use `set presence of <device> to present|absent` 
  in the actions part.
   */
  SetPresenceActionProvider = (function(superClass) {
    extend(SetPresenceActionProvider, superClass);

    function SetPresenceActionProvider(framework) {
      this.framework = framework;
    }

    SetPresenceActionProvider.prototype.parseAction = function(input, context) {
      var device, m, match, presenceDevices, retVar, state;
      retVar = null;
      presenceDevices = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("changePresenceTo");
        };
      })(this)).value();
      device = null;
      state = null;
      match = null;
      m = M(input, context).match(['set presence of ']);
      m.matchDevice(presenceDevices, function(m, d) {
        return m.match([' present', ' absent'], function(m, s) {
          if ((device != null) && device.id !== d.id) {
            if (context != null) {
              context.addError("\"" + (input.trim()) + "\" is ambiguous.");
            }
            return;
          }
          device = d;
          state = s.trim();
          return match = m.getFullMatch();
        });
      });
      if (match != null) {
        assert(device != null);
        assert(state === 'present' || state === 'absent');
        assert(typeof match === "string");
        state = state === 'present';
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new PresenceActionHandler(device, state)
        };
      } else {
        return null;
      }
    };

    return SetPresenceActionProvider;

  })(ActionProvider);
  PresenceActionHandler = (function(superClass) {
    extend(PresenceActionHandler, superClass);

    function PresenceActionHandler(device1, state1) {
      this.device = device1;
      this.state = state1;
      this.executeRestoreAction = bind(this.executeRestoreAction, this);
      this.executeAction = bind(this.executeAction, this);
      this._doExecuteAction = bind(this._doExecuteAction, this);
    }

    PresenceActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return PresenceActionHandler.__super__.setup.call(this);
    };


    /*
    Handles the above actions.
     */

    PresenceActionHandler.prototype._doExecuteAction = function(simulate, state) {
      return (simulate ? state ? Promise.resolve(__("would set presence of %s to present", this.device.name)) : Promise.resolve(__("would set presence of %s to absent", this.device.name)) : state ? this.device.changePresenceTo(state).then((function(_this) {
        return function() {
          return __("set presence of %s to present", _this.device.name);
        };
      })(this)) : this.device.changePresenceTo(state).then((function(_this) {
        return function() {
          return __("set presence %s to absent", _this.device.name);
        };
      })(this)));
    };

    PresenceActionHandler.prototype.executeAction = function(simulate) {
      return this._doExecuteAction(simulate, this.state);
    };

    PresenceActionHandler.prototype.hasRestoreAction = function() {
      return true;
    };

    PresenceActionHandler.prototype.executeRestoreAction = function(simulate) {
      return this._doExecuteAction(simulate, !this.state);
    };

    return PresenceActionHandler;

  })(ActionHandler);

  /*
  The open/close ActionProvider
  -------------
  Provides open/close action, for the DummyContactSensor.
   */
  ContactActionProvider = (function(superClass) {
    extend(ContactActionProvider, superClass);

    function ContactActionProvider(framework) {
      this.framework = framework;
    }

    ContactActionProvider.prototype.parseAction = function(input, context) {
      var contactDevices, device, m, match, retVar, state;
      retVar = null;
      contactDevices = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("changeContactTo");
        };
      })(this)).value();
      device = null;
      state = null;
      match = null;
      m = M(input, context).match(['open ', 'close '], (function(_this) {
        return function(m, a) {
          return m.matchDevice(contactDevices, function(m, d) {
            if ((device != null) && device.id !== d.id) {
              if (context != null) {
                context.addError("\"" + (input.trim()) + "\" is ambiguous.");
              }
              return;
            }
            device = d;
            state = a.trim();
            return match = m.getFullMatch();
          });
        };
      })(this));
      if (match != null) {
        assert(device != null);
        assert(state === 'open' || state === 'close');
        assert(typeof match === "string");
        state = state === 'close';
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new ContactActionHandler(device, state)
        };
      } else {
        return null;
      }
    };

    return ContactActionProvider;

  })(ActionProvider);
  ContactActionHandler = (function(superClass) {
    extend(ContactActionHandler, superClass);

    function ContactActionHandler(device1, state1) {
      this.device = device1;
      this.state = state1;
      this.executeRestoreAction = bind(this.executeRestoreAction, this);
      this.executeAction = bind(this.executeAction, this);
      this._doExecuteAction = bind(this._doExecuteAction, this);
    }

    ContactActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return ContactActionHandler.__super__.setup.call(this);
    };


    /*
    Handles the above actions.
     */

    ContactActionHandler.prototype._doExecuteAction = function(simulate, state) {
      return (simulate ? state ? Promise.resolve(__("would set contact %s to closed", this.device.name)) : Promise.resolve(__("would set contact %s to opened", this.device.name)) : state ? this.device.changeContactTo(state).then((function(_this) {
        return function() {
          return __("set contact %s to closed", _this.device.name);
        };
      })(this)) : this.device.changeContactTo(state).then((function(_this) {
        return function() {
          return __("set contact %s to opened", _this.device.name);
        };
      })(this)));
    };

    ContactActionHandler.prototype.executeAction = function(simulate) {
      return this._doExecuteAction(simulate, this.state);
    };

    ContactActionHandler.prototype.hasRestoreAction = function() {
      return true;
    };

    ContactActionHandler.prototype.executeRestoreAction = function(simulate) {
      return this._doExecuteAction(simulate, !this.state);
    };

    return ContactActionHandler;

  })(ActionHandler);

  /*
  The Switch Action Provider
  -------------
  Provides the ability to switch devices on or off. Currently it handles the following actions:
  
  * switch [the] _device_ on|off
  * turn [the] _device_ on|off
  * switch on|off [the] _device_ 
  * turn on|off [the] _device_ 
  
  where _device_ is the name or id of a device and "the" is optional.
   */
  SwitchActionProvider = (function(superClass) {
    extend(SwitchActionProvider, superClass);

    function SwitchActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    Parses the above actions.
     */

    SwitchActionProvider.prototype.parseAction = function(input, context) {
      var device, m, match, retVar, state, switchDevices;
      retVar = null;
      switchDevices = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("turnOn") && device.hasAction("turnOff");
        };
      })(this)).value();
      device = null;
      state = null;
      match = null;
      m = M(input, context).match(['turn ', 'switch ']);
      m.matchDevice(switchDevices, function(m, d) {
        return m.match([' on', ' off'], function(m, s) {
          if ((device != null) && device.id !== d.id) {
            if (context != null) {
              context.addError("\"" + (input.trim()) + "\" is ambiguous.");
            }
            return;
          }
          device = d;
          state = s.trim();
          return match = m.getFullMatch();
        });
      });
      m.match(['on ', 'off '], function(m, s) {
        return m.matchDevice(switchDevices, function(m, d) {
          if ((device != null) && device.id !== d.id) {
            if (context != null) {
              context.addError("\"" + (input.trim()) + "\" is ambiguous.");
            }
            return;
          }
          device = d;
          state = s.trim();
          return match = m.getFullMatch();
        });
      });
      if (match != null) {
        assert(device != null);
        assert(state === 'on' || state === 'off');
        assert(typeof match === "string");
        state = state === 'on';
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new SwitchActionHandler(device, state)
        };
      } else {
        return null;
      }
    };

    return SwitchActionProvider;

  })(ActionProvider);
  SwitchActionHandler = (function(superClass) {
    extend(SwitchActionHandler, superClass);

    function SwitchActionHandler(device1, state1) {
      this.device = device1;
      this.state = state1;
      this.executeRestoreAction = bind(this.executeRestoreAction, this);
      this.executeAction = bind(this.executeAction, this);
      this._doExecuteAction = bind(this._doExecuteAction, this);
    }

    SwitchActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return SwitchActionHandler.__super__.setup.call(this);
    };


    /*
    Handles the above actions.
     */

    SwitchActionHandler.prototype._doExecuteAction = function(simulate, state) {
      return (simulate ? state ? Promise.resolve(__("would turn %s on", this.device.name)) : Promise.resolve(__("would turn %s off", this.device.name)) : state ? this.device.turnOn().then((function(_this) {
        return function() {
          return __("turned %s on", _this.device.name);
        };
      })(this)) : this.device.turnOff().then((function(_this) {
        return function() {
          return __("turned %s off", _this.device.name);
        };
      })(this)));
    };

    SwitchActionHandler.prototype.executeAction = function(simulate) {
      return this._doExecuteAction(simulate, this.state);
    };

    SwitchActionHandler.prototype.hasRestoreAction = function() {
      return true;
    };

    SwitchActionHandler.prototype.executeRestoreAction = function(simulate) {
      return this._doExecuteAction(simulate, !this.state);
    };

    return SwitchActionHandler;

  })(ActionHandler);

  /*
  The Toggle Action Provider
  -------------
  Provides the ability to toggle switch devices on or off. 
  Currently it handles the following actions:
  
  * toggle the state of _device_
  * toggle the state of [the] _device_
  * toggle _device_ state 
  * toggle  [the] _device_ state
  
  where _device_ is the name or id of a device and "the" is optional.
   */
  ToggleActionProvider = (function(superClass) {
    extend(ToggleActionProvider, superClass);

    function ToggleActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    Parses the above actions.
     */

    ToggleActionProvider.prototype.parseAction = function(input, context) {
      var device, m, match, onDeviceMatch, retVar, switchDevices;
      retVar = null;
      switchDevices = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("toggle");
        };
      })(this)).value();
      if (switchDevices.length === 0) {
        return;
      }
      device = null;
      match = null;
      onDeviceMatch = (function(m, d) {
        device = d;
        return match = m.getFullMatch();
      });
      m = M(input, context).match('toggle ').or([
        ((function(_this) {
          return function(m) {
            return m.match('the state of ', {
              optional: true
            }).matchDevice(switchDevices, onDeviceMatch);
          };
        })(this)), ((function(_this) {
          return function(m) {
            return m.matchDevice(switchDevices, function(m, d) {
              return m.match(' state', {
                optional: true
              }, function(m) {
                return onDeviceMatch(m, d);
              });
            });
          };
        })(this))
      ]);
      if (match != null) {
        assert(device != null);
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new ToggleActionHandler(device)
        };
      } else {
        return null;
      }
    };

    return ToggleActionProvider;

  })(ActionProvider);
  ToggleActionHandler = (function(superClass) {
    extend(ToggleActionHandler, superClass);

    function ToggleActionHandler(device1) {
      this.device = device1;
      this.executeAction = bind(this.executeAction, this);
    }

    ToggleActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return ToggleActionHandler.__super__.setup.call(this);
    };

    ToggleActionHandler.prototype.executeAction = function(simulate) {
      return (simulate ? Promise.resolve(__("would toggle state of %s", this.device.name)) : this.device.toggle().then((function(_this) {
        return function() {
          return __("toggled state of %s", _this.device.name);
        };
      })(this)));
    };

    return ToggleActionHandler;

  })(ActionHandler);

  /*
  The Button Action Provider
  -------------
  Provides the ability to press the button of a buttonsdevices.
  Currently it handles the following actions:
  
  * press [the] _device_
  
  where _device_ is the name or id of a the button not the buttons device and "the" is optional.
   */
  ButtonActionProvider = (function(superClass) {
    extend(ButtonActionProvider, superClass);

    function ButtonActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    Parses the above actions.
     */

    ButtonActionProvider.prototype.parseAction = function(input, context) {
      var b, buttonsWithId, d, end, i, id, len, m, match, matchCount, matchingButtonId, matchingDevice, onButtonMatch, ref, ref1;
      matchCount = 0;
      matchingDevice = null;
      matchingButtonId = null;
      end = (function(_this) {
        return function() {
          return matchCount++;
        };
      })(this);
      onButtonMatch = (function(_this) {
        return function(m, arg) {
          var buttonId, device;
          device = arg.device, buttonId = arg.buttonId;
          matchingDevice = device;
          return matchingButtonId = buttonId;
        };
      })(this);
      buttonsWithId = [];
      ref = this.framework.deviceManager.devices;
      for (id in ref) {
        d = ref[id];
        if (!(d instanceof env.devices.ButtonsDevice)) {
          continue;
        }
        ref1 = d.config.buttons;
        for (i = 0, len = ref1.length; i < len; i++) {
          b = ref1[i];
          buttonsWithId.push([
            {
              device: d,
              buttonId: b.id
            }, b.id
          ]);
          if (b.id !== b.text) {
            buttonsWithId.push([
              {
                device: d,
                buttonId: b.id
              }, b.text
            ]);
          }
        }
      }
      m = M(input, context).match('press ').match('the ', {
        optional: true
      }).match('button ', {
        optional: true
      }).match(buttonsWithId, {
        wildcard: "{button}"
      }, onButtonMatch);
      match = m.getFullMatch();
      if (match != null) {
        assert(matchingDevice != null);
        assert(matchingButtonId != null);
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new ButtonActionHandler(matchingDevice, matchingButtonId)
        };
      } else {
        return null;
      }
    };

    return ButtonActionProvider;

  })(ActionProvider);
  ButtonActionHandler = (function(superClass) {
    extend(ButtonActionHandler, superClass);

    function ButtonActionHandler(device1, buttonId1) {
      this.device = device1;
      this.buttonId = buttonId1;
      this.executeAction = bind(this.executeAction, this);
      this._doExecuteAction = bind(this._doExecuteAction, this);
      assert((this.device != null) && this.device instanceof env.devices.ButtonsDevice);
      assert((this.buttonId != null) && typeof this.buttonId === "string");
    }

    ButtonActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return ButtonActionHandler.__super__.setup.call(this);
    };


    /*
    Handles the above actions.
     */

    ButtonActionHandler.prototype._doExecuteAction = function(simulate) {
      return (simulate ? Promise.resolve(__("would press button %s of device %s", this.buttonId, this.device.id)) : this.device.buttonPressed(this.buttonId).then((function(_this) {
        return function() {
          return __("press button %s of device %s", _this.buttonId, _this.device.id);
        };
      })(this)));
    };

    ButtonActionHandler.prototype.executeAction = function(simulate) {
      return this._doExecuteAction(simulate);
    };

    ButtonActionHandler.prototype.hasRestoreAction = function() {
      return false;
    };

    return ButtonActionHandler;

  })(ActionHandler);

  /*
  The Shutter Action Provider
  -------------
  Provides the ability to raise or lower a shutter
  
  * lower [the] _device_ [down]
  * raise [the] _device_ [up]
  * move [the] _device_ up|down
  
  where _device_ is the name or id of a device and "the" is optional.
   */
  ShutterActionProvider = (function(superClass) {
    extend(ShutterActionProvider, superClass);

    function ShutterActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    Parses the above actions.
     */

    ShutterActionProvider.prototype.parseAction = function(input, context) {
      var device, m, match, position, shutterDevices;
      shutterDevices = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("moveUp") && device.hasAction("moveDown");
        };
      })(this)).value();
      device = null;
      position = null;
      match = null;
      m = M(input, context).match(['raise ', 'lower ', 'move '], (function(_this) {
        return function(m, a) {
          return m.matchDevice(shutterDevices, function(m, d) {
            var last, nt, p, ref;
            ref = ((function() {
              switch (a.trim()) {
                case 'raise':
                  return ['up', ' up'];
                case 'lower':
                  return ['down', ' down'];
                default:
                  return [null, [" up", " down"]];
              }
            })()), p = ref[0], nt = ref[1];
            last = m.match(nt, {
              optional: a.trim() !== 'move'
            }, function(m, po) {
              return p = po.trim();
            });
            if (last.hadMatch()) {
              if ((device != null) && device.id !== d.id) {
                if (context != null) {
                  context.addError("\"" + (input.trim()) + "\" is ambiguous.");
                }
                return;
              }
              device = d;
              position = p;
              return match = last.getFullMatch();
            }
          });
        };
      })(this));
      if (match != null) {
        assert(device != null);
        assert(position === 'down' || position === 'up');
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new ShutterActionHandler(device, position)
        };
      } else {
        return null;
      }
    };

    return ShutterActionProvider;

  })(ActionProvider);
  ShutterActionHandler = (function(superClass) {
    extend(ShutterActionHandler, superClass);

    function ShutterActionHandler(device1, position1) {
      this.device = device1;
      this.position = position1;
      this.executeRestoreAction = bind(this.executeRestoreAction, this);
      this.executeAction = bind(this.executeAction, this);
    }

    ShutterActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return ShutterActionHandler.__super__.setup.call(this);
    };

    ShutterActionHandler.prototype.executeAction = function(simulate) {
      return (simulate ? this.position === 'up' ? Promise.resolve(__("would raise %s", this.device.name)) : Promise.resolve(__("would lower %s", this.device.name)) : this.position === 'up' ? this.device.moveUp().then((function(_this) {
        return function() {
          return __("raised %s", _this.device.name);
        };
      })(this)) : this.device.moveDown().then((function(_this) {
        return function() {
          return __("lowered %s", _this.device.name);
        };
      })(this)));
    };

    ShutterActionHandler.prototype.hasRestoreAction = function() {
      return this.device.hasAction('stop');
    };

    ShutterActionHandler.prototype.executeRestoreAction = function(simulate) {
      if (simulate) {
        return Promise.resolve(__("would stop %s", this.device.name));
      } else {
        return this.device.stop().then((function(_this) {
          return function() {
            return __("stopped %s", _this.device.name);
          };
        })(this));
      }
    };

    return ShutterActionHandler;

  })(ActionHandler);

  /*
  The Shutter Stop Action Provider
  -------------
  Provides the ability to stop a shutter
  
  * stop [the] _device_
  
  where _device_ is the name or id of a device and "the" is optional.
   */
  StopShutterActionProvider = (function(superClass) {
    extend(StopShutterActionProvider, superClass);

    function StopShutterActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    Parses the above actions.
     */

    StopShutterActionProvider.prototype.parseAction = function(input, context) {
      var device, m, match, shutterDevices;
      shutterDevices = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("stop") && device.hasAction("moveUp");
        };
      })(this)).value();
      device = null;
      match = null;
      m = M(input, context).match("stop ", (function(_this) {
        return function(m, a) {
          return m.matchDevice(shutterDevices, function(m, d) {
            if ((device != null) && device.id !== d.id) {
              if (context != null) {
                context.addError("\"" + (input.trim()) + "\" is ambiguous.");
              }
              return;
            }
            device = d;
            return match = m.getFullMatch();
          });
        };
      })(this));
      if (match != null) {
        assert(device != null);
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new StopShutterActionHandler(device)
        };
      } else {
        return null;
      }
    };

    return StopShutterActionProvider;

  })(ActionProvider);
  StopShutterActionHandler = (function(superClass) {
    extend(StopShutterActionHandler, superClass);

    function StopShutterActionHandler(device1) {
      this.device = device1;
      this.executeAction = bind(this.executeAction, this);
    }

    StopShutterActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return StopShutterActionHandler.__super__.setup.call(this);
    };

    StopShutterActionHandler.prototype.executeAction = function(simulate) {
      return (simulate ? Promise.resolve(__("would stop %s", this.device.name)) : this.device.stop().then((function(_this) {
        return function() {
          return __("stopped %s", _this.device.name);
        };
      })(this)));
    };

    StopShutterActionHandler.prototype.hasRestoreAction = function() {
      return false;
    };

    return StopShutterActionHandler;

  })(ActionHandler);

  /*
  The Dimmer Action Provider
  -------------
  Provides the ability to change the dim level of dimmer devices. Currently it handles the 
  following actions:
  
  * dim [the] _device_ to _value_%
  
  where _device_ is the name or id of a device and "the" is optional.
   */
  DimmerActionProvider = (function(superClass) {
    extend(DimmerActionProvider, superClass);

    function DimmerActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    Parses the above actions.
     */

    DimmerActionProvider.prototype.parseAction = function(input, context) {
      var device, dimmers, match, retVar, value, valueTokens;
      retVar = null;
      dimmers = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("changeDimlevelTo");
        };
      })(this)).value();
      if (dimmers.length === 0) {
        return;
      }
      device = null;
      valueTokens = null;
      match = null;
      M(input, context).match('dim ').matchDevice(dimmers, (function(_this) {
        return function(next, d) {
          return next.match(' to ').matchNumericExpression(function(next, ts) {
            var m;
            m = next.match('%', {
              optional: true
            });
            if ((device != null) && device.id !== d.id) {
              if (context != null) {
                context.addError("\"" + (input.trim()) + "\" is ambiguous.");
              }
              return;
            }
            device = d;
            valueTokens = ts;
            return match = m.getFullMatch();
          });
        };
      })(this));
      if (match != null) {
        if (valueTokens.length === 1 && !isNaN(valueTokens[0])) {
          value = valueTokens[0];
          assert(!isNaN(value));
          value = parseFloat(value);
          if (value < 0.0) {
            if (context != null) {
              context.addError("Can't dim to a negative dimlevel.");
            }
            return;
          }
          if (value > 100.0) {
            if (context != null) {
              context.addError("Can't dim to greater than 100%.");
            }
            return;
          }
        }
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new DimmerActionHandler(this.framework, device, valueTokens)
        };
      } else {
        return null;
      }
    };

    return DimmerActionProvider;

  })(ActionProvider);
  DimmerActionHandler = (function(superClass) {
    extend(DimmerActionHandler, superClass);

    function DimmerActionHandler(framework, device1, valueTokens1) {
      this.framework = framework;
      this.device = device1;
      this.valueTokens = valueTokens1;
      this.executeRestoreAction = bind(this.executeRestoreAction, this);
      this.executeAction = bind(this.executeAction, this);
      this._doExecuteAction = bind(this._doExecuteAction, this);
      assert(this.device != null);
      assert(this.valueTokens != null);
    }

    DimmerActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return DimmerActionHandler.__super__.setup.call(this);
    };

    DimmerActionHandler.prototype._clampVal = function(value) {
      assert(!isNaN(value));
      return ((function() {
        switch (false) {
          case !(value > 100):
            return 100;
          case !(value < 0):
            return 0;
          default:
            return value;
        }
      })());
    };


    /*
    Handles the above actions.
     */

    DimmerActionHandler.prototype._doExecuteAction = function(simulate, value) {
      return (simulate ? __("would dim %s to %s%%", this.device.name, value) : this.device.changeDimlevelTo(value).then((function(_this) {
        return function() {
          return __("dimmed %s to %s%%", _this.device.name, value);
        };
      })(this)));
    };

    DimmerActionHandler.prototype.executeAction = function(simulate) {
      return this.device.getDimlevel().then((function(_this) {
        return function(lastValue) {
          _this.lastValue = lastValue || 0;
          return _this.framework.variableManager.evaluateNumericExpression(_this.valueTokens).then(function(value) {
            value = _this._clampVal(value);
            return _this._doExecuteAction(simulate, value);
          });
        };
      })(this));
    };

    DimmerActionHandler.prototype.hasRestoreAction = function() {
      return true;
    };

    DimmerActionHandler.prototype.executeRestoreAction = function(simulate) {
      return Promise.resolve(this._doExecuteAction(simulate, this.lastValue));
    };

    return DimmerActionHandler;

  })(ActionHandler);
  HeatingThermostatModeActionProvider = (function(superClass) {
    extend(HeatingThermostatModeActionProvider, superClass);

    function HeatingThermostatModeActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    Parses the above actions.
     */

    HeatingThermostatModeActionProvider.prototype.parseAction = function(input, context) {
      var device, match, modes, retVar, thermostats, value, valueTokens;
      retVar = null;
      thermostats = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("changeModeTo");
        };
      })(this)).value();
      if (thermostats.length === 0) {
        return;
      }
      device = null;
      valueTokens = null;
      match = null;
      M(input, context).match('set mode of ').matchDevice(thermostats, (function(_this) {
        return function(next, d) {
          return next.match(' to ').matchStringWithVars(function(next, ts) {
            var m;
            m = next.match(' mode', {
              optional: true
            });
            if ((device != null) && device.id !== d.id) {
              if (context != null) {
                context.addError("\"" + (input.trim()) + "\" is ambiguous.");
              }
              return;
            }
            device = d;
            valueTokens = ts;
            return match = m.getFullMatch();
          });
        };
      })(this));
      if (match != null) {
        if (valueTokens.length === 1 && !isNaN(valueTokens[0])) {
          value = valueTokens[0];
          assert(!isNaN(value));
          modes = ["eco", "boost", "auto", "manu", "comfy"];
          if (modes.indexOf(value) < -1) {
            if (context != null) {
              context.addError("Allowed modes: eco,boost,auto,manu,comfy");
            }
            return;
          }
        }
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new HeatingThermostatModeActionHandler(this.framework, device, valueTokens)
        };
      } else {
        return null;
      }
    };

    return HeatingThermostatModeActionProvider;

  })(ActionProvider);
  HeatingThermostatModeActionHandler = (function(superClass) {
    extend(HeatingThermostatModeActionHandler, superClass);

    function HeatingThermostatModeActionHandler(framework, device1, valueTokens1) {
      this.framework = framework;
      this.device = device1;
      this.valueTokens = valueTokens1;
      this.executeRestoreAction = bind(this.executeRestoreAction, this);
      this.executeAction = bind(this.executeAction, this);
      this._doExecuteAction = bind(this._doExecuteAction, this);
      assert(this.device != null);
      assert(this.valueTokens != null);
    }

    HeatingThermostatModeActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return HeatingThermostatModeActionHandler.__super__.setup.call(this);
    };


    /*
    Handles the above actions.
     */

    HeatingThermostatModeActionHandler.prototype._doExecuteAction = function(simulate, value) {
      return (simulate ? __("would set mode %s to %s", this.device.name, value) : this.device.changeModeTo(value).then((function(_this) {
        return function() {
          return __("set mode %s to %s", _this.device.name, value);
        };
      })(this)));
    };

    HeatingThermostatModeActionHandler.prototype.executeAction = function(simulate) {
      return this.framework.variableManager.evaluateStringExpression(this.valueTokens).then((function(_this) {
        return function(value) {
          _this.lastValue = value;
          return _this._doExecuteAction(simulate, value);
        };
      })(this));
    };

    HeatingThermostatModeActionHandler.prototype.hasRestoreAction = function() {
      return true;
    };

    HeatingThermostatModeActionHandler.prototype.executeRestoreAction = function(simulate) {
      return Promise.resolve(this._doExecuteAction(simulate, this.lastValue));
    };

    return HeatingThermostatModeActionHandler;

  })(ActionHandler);
  HeatingThermostatSetpointActionProvider = (function(superClass) {
    extend(HeatingThermostatSetpointActionProvider, superClass);

    function HeatingThermostatSetpointActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    Parses the above actions.
     */

    HeatingThermostatSetpointActionProvider.prototype.parseAction = function(input, context) {
      var device, match, retVar, thermostats, value, valueTokens;
      retVar = null;
      thermostats = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("changeTemperatureTo");
        };
      })(this)).value();
      if (thermostats.length === 0) {
        return;
      }
      device = null;
      valueTokens = null;
      match = null;
      M(input, context).match('set temp of ').matchDevice(thermostats, (function(_this) {
        return function(next, d) {
          return next.match(' to ').matchNumericExpression(function(next, ts) {
            var m;
            m = next.match('Â°C', {
              optional: true
            });
            if ((device != null) && device.id !== d.id) {
              if (context != null) {
                context.addError("\"" + (input.trim()) + "\" is ambiguous.");
              }
              return;
            }
            device = d;
            valueTokens = ts;
            return match = m.getFullMatch();
          });
        };
      })(this));
      if (match != null) {
        if (valueTokens.length === 1 && !isNaN(valueTokens[0])) {
          value = valueTokens[0];
          assert(!isNaN(value));
          value = parseFloat(value);
          if (value < 0.0) {
            if (context != null) {
              context.addError("Can't set temp to a negative value.");
            }
            return;
          }
          if (value > 32.0) {
            if (context != null) {
              context.addError("Can't set temp higher than 32Â°C.");
            }
            return;
          }
        }
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new HeatingThermostatSetpointActionHandler(this.framework, device, valueTokens)
        };
      } else {
        return null;
      }
    };

    return HeatingThermostatSetpointActionProvider;

  })(ActionProvider);
  HeatingThermostatSetpointActionHandler = (function(superClass) {
    extend(HeatingThermostatSetpointActionHandler, superClass);

    function HeatingThermostatSetpointActionHandler(framework, device1, valueTokens1) {
      this.framework = framework;
      this.device = device1;
      this.valueTokens = valueTokens1;
      this.executeRestoreAction = bind(this.executeRestoreAction, this);
      this.executeAction = bind(this.executeAction, this);
      this._doExecuteAction = bind(this._doExecuteAction, this);
      assert(this.device != null);
      assert(this.valueTokens != null);
    }

    HeatingThermostatSetpointActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return HeatingThermostatSetpointActionHandler.__super__.setup.call(this);
    };


    /*
    Handles the above actions.
     */

    HeatingThermostatSetpointActionHandler.prototype._doExecuteAction = function(simulate, value) {
      return (simulate ? __("would set temp of %s to %sÂ°C", this.device.name, value) : this.device.changeTemperatureTo(value).then((function(_this) {
        return function() {
          return __("set temp of %s to %sÂ°C", _this.device.name, value);
        };
      })(this)));
    };

    HeatingThermostatSetpointActionHandler.prototype.executeAction = function(simulate) {
      return this.framework.variableManager.evaluateNumericExpression(this.valueTokens).then((function(_this) {
        return function(value) {
          _this.lastValue = value;
          return _this._doExecuteAction(simulate, value);
        };
      })(this));
    };

    HeatingThermostatSetpointActionHandler.prototype.hasRestoreAction = function() {
      return true;
    };

    HeatingThermostatSetpointActionHandler.prototype.executeRestoreAction = function(simulate) {
      return Promise.resolve(this._doExecuteAction(simulate, this.lastValue));
    };

    return HeatingThermostatSetpointActionHandler;

  })(ActionHandler);

  /*
  The Timer Action Provider
  -------------
  Start, stop or reset Timer
  
  * start|stop|reset the _device_ [timer] 
  
  where _device_ is the name or id of a timer device and "the" is optional.
   */
  TimerActionProvider = (function(superClass) {
    extend(TimerActionProvider, superClass);

    function TimerActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    Parses the above actions.
     */

    TimerActionProvider.prototype.parseAction = function(input, context) {
      var action, device, m, match, timerDevices;
      timerDevices = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("startTimer") && device.hasAction("stopTimer") && device.hasAction("resetTimer");
        };
      })(this)).value();
      device = null;
      action = null;
      match = null;
      m = M(input, context).match(['start ', 'stop ', 'reset '], (function(_this) {
        return function(m, a) {
          return m.matchDevice(timerDevices, function(m, d) {
            var last;
            last = m.match(' timer', {
              optional: true
            });
            if (last.hadMatch()) {
              if ((device != null) && device.id !== d.id) {
                if (context != null) {
                  context.addError("\"" + (input.trim()) + "\" is ambiguous.");
                }
                return;
              }
              device = d;
              action = a.trim();
              return match = last.getFullMatch();
            }
          });
        };
      })(this));
      if (match != null) {
        assert(device != null);
        assert(action === 'start' || action === 'stop' || action === 'reset');
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new TimerActionHandler(device, action)
        };
        return null;
      }
    };

    return TimerActionProvider;

  })(ActionProvider);
  TimerActionHandler = (function(superClass) {
    extend(TimerActionHandler, superClass);

    function TimerActionHandler(device1, action1) {
      this.device = device1;
      this.action = action1;
      this.executeAction = bind(this.executeAction, this);
    }

    TimerActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return TimerActionHandler.__super__.setup.call(this);
    };

    TimerActionHandler.prototype.executeAction = function(simulate) {
      return (simulate ? Promise.resolve(__("would " + this.action + " %s", this.device.name)) : this.device[this.action + "Timer"]().then((function(_this) {
        return function() {
          return __(_this.action + "ed %s", _this.device.name);
        };
      })(this)));
    };

    TimerActionHandler.prototype.hasRestoreAction = function() {
      return false;
    };

    return TimerActionHandler;

  })(ActionHandler);
  AVPlayerPauseActionProvider = (function(superClass) {
    extend(AVPlayerPauseActionProvider, superClass);

    function AVPlayerPauseActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    This function handles action in the form of `play device`
     */

    AVPlayerPauseActionProvider.prototype.parseAction = function(input, context) {
      var avPlayers, device, m, match, onDeviceMatch, retVar;
      retVar = null;
      avPlayers = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("pause");
        };
      })(this)).value();
      if (avPlayers.length === 0) {
        return;
      }
      device = null;
      match = null;
      onDeviceMatch = (function(m, d) {
        device = d;
        return match = m.getFullMatch();
      });
      m = M(input, context).match('pause ').matchDevice(avPlayers, onDeviceMatch);
      if (match != null) {
        assert(device != null);
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new AVPlayerPauseActionHandler(device)
        };
      } else {
        return null;
      }
    };

    return AVPlayerPauseActionProvider;

  })(ActionProvider);
  AVPlayerPauseActionHandler = (function(superClass) {
    extend(AVPlayerPauseActionHandler, superClass);

    function AVPlayerPauseActionHandler(device1) {
      this.device = device1;
      this.executeAction = bind(this.executeAction, this);
    }

    AVPlayerPauseActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return AVPlayerPauseActionHandler.__super__.setup.call(this);
    };

    AVPlayerPauseActionHandler.prototype.executeAction = function(simulate) {
      return (simulate ? Promise.resolve(__("would pause %s", this.device.name)) : this.device.pause().then((function(_this) {
        return function() {
          return __("paused %s", _this.device.name);
        };
      })(this)));
    };

    return AVPlayerPauseActionHandler;

  })(ActionHandler);
  AVPlayerStopActionProvider = (function(superClass) {
    extend(AVPlayerStopActionProvider, superClass);

    function AVPlayerStopActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    This function handles action in the form of `execute "some string"`
     */

    AVPlayerStopActionProvider.prototype.parseAction = function(input, context) {
      var avPlayers, device, m, match, onDeviceMatch, retVar;
      retVar = null;
      avPlayers = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("stop") && device.hasAction("play");
        };
      })(this)).value();
      if (avPlayers.length === 0) {
        return;
      }
      device = null;
      match = null;
      onDeviceMatch = (function(m, d) {
        device = d;
        return match = m.getFullMatch();
      });
      m = M(input, context).match('stop ').matchDevice(avPlayers, onDeviceMatch);
      if (match != null) {
        assert(device != null);
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new AVPlayerStopActionHandler(device)
        };
      } else {
        return null;
      }
    };

    return AVPlayerStopActionProvider;

  })(ActionProvider);
  AVPlayerStopActionHandler = (function(superClass) {
    extend(AVPlayerStopActionHandler, superClass);

    function AVPlayerStopActionHandler(device1) {
      this.device = device1;
      this.executeAction = bind(this.executeAction, this);
    }

    AVPlayerStopActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return AVPlayerStopActionHandler.__super__.setup.call(this);
    };

    AVPlayerStopActionHandler.prototype.executeAction = function(simulate) {
      return (simulate ? Promise.resolve(__("would stop %s", this.device.name)) : this.device.stop().then((function(_this) {
        return function() {
          return __("stop %s", _this.device.name);
        };
      })(this)));
    };

    return AVPlayerStopActionHandler;

  })(ActionHandler);
  AVPlayerPlayActionProvider = (function(superClass) {
    extend(AVPlayerPlayActionProvider, superClass);

    function AVPlayerPlayActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    This function handles action in the form of `execute "some string"`
     */

    AVPlayerPlayActionProvider.prototype.parseAction = function(input, context) {
      var avPlayers, device, m, match, onDeviceMatch, retVar;
      retVar = null;
      avPlayers = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("play");
        };
      })(this)).value();
      if (avPlayers.length === 0) {
        return;
      }
      device = null;
      match = null;
      onDeviceMatch = (function(m, d) {
        device = d;
        return match = m.getFullMatch();
      });
      m = M(input, context).match('play ').matchDevice(avPlayers, onDeviceMatch);
      if (match != null) {
        assert(device != null);
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new AVPlayerPlayActionHandler(device)
        };
      } else {
        return null;
      }
    };

    return AVPlayerPlayActionProvider;

  })(ActionProvider);
  AVPlayerPlayActionHandler = (function(superClass) {
    extend(AVPlayerPlayActionHandler, superClass);

    function AVPlayerPlayActionHandler(device1) {
      this.device = device1;
      this.executeAction = bind(this.executeAction, this);
    }

    AVPlayerPlayActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return AVPlayerPlayActionHandler.__super__.setup.call(this);
    };

    AVPlayerPlayActionHandler.prototype.executeAction = function(simulate) {
      return (simulate ? Promise.resolve(__("would play %s", this.device.name)) : this.device.play().then((function(_this) {
        return function() {
          return __("playing %s", _this.device.name);
        };
      })(this)));
    };

    return AVPlayerPlayActionHandler;

  })(ActionHandler);
  AVPlayerVolumeActionProvider = (function(superClass) {
    extend(AVPlayerVolumeActionProvider, superClass);

    function AVPlayerVolumeActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    This function handles action in the form of `execute "some string"`
     */

    AVPlayerVolumeActionProvider.prototype.parseAction = function(input, context) {
      var avPlayers, device, match, onDeviceMatch, retVar, value, valueTokens, volume;
      retVar = null;
      volume = null;
      avPlayers = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("setVolume");
        };
      })(this)).value();
      if (avPlayers.length === 0) {
        return;
      }
      device = null;
      valueTokens = null;
      match = null;
      onDeviceMatch = (function(m, d) {
        device = d;
        return match = m.getFullMatch();
      });
      M(input, context).match('change volume of ').matchDevice(avPlayers, (function(_this) {
        return function(next, d) {
          return next.match(' to ', function(next) {
            return next.matchNumericExpression(function(next, ts) {
              var m;
              m = next.match('%', {
                optional: true
              });
              if ((device != null) && device.id !== d.id) {
                if (context != null) {
                  context.addError("\"" + (input.trim()) + "\" is ambiguous.");
                }
                return;
              }
              device = d;
              valueTokens = ts;
              return match = m.getFullMatch();
            });
          });
        };
      })(this));
      if (match != null) {
        value = valueTokens[0];
        assert(device != null);
        assert(typeof match === "string");
        value = parseFloat(value);
        if (value < 0.0) {
          if (context != null) {
            context.addError("Can't change volume to a negative value.");
          }
          return;
        }
        if (value > 100.0) {
          if (context != null) {
            context.addError("Can't change volume to greater than 100%.");
          }
          return;
        }
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new AVPlayerVolumeActionHandler(this.framework, device, valueTokens)
        };
      } else {
        return null;
      }
    };

    return AVPlayerVolumeActionProvider;

  })(ActionProvider);
  AVPlayerVolumeActionHandler = (function(superClass) {
    extend(AVPlayerVolumeActionHandler, superClass);

    function AVPlayerVolumeActionHandler(framework, device1, valueTokens1) {
      this.framework = framework;
      this.device = device1;
      this.valueTokens = valueTokens1;
      this.executeAction = bind(this.executeAction, this);
    }

    AVPlayerVolumeActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return AVPlayerVolumeActionHandler.__super__.setup.call(this);
    };

    AVPlayerVolumeActionHandler.prototype.executeAction = function(simulate, value) {
      var val;
      return (isNaN(this.valueTokens[0]) ? val = this.framework.variableManager.getVariableValue(this.valueTokens[0].substring(1)) : val = this.valueTokens[0], simulate ? Promise.resolve(__("would set volume of %s to %s", this.device.name, val)) : this.device.setVolume(val).then((function(_this) {
        return function() {
          return __("set volume of %s to %s", _this.device.name, val);
        };
      })(this)));
    };

    return AVPlayerVolumeActionHandler;

  })(ActionHandler);
  AVPlayerNextActionProvider = (function(superClass) {
    extend(AVPlayerNextActionProvider, superClass);

    function AVPlayerNextActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    This function handles action in the form of `execute "some string"`
     */

    AVPlayerNextActionProvider.prototype.parseAction = function(input, context) {
      var avPlayers, device, m, match, onDeviceMatch, retVar, valueTokens, volume;
      retVar = null;
      volume = null;
      avPlayers = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("next");
        };
      })(this)).value();
      if (avPlayers.length === 0) {
        return;
      }
      device = null;
      valueTokens = null;
      match = null;
      onDeviceMatch = (function(m, d) {
        device = d;
        return match = m.getFullMatch();
      });
      m = M(input, context).match(['play next', 'next ']).match(" song ", {
        optional: true
      }).match("on ", {
        optional: true
      }).matchDevice(avPlayers, onDeviceMatch);
      if (match != null) {
        assert(device != null);
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new AVPlayerNextActionHandler(device)
        };
      } else {
        return null;
      }
    };

    return AVPlayerNextActionProvider;

  })(ActionProvider);
  AVPlayerNextActionHandler = (function(superClass) {
    extend(AVPlayerNextActionHandler, superClass);

    function AVPlayerNextActionHandler(device1) {
      this.device = device1;
      this.executeAction = bind(this.executeAction, this);
    }

    AVPlayerNextActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return AVPlayerNextActionHandler.__super__.setup.call(this);
    };

    AVPlayerNextActionHandler.prototype.executeAction = function(simulate) {
      return (simulate ? Promise.resolve(__("would play next track of %s", this.device.name)) : this.device.next().then((function(_this) {
        return function() {
          return __("play next track of %s", _this.device.name);
        };
      })(this)));
    };

    return AVPlayerNextActionHandler;

  })(ActionHandler);
  AVPlayerPrevActionProvider = (function(superClass) {
    extend(AVPlayerPrevActionProvider, superClass);

    function AVPlayerPrevActionProvider(framework) {
      this.framework = framework;
      this.parseAction = bind(this.parseAction, this);
    }


    /*
    This function handles action in the form of `execute "some string"`
     */

    AVPlayerPrevActionProvider.prototype.parseAction = function(input, context) {
      var avPlayers, device, m, match, onDeviceMatch, retVar, valueTokens, volume;
      retVar = null;
      volume = null;
      avPlayers = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAction("previous");
        };
      })(this)).value();
      if (avPlayers.length === 0) {
        return;
      }
      device = null;
      valueTokens = null;
      match = null;
      onDeviceMatch = (function(m, d) {
        device = d;
        return match = m.getFullMatch();
      });
      m = M(input, context).match(['play previous', 'previous ']).match(" song ", {
        optional: true
      }).match("on ", {
        optional: true
      }).matchDevice(avPlayers, onDeviceMatch);
      if (match != null) {
        assert(device != null);
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          actionHandler: new AVPlayerNextActionHandler(device)
        };
      } else {
        return null;
      }
    };

    return AVPlayerPrevActionProvider;

  })(ActionProvider);
  AVPlayerPrevActionHandler = (function(superClass) {
    extend(AVPlayerPrevActionHandler, superClass);

    function AVPlayerPrevActionHandler(device1) {
      this.device = device1;
      this.executeAction = bind(this.executeAction, this);
    }

    AVPlayerPrevActionHandler.prototype.setup = function() {
      this.dependOnDevice(this.device);
      return AVPlayerPrevActionHandler.__super__.setup.call(this);
    };

    AVPlayerPrevActionHandler.prototype.executeAction = function(simulate) {
      return (simulate ? Promise.resolve(__("would play previous track of %s", this.device.name)) : this.device.previous().then((function(_this) {
        return function() {
          return __("play previous track of %s", _this.device.name);
        };
      })(this)));
    };

    return AVPlayerPrevActionHandler;

  })(ActionHandler);
  return exports = {
    ActionHandler: ActionHandler,
    ActionProvider: ActionProvider,
    SetVariableActionProvider: SetVariableActionProvider,
    SetPresenceActionProvider: SetPresenceActionProvider,
    ContactActionProvider: ContactActionProvider,
    SwitchActionProvider: SwitchActionProvider,
    DimmerActionProvider: DimmerActionProvider,
    LogActionProvider: LogActionProvider,
    ShutterActionProvider: ShutterActionProvider,
    StopShutterActionProvider: StopShutterActionProvider,
    ToggleActionProvider: ToggleActionProvider,
    ButtonActionProvider: ButtonActionProvider,
    HeatingThermostatModeActionProvider: HeatingThermostatModeActionProvider,
    HeatingThermostatSetpointActionProvider: HeatingThermostatSetpointActionProvider,
    TimerActionProvider: TimerActionProvider,
    AVPlayerPauseActionProvider: AVPlayerPauseActionProvider,
    AVPlayerStopActionProvider: AVPlayerStopActionProvider,
    AVPlayerPlayActionProvider: AVPlayerPlayActionProvider,
    AVPlayerVolumeActionProvider: AVPlayerVolumeActionProvider,
    AVPlayerNextActionProvider: AVPlayerNextActionProvider,
    AVPlayerPrevActionProvider: AVPlayerPrevActionProvider
  };
};
