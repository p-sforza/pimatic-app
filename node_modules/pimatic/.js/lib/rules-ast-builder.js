
/*
Rules AST Builder
===========
Builds a Abstract Syntax Tree (AST) from a rule condition token sequence.
 */
var AndExpression, BoolExpression, BoolExpressionTreeBuilder, OrExpression, PredicateExpression, Promise, S, _, assert, util,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

assert = require('cassert');

util = require('util');

Promise = require('bluebird');

_ = require('lodash');

S = require('string');

BoolExpression = (function() {
  function BoolExpression() {}

  BoolExpression.prototype.toString = function() {
    return (this.type.replace(' ', '')) + "(" + (this.left.toString()) + ", " + (this.right.toString()) + ")";
  };

  return BoolExpression;

})();

AndExpression = (function(superClass) {
  extend(AndExpression, superClass);

  function AndExpression(type, left1, right1) {
    this.type = type;
    this.left = left1;
    this.right = right1;
  }

  AndExpression.prototype.evaluate = function(cache) {
    return this.left.evaluate(cache).then((function(_this) {
      return function(val) {
        if (val) {
          return _this.right.evaluate(cache);
        } else {
          return false;
        }
      };
    })(this));
  };

  return AndExpression;

})(BoolExpression);

OrExpression = (function(superClass) {
  extend(OrExpression, superClass);

  function OrExpression(type, left1, right1) {
    this.type = type;
    this.left = left1;
    this.right = right1;
  }

  OrExpression.prototype.evaluate = function(cache) {
    return this.left.evaluate(cache).then((function(_this) {
      return function(val) {
        if (val) {
          return true;
        } else {
          return _this.right.evaluate(cache);
        }
      };
    })(this));
  };

  return OrExpression;

})(BoolExpression);

PredicateExpression = (function(superClass) {
  extend(PredicateExpression, superClass);

  function PredicateExpression(predicate1) {
    this.predicate = predicate1;
    this.type = "predicate";
  }

  PredicateExpression.prototype.evaluate = function(cache) {
    var id, value;
    id = this.predicate.id;
    value = cache[id];
    return (value != null ? Promise.resolve(value) : this.predicate.justTrigger === true ? Promise.resolve(false) : this.predicate.handler.getValue().then((function(_this) {
      return function(value) {
        if ((_this.predicate["for"] != null) && value === true) {
          return _this.predicate.timeAchived;
        } else {
          cache[id] = value;
          return value;
        }
      };
    })(this)));
  };

  PredicateExpression.prototype.toString = function() {
    return "predicate('" + this.predicate.token + "')";
  };

  return PredicateExpression;

})(BoolExpression);

BoolExpressionTreeBuilder = (function() {
  function BoolExpressionTreeBuilder() {}

  BoolExpressionTreeBuilder.prototype._nextToken = function() {
    if (this.pos < this.tokens.length) {
      return this.token = this.tokens[this.pos++];
    } else {
      return this.token = '';
    }
  };

  BoolExpressionTreeBuilder.prototype.build = function(tokens, predicates) {
    this.tokens = tokens;
    this.predicates = predicates;
    this.pos = 0;
    this._nextToken();
    return this._buildExpression();
  };

  BoolExpressionTreeBuilder.prototype._buildOuterExpression = function(left, inner) {
    if (!inner) {
      return this._buildExpression(left, true, false);
    } else {
      return left;
    }
  };

  BoolExpressionTreeBuilder.prototype._buildExpression = function(left, greedy, inner) {
    var innerExpr, outer, predicateExpr, right;
    if (left == null) {
      left = null;
    }
    if (greedy == null) {
      greedy = true;
    }
    if (inner == null) {
      inner = false;
    }
    switch (this.token) {
      case 'predicate':
        this._nextToken();
        predicateExpr = this._buildPredicateExpression();
        return (greedy ? this._buildExpression(predicateExpr, greedy, inner) : predicateExpr);
      case 'or':
        this._nextToken();
        outer = new OrExpression('or', left, this._buildExpression(null, true, true));
        return this._buildOuterExpression(outer, inner);
      case 'or when':
        if (inner) {
          return left;
        }
        this._nextToken();
        outer = new OrExpression('or when', left, this._buildExpression(null, true, true));
        return this._buildOuterExpression(outer, inner);
      case 'and':
        this._nextToken();
        right = this._buildExpression(null, false);
        return this._buildExpression(new AndExpression('and', left, right), true);
      case 'and if':
        this._nextToken();
        outer = new AndExpression('and if', left, this._buildExpression(null, true, true));
        return this._buildOuterExpression(outer, inner);
      case '[':
        this._nextToken();
        innerExpr = this._buildExpression(null, true, true);
        assert(this.token === ']');
        this._nextToken();
        return (greedy ? this._buildExpression(innerExpr, greedy, false, true) : innerExpr);
      case ']':
      case '':
        return left;
      default:
        return assert(false);
    }
  };

  BoolExpressionTreeBuilder.prototype._buildPredicateExpression = function() {
    var predicate, predicateIndex;
    assert(this.token === '(');
    this._nextToken();
    predicateIndex = this.token;
    assert(typeof predicateIndex === "number");
    this._nextToken();
    assert(this.token === ')');
    this._nextToken();
    predicate = this.predicates[predicateIndex];
    return new PredicateExpression(predicate);
  };

  return BoolExpressionTreeBuilder;

})();

module.exports = {
  BoolExpression: BoolExpression,
  AndExpression: AndExpression,
  OrExpression: OrExpression,
  BoolExpressionTreeBuilder: BoolExpressionTreeBuilder
};
