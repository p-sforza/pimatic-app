
/*
Framework
=========
 */
var JaySchema, Promise, RJSON, S, _, assert, basicAuth, bodyParser, connectTimeout, cookieParser, cookieSession, declapi, engineIo, events, express, fs, i18n, jsonlint, methodOverride, path, socketIo, util,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

assert = require('cassert');

fs = require("fs");

JaySchema = require('jayschema');

RJSON = require('relaxed-json');

i18n = require('i18n');

express = require("express");

methodOverride = require('method-override');

connectTimeout = require('connect-timeout');

cookieParser = require('cookie-parser');

bodyParser = require('body-parser');

cookieSession = require('cookie-session');

basicAuth = require('basic-auth');

socketIo = require('socket.io');

engineIo = require.cache[require.resolve('socket.io')].require('engine.io');

Promise = require('bluebird');

path = require('path');

S = require('string');

_ = require('lodash');

declapi = require('decl-api');

util = require('util');

jsonlint = require('jsonlint');

events = require('events');

module.exports = function(env) {
  var Framework;
  Framework = (function(superClass) {
    extend(Framework, superClass);

    Framework.prototype.configFile = null;

    Framework.prototype.app = null;

    Framework.prototype.io = null;

    Framework.prototype.ruleManager = null;

    Framework.prototype.pluginManager = null;

    Framework.prototype.variableManager = null;

    Framework.prototype.deviceManager = null;

    Framework.prototype.groupManager = null;

    Framework.prototype.pageManager = null;

    Framework.prototype.database = null;

    Framework.prototype.config = null;

    Framework.prototype._publicPathes = {};

    function Framework(configFile) {
      var discoverEvent, fn, j, len, ref;
      this.configFile = configFile;
      assert(this.configFile != null);
      this.maindir = path.resolve(__dirname, '..');
      env.logger.winston.on("logged", (function(_this) {
        return function(level, msg, meta) {
          return _this._emitMessageLoggedEvent(level, msg, meta);
        };
      })(this));
      this.pluginManager = new env.plugins.PluginManager(this);
      this.pluginManager.on('updateProcessStatus', (function(_this) {
        return function(status, info) {
          return _this._emitUpdateProcessStatus(status, info);
        };
      })(this));
      this.pluginManager.on('updateProcessMessage', (function(_this) {
        return function(message, info) {
          return _this._emitUpdateProcessMessage(message, info);
        };
      })(this));
      this.packageJson = this.pluginManager.getInstalledPackageInfo('pimatic');
      env.logger.info("Starting pimatic version " + this.packageJson.version);
      this._loadConfig();
      this.pluginManager.pluginsConfig = this.config.plugins;
      this.userManager = new env.users.UserManager(this, this.config.users, this.config.roles);
      this.deviceManager = new env.devices.DeviceManager(this, this.config.devices);
      this.groupManager = new env.groups.GroupManager(this, this.config.groups);
      this.pageManager = new env.pages.PageManager(this, this.config.pages);
      this.variableManager = new env.variables.VariableManager(this, this.config.variables);
      this.ruleManager = new env.rules.RuleManager(this, this.config.rules);
      this.database = new env.database.Database(this, this.config.settings.database);
      this.deviceManager.on('deviceRemoved', (function(_this) {
        return function(device) {
          var group;
          group = _this.groupManager.getGroupOfDevice(device.id);
          if (group != null) {
            _this.groupManager.removeDeviceFromGroup(group.id, device.id);
          }
          return _this.pageManager.removeDeviceFromAllPages(device.id);
        };
      })(this));
      this.ruleManager.on('ruleRemoved', (function(_this) {
        return function(rule) {
          var group;
          group = _this.groupManager.getGroupOfRule(rule.id);
          if (group != null) {
            return _this.groupManager.removeRuleFromGroup(group.id, rule.id);
          }
        };
      })(this));
      this.variableManager.on('variableRemoved', (function(_this) {
        return function(variable) {
          var group;
          group = _this.groupManager.getGroupOfVariable(variable.name);
          if (group != null) {
            return _this.groupManager.removeVariableFromGroup(group.id, variable.name);
          }
        };
      })(this));
      ref = ['discover', 'discoverMessage', 'deviceDiscovered'];
      fn = (function(_this) {
        return function(discoverEvent) {
          return _this.deviceManager.on(discoverEvent, function(eventData) {
            var ref1;
            return (ref1 = _this.io) != null ? ref1.emit(discoverEvent, eventData) : void 0;
          });
        };
      })(this);
      for (j = 0, len = ref.length; j < len; j++) {
        discoverEvent = ref[j];
        fn(discoverEvent);
      }
      this._setupExpressApp();
    }

    Framework.prototype._normalizeScheme = function(scheme) {
      var isRequired, opt, optName, prop, ref, ref1, ref2, requiredProps, s;
      if (scheme._normalized) {
        return;
      }
      if (scheme.type === "object" && typeof scheme.properties === "object") {
        requiredProps = scheme.required || [];
        ref = scheme.properties;
        for (prop in ref) {
          if (!hasProp.call(ref, prop)) continue;
          s = ref[prop];
          isRequired = true;
          if (typeof s.required === "boolean") {
            if (s.required === false) {
              isRequired = false;
            }
            delete s.required;
          }
          if (s["default"] != null) {
            isRequired = false;
          }
          if (isRequired && !(indexOf.call(requiredProps, prop) >= 0)) {
            requiredProps.push(prop);
          }
          if (s != null) {
            this._normalizeScheme(s);
          }
          if (((ref1 = s.defines) != null ? ref1.options : void 0) != null) {
            ref2 = s.defines.options;
            for (optName in ref2) {
              if (!hasProp.call(ref2, optName)) continue;
              opt = ref2[optName];
              this._normalizeScheme(opt);
            }
          }
        }
        if (requiredProps.length > 0) {
          scheme.required = requiredProps;
        }
        if (scheme.additionalProperties == null) {
          scheme.additionalProperties = false;
        }
      }
      if (scheme.type === "array") {
        if (scheme.items != null) {
          this._normalizeScheme(scheme.items);
        }
      }
      return scheme._normalized = true;
    };

    Framework.prototype._validateConfig = function(config, schema, scope) {
      var e, errorMessage, errors, i, j, js, len;
      if (scope == null) {
        scope = "config";
      }
      js = new JaySchema();
      errors = js.validate(config, schema);
      if (errors.length > 0) {
        errorMessage = "Invalid " + scope + ": ";
        for (i = j = 0, len = errors.length; j < len; i = ++j) {
          e = errors[i];
          if (i > 0) {
            errorMessage += ", ";
          }
          if (e.kind === "ObjectValidationError" && e.constraintName === "required") {
            errorMessage += e.desc.replace(/^missing: (.*)$/, 'Missing property "$1"');
          } else if (e.kind === "ObjectValidationError" && e.constraintName === "additionalProperties" && (e.testedValue != null)) {
            errorMessage += "Property \"" + e.testedValue + "\" is not a valid property";
          } else if (e.desc != null) {
            errorMessage += e.desc;
          } else {
            errorMessage += ("Property \"" + e.instanceContext + "\" Should have " + e.constraintName + " ") + ("" + e.constraintValue);
            if (e.testedValue != null) {
              errorMessage += ", was: " + e.testedValue;
            }
          }
          if ((e.instanceContext != null) && e.instanceContext.length > 1) {
            errorMessage += " in " + e.instanceContext.replace('#', '');
          }
        }
        return env.logger.error(errorMessage);
      }
    };

    Framework.prototype._loadConfig = function() {
      var auth, contents, i, instance, j, len, ref, ref1, role, schema;
      schema = require("../config-schema");
      contents = fs.readFileSync(this.configFile).toString();
      instance = jsonlint.parse(RJSON.transform(contents));
      auth = (ref = instance.settings) != null ? ref.authentication : void 0;
      if (((auth != null ? auth.username : void 0) != null) && ((auth != null ? auth.password : void 0) != null) && (instance.users == null)) {
        if (instance.users == null) {
          instance.users = [
            {
              username: auth.username,
              password: auth.password,
              role: "admin"
            }
          ];
          delete auth.username;
          delete auth.password;
          env.logger.warn("Move user authentication setting to new users definition!");
        }
      }
      this._normalizeScheme(schema);
      this._validateConfig(instance, schema);
      this.config = declapi.enhanceJsonSchemaWithDefaults(schema, instance);
      ref1 = this.config.roles;
      for (i = j = 0, len = ref1.length; j < len; i = ++j) {
        role = ref1[i];
        this.config.roles[i] = declapi.enhanceJsonSchemaWithDefaults(schema.properties.roles.items, role);
      }
      assert(Array.isArray(this.config.plugins));
      assert(Array.isArray(this.config.devices));
      assert(Array.isArray(this.config.pages));
      assert(Array.isArray(this.config.groups));
      this._checkConfig(this.config);
      env.logger.winston.transports.taggedConsoleLogger.level = this.config.settings.logLevel;
      if (this.config.settings.debug) {
        env.logger.logDebug = true;
        env.logger.debug("settings.debug is true, showing debug output for pimatic core.");
      }
      i18n.configure({
        locales: ['en', 'de'],
        directory: __dirname + '/../locales',
        defaultLocale: this.config.settings.locale
      });
      return events.EventEmitter.defaultMaxListeners = this.config.settings.defaultMaxListeners;
    };

    Framework.prototype._checkConfig = function(config) {
      var checkForDublicate, deviceId, found, group, item, j, k, l, len, len1, len2, len3, len4, logWarning, m, o, page, ref, ref1, ref2, ref3, ref4, results, ruleId, variableName;
      checkForDublicate = (function(_this) {
        return function(type, collection, idProperty) {
          var e, id, ids, j, len, results;
          ids = {};
          results = [];
          for (j = 0, len = collection.length; j < len; j++) {
            e = collection[j];
            id = e[idProperty];
            if (ids[id] != null) {
              throw new Error("Duplicate " + type + " " + id + " in config.");
            }
            results.push(ids[id] = true);
          }
          return results;
        };
      })(this);
      checkForDublicate("plugin", config.plugins, 'plugin');
      checkForDublicate("device", config.devices, 'id');
      checkForDublicate("rules", config.rules, 'id');
      checkForDublicate("variables", config.variables, 'name');
      checkForDublicate("groups", config.groups, 'id');
      checkForDublicate("pages", config.pages, 'id');
      logWarning = function(type, id, name, collection) {
        if (collection == null) {
          collection = "group";
        }
        return env.logger.warn(("Could not find a " + type + " with the ID \"" + id + "\" from ") + (collection + " \"" + name + "\" in " + type + "s config section."));
      };
      ref = config.groups;
      for (j = 0, len = ref.length; j < len; j++) {
        group = ref[j];
        ref1 = group.devices;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          deviceId = ref1[k];
          found = _.find(config.devices, {
            id: deviceId
          });
          if (found == null) {
            logWarning('device', deviceId, group.id);
          }
        }
        ref2 = group.rules;
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          ruleId = ref2[l];
          found = _.find(config.rules, {
            id: ruleId
          });
          if (found == null) {
            logWarning('rule', ruleId, group.id);
          }
        }
        ref3 = group.variables;
        for (m = 0, len3 = ref3.length; m < len3; m++) {
          variableName = ref3[m];
          found = _.find(config.variables, {
            name: variableName
          });
          if (found == null) {
            logWarning('variable', variableName, group.id);
          }
        }
      }
      ref4 = config.pages;
      results = [];
      for (o = 0, len4 = ref4.length; o < len4; o++) {
        page = ref4[o];
        results.push((function() {
          var len5, q, ref5, results1;
          ref5 = page.devices;
          results1 = [];
          for (q = 0, len5 = ref5.length; q < len5; q++) {
            item = ref5[q];
            found = _.find(config.devices, {
              id: item.deviceId
            });
            if (found == null) {
              results1.push(logWarning('device', item.deviceId, page.id, 'page'));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    };

    Framework.prototype._setupExpressApp = function() {
      var actionsWithBindings, auth, checkPermissions, engine, extraHeaders, http, https, httpsConfig, httpsOptions, j, len, name, onError, onUpgrade, ref, ref1, ref2, ref3, ref4, ref5, serverEnabled, socketIoPath, user, validPassword, validSecret, validUsername, value;
      this.app = express();
      this.app.use(methodOverride('X-HTTP-Method-Override'));
      this.app.use(connectTimeout("5min", {
        respond: false
      }));
      extraHeaders = {};
      this.corsEnabled = (this.config.settings.cors != null) && !_.isEmpty(this.config.settings.cors.allowedOrigin);
      if (this.corsEnabled) {
        extraHeaders["Access-Control-Allow-Origin"] = this.config.settings.cors.allowedOrigin;
        extraHeaders["Access-Control-Allow-Credentials"] = true;
        extraHeaders["Access-Control-Allow-Methods"] = "GET,PUT,POST,DELETE";
        extraHeaders["Access-Control-Allow-Headers"] = "Content-Type, Authorization";
      }
      this.app.use((function(_this) {
        return function(req, res, next) {
          var key, value;
          for (key in extraHeaders) {
            if (!hasProp.call(extraHeaders, key)) continue;
            value = extraHeaders[key];
            res.header(key, value);
          }
          if (_this.corsEnabled && req.method === 'OPTIONS') {
            return res.sendStatus(200);
          }
          req.on("timeout", function() {
            env.logger.warn("http request handler timeout. Possible unhandled request: " + req.method + " " + req.url);
            if (req.body != null) {
              return env.logger.debug(req.body);
            }
          });
          return next();
        };
      })(this));
      this.app.use(cookieParser());
      this.app.use(bodyParser.urlencoded({
        limit: '10mb',
        extended: true
      }));
      this.app.use(bodyParser.json({
        limit: '10mb'
      }));
      auth = this.config.settings.authentication;
      validSecret = (auth.secret != null) && typeof auth.secret === "string" && auth.secret.length >= 32;
      if (!validSecret) {
        auth.secret = require('crypto').randomBytes(64).toString('base64');
      }
      assert(typeof auth.secret === "string");
      assert(auth.secret.length >= 32);
      this.app.use(cookieSession({
        secret: auth.secret,
        key: 'pimatic.sess',
        cookie: {
          maxAge: null
        }
      }));
      assert((ref = auth.enabled) === true || ref === false);
      if (auth.enabled === true) {
        ref1 = this.config.users;
        for (j = 0, len = ref1.length; j < len; j++) {
          user = ref1[j];
          validUsername = (user.username != null) && typeof user.username === "string" && user.username.length !== 0;
          if (!validUsername) {
            throw new Error("Authentication is enabled, but no username has been defined for the user. " + "Please define a username in the user section of the config.json file.");
          }
          validPassword = (user.password != null) && typeof user.password === "string" && user.password.length !== 0;
          if (!validPassword) {
            throw new Error("Authentication is enabled, but no password has been defined for the user " + ("\"" + user.username + "\". Please define a password for \"" + user.username + "\" ") + "in the users section of the config.json file or disable authentication.");
          }
        }
      }
      this.app.use((function(_this) {
        return function(req, res, next) {
          var authInfo, loggedIn, role, unauthorized;
          if (req.path === "/login") {
            return next();
          }
          if (auth.enabled === false) {
            req.session.username = '';
            return next();
          }
          if (_this.userManager.isPublicAccessAllowed(req)) {
            return next();
          }
          loggedIn = typeof req.session.username === "string" && typeof req.session.loginToken === "string" && req.session.username.length > 0 && req.session.loginToken.length > 0 && _this.userManager.checkLoginToken(auth.secret, req.session.username, req.session.loginToken);
          if (loggedIn) {
            return next();
          }
          unauthorized = function(res) {
            res.set('WWW-Authenticate', 'Basic realm=Authorization Required');
            return res.status(401).send("Unauthorized");
          };
          authInfo = basicAuth(req);
          if (!authInfo || !authInfo.name || !authInfo.pass) {
            return unauthorized(res);
          }
          if (_this.userManager.checkLogin(authInfo.name, authInfo.pass)) {
            role = _this.userManager.getUserByUsername(authInfo.name).role;
            assert((role != null) && typeof role === "string" && role.length > 0);
            req.session.username = authInfo.name;
            req.session.loginToken = _this.userManager.getLoginTokenForUsername(auth.secret, authInfo.name);
            req.session.role = role;
            return next();
          } else {
            delete req.session.username;
            delete req.session.loginToken;
            delete req.session.role;
            return unauthorized(res);
          }
        };
      })(this));
      this.app.post('/login', (function(_this) {
        return function(req, res) {
          var password, rememberMe, role;
          user = req.body.username;
          password = req.body.password;
          rememberMe = req.body.rememberMe;
          if (rememberMe === 'true') {
            rememberMe = true;
          }
          if (rememberMe === 'false') {
            rememberMe = false;
          }
          rememberMe = !!rememberMe;
          if (_this.userManager.checkLogin(user, password)) {
            role = _this.userManager.getUserByUsername(user).role;
            assert((role != null) && typeof role === "string" && role.length > 0);
            req.session.username = user;
            req.session.loginToken = _this.userManager.getLoginTokenForUsername(auth.secret, user);
            req.session.role = role;
            req.session.rememberMe = rememberMe;
            if (rememberMe && auth.loginTime !== 0) {
              req.sessionOptions.maxAge = auth.loginTime;
            } else {
              req.sessionOptions.maxAge = null;
            }
            return res.send({
              success: true,
              username: user,
              role: role,
              rememberMe: rememberMe
            });
          } else {
            delete req.session.username;
            delete req.session.loginToken;
            delete req.session.role;
            delete req.session.rememberMe;
            return res.status(401).send({
              success: false,
              message: __("Wrong username or password.")
            });
          }
        };
      })(this));
      this.app.get('/logout', (function(_this) {
        return function(req, res) {
          req.session = null;
          res.status(401).send("You are now logged out.");
        };
      })(this));
      serverEnabled = ((ref2 = this.config.settings.httpsServer) != null ? ref2.enabled : void 0) || ((ref3 = this.config.settings.httpServer) != null ? ref3.enabled : void 0);
      if (!serverEnabled) {
        env.logger.warn("You have no HTTPS and no HTTP server enabled!");
      }
      this._initRestApi();
      socketIoPath = '/socket.io';
      engine = new engineIo.Server({
        path: socketIoPath
      });
      this.io = new socketIo();
      this.io.use((function(_this) {
        return function(socket, next) {
          var loggedIn, req;
          if (auth.enabled === false) {
            return next();
          }
          req = socket.request;
          if ((req.query.username != null) && (req.query.password != null)) {
            if (_this.userManager.checkLogin(req.query.username, req.query.password)) {
              socket.username = req.query.username;
              return next();
            } else {
              return next(new Error('unauthorizied'));
            }
          } else if (req.session != null) {
            loggedIn = typeof req.session.username === "string" && typeof req.session.loginToken === "string" && req.session.username.length > 0 && req.session.loginToken.length > 0 && _this.userManager.checkLoginToken(auth.secret, req.session.username, req.session.loginToken);
            if (loggedIn) {
              socket.username = req.session.username;
              return next();
            } else {
              return next(new Error('Authentication error'));
            }
          } else {
            return next(new Error('Unauthorized'));
          }
        };
      })(this));
      this.io.bind(engine);
      this.app.all('/socket.io/socket.io.js', (function(_this) {
        return function(req, res) {
          return _this.io.serve(req, res);
        };
      })(this));
      this.app.all('/socket.io/*', (function(_this) {
        return function(req, res) {
          return engine.handleRequest(req, res);
        };
      })(this));
      this.app.use((function(_this) {
        return function(err, req, res, next) {
          env.logger.error("Error on incoming http request to " + req.path + ": " + err.message);
          env.logger.debug(err);
          if (!res.headersSent) {
            return res.status(500).send(err.stack);
          }
        };
      })(this));
      onUpgrade = (function(_this) {
        return function(req, socket, head) {
          if (socketIoPath === req.url.substr(0, socketIoPath.length)) {
            engine.handleUpgrade(req, socket, head);
          } else {
            socket.end();
          }
        };
      })(this);
      if ((ref4 = this.config.settings.httpsServer) != null ? ref4.enabled : void 0) {
        httpsConfig = this.config.settings.httpsServer;
        assert(httpsConfig instanceof Object);
        assert(typeof httpsConfig.keyFile === 'string' && httpsConfig.keyFile.length !== 0);
        assert(typeof httpsConfig.certFile === 'string' && httpsConfig.certFile.length !== 0);
        httpsOptions = {};
        for (name in httpsConfig) {
          value = httpsConfig[name];
          httpsOptions[name] = value;
        }
        httpsOptions.key = fs.readFileSync(path.resolve(this.maindir, '../..', httpsConfig.keyFile));
        httpsOptions.cert = fs.readFileSync(path.resolve(this.maindir, '../..', httpsConfig.certFile));
        https = require("https");
        this.app.httpsServer = https.createServer(httpsOptions, this.app);
        this.app.httpsServer.on('upgrade', onUpgrade);
      }
      if ((ref5 = this.config.settings.httpServer) != null ? ref5.enabled : void 0) {
        http = require("http");
        this.app.httpServer = http.createServer(this.app);
        this.app.httpServer.on('upgrade', onUpgrade);
      }
      actionsWithBindings = [[env.api.framework.actions, this], [env.api.rules.actions, this.ruleManager], [env.api.variables.actions, this.variableManager], [env.api.plugins.actions, this.pluginManager], [env.api.database.actions, this.database], [env.api.groups.actions, this.groupManager], [env.api.pages.actions, this.pageManager], [env.api.devices.actions, this.deviceManager]];
      onError = (function(_this) {
        return function(error) {
          env.logger.error(error.message);
          return env.logger.debug(error);
        };
      })(this);
      checkPermissions = (function(_this) {
        return function(socket, action) {
          var hasPermission;
          if (auth.enabled === false) {
            return true;
          }
          hasPermission = false;
          if ((action.permission != null) && (action.permission.scope != null)) {
            hasPermission = _this.userManager.hasPermission(socket.username, action.permission.scope, action.permission.access);
          } else if ((action.permission != null) && (action.permission.action != null)) {
            hasPermission = _this.userManager.hasPermissionBoolean(socket.username, action.permission.action);
          } else {
            hasPermission = true;
          }
          return hasPermission;
        };
      })(this);
      return this.io.on('connection', (function(_this) {
        return function(socket) {
          var d, needsRules, permissions, r, role, username, v;
          declapi.createSocketIoApi(socket, actionsWithBindings, onError, checkPermissions);
          if (auth.enabled === true) {
            username = socket.username;
            role = _this.userManager.getUserByUsername(username).role;
            permissions = _this.userManager.getPermissionsByUsername(username);
          } else {
            username = 'nobody';
            role = 'no';
            permissions = {
              pages: "write",
              rules: "write",
              variables: "write",
              messages: "write",
              events: "write",
              devices: "write",
              groups: "write",
              plugins: "write",
              updates: "write",
              controlDevices: true,
              restart: true
            };
          }
          socket.emit('hello', {
            username: username,
            role: role,
            permissions: permissions
          });
          if (auth.enabled === false || _this.userManager.hasPermission(username, 'devices', 'read') || _this.userManager.hasPermission(username, 'pages', 'read')) {
            socket.emit('devices', (function() {
              var k, len1, ref6, results;
              ref6 = this.deviceManager.getDevices();
              results = [];
              for (k = 0, len1 = ref6.length; k < len1; k++) {
                d = ref6[k];
                results.push(d.toJson());
              }
              return results;
            }).call(_this));
          } else {
            socket.emit('devices', []);
          }
          if (auth.enabled === false || _this.userManager.hasPermission(username, 'rules', 'read')) {
            socket.emit('rules', (function() {
              var k, len1, ref6, results;
              ref6 = this.ruleManager.getRules();
              results = [];
              for (k = 0, len1 = ref6.length; k < len1; k++) {
                r = ref6[k];
                results.push(r.toJson());
              }
              return results;
            }).call(_this));
          } else {
            socket.emit('rules', []);
          }
          if (auth.enabled === false || _this.userManager.hasPermission(username, 'rules', 'read')) {
            socket.emit('variables', (function() {
              var k, len1, ref6, results;
              ref6 = this.variableManager.getVariables();
              results = [];
              for (k = 0, len1 = ref6.length; k < len1; k++) {
                v = ref6[k];
                results.push(v.toJson());
              }
              return results;
            }).call(_this));
          } else {
            socket.emit('variables', []);
          }
          if (auth.enabled === false || _this.userManager.hasPermission(username, 'pages', 'read')) {
            socket.emit('pages', _this.pageManager.getPages(role));
          } else {
            socket.emit('pages', []);
          }
          needsRules = auth.enabled === false || _this.userManager.hasPermission(username, 'devices', 'read') || _this.userManager.hasPermission(username, 'rules', 'read') || _this.userManager.hasPermission(username, 'variables', 'read') || _this.userManager.hasPermission(username, 'pages', 'read') || _this.userManager.hasPermission(username, 'groups', 'read');
          if (needsRules) {
            return socket.emit('groups', _this.groupManager.getGroups());
          } else {
            return socket.emit('groups', []);
          }
        };
      })(this));
    };

    Framework.prototype.listen = function() {
      var awaiting, genErrFunc, httpServerConfig, httpsServerConfig, listenPromises;
      genErrFunc = (function(_this) {
        return function(serverConfig) {
          return function(err) {
            var msg;
            msg = "Could not listen on port " + serverConfig.port + ". Error: " + err.message + ". ";
            switch (err.code) {
              case "EACCES":
                msg += "Are you root?.";
                break;
              case "EADDRINUSE":
                msg += "Is a server already running?";
            }
            env.logger.error(msg);
            env.logger.debug(err.stack);
            err.silent = true;
            throw err;
          };
        };
      })(this);
      listenPromises = [];
      if (this.app.httpsServer != null) {
        httpsServerConfig = this.config.settings.httpsServer;
        this.app.httpsServer.on('error', genErrFunc(httpsServerConfig));
        awaiting = Promise.fromCallback((function(_this) {
          return function(callback) {
            return _this.app.httpsServer.listen(httpsServerConfig.port, httpsServerConfig.hostname, callback);
          };
        })(this));
        listenPromises.push(awaiting.then((function(_this) {
          return function() {
            return env.logger.info("Listening for HTTPS-request on port " + httpsServerConfig.port + "...");
          };
        })(this)));
      }
      if (this.app.httpServer != null) {
        httpServerConfig = this.config.settings.httpServer;
        this.app.httpServer.on('error', genErrFunc(this.config.settings.httpServer));
        awaiting = Promise.fromCallback((function(_this) {
          return function(callback) {
            return _this.app.httpServer.listen(httpServerConfig.port, httpServerConfig.hostname, callback);
          };
        })(this));
        listenPromises.push(awaiting.then((function(_this) {
          return function() {
            return env.logger.info("Listening for HTTP-request on port " + httpServerConfig.port + "...");
          };
        })(this)));
      }
      return Promise.all(listenPromises).then((function(_this) {
        return function() {
          return _this.emit("server listen", "startup");
        };
      })(this));
    };

    Framework.prototype.restart = function() {
      var proxy;
      if (process.env['PIMATIC_DAEMONIZED'] == null) {
        throw new Error('Can not restart self, when not daemonized. ' + 'Please run pimatic with: "node ' + process.argv[1] + ' start" to use this feature.');
      }
      env.logger.info("Restarting...");
      proxy = new events();
      this.destroy()["catch"](function(err) {
        env.logger.error("Error during orderly shutdown of pimatic: " + err.message);
        return env.logger.debug(err.stack);
      })["finally"](function() {
        var args, child, daemon, scriptName;
        daemon = require('daemon');
        scriptName = process.argv[1];
        args = process.argv.slice(2);
        args[0] = 'restart';
        child = daemon.daemon(scriptName, args, {
          cwd: process.cwd()
        });
        child.on('error', function(error) {
          return proxy.emit('error', error);
        });
        return child.on('close', function(code) {
          return proxy.emit('close', code);
        });
      });
      return new Promise((function(_this) {
        return function(resolve, reject) {
          proxy.on('error', reject);
          return proxy.on('close', function(code) {
            if (code === 0) {
              return resolve();
            } else {
              return reject(new Error("Error restarting pimatic, exit code " + code));
            }
          });
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          env.logger.error("Error restarting pimatic: " + err.message);
          return env.logger.debug(err.stack);
        };
      })(this));
    };

    Framework.prototype.getGuiSettings = function() {
      return {
        config: this.config.settings.gui,
        defaults: this.config.settings.gui.__proto__
      };
    };

    Framework.prototype._emitDeviceAttributeEvent = function(device, attributeName, attribute, time, value) {
      var ref;
      this.emit('deviceAttributeChanged', {
        device: device,
        attributeName: attributeName,
        attribute: attribute,
        time: time,
        value: value
      });
      return (ref = this.io) != null ? ref.emit('deviceAttributeChanged', {
        deviceId: device.id,
        attributeName: attributeName,
        time: time.getTime(),
        value: value
      }) : void 0;
    };

    Framework.prototype._emitDeviceEvent = function(eventType, device) {
      var ref;
      this.emit(eventType, device);
      return (ref = this.io) != null ? ref.emit(eventType, device.toJson()) : void 0;
    };

    Framework.prototype._emitDeviceAdded = function(device) {
      return this._emitDeviceEvent('deviceAdded', device);
    };

    Framework.prototype._emitDeviceChanged = function(device) {
      return this._emitDeviceEvent('deviceChanged', device);
    };

    Framework.prototype._emitDeviceRemoved = function(device) {
      return this._emitDeviceEvent('deviceRemoved', device);
    };

    Framework.prototype._emitDeviceOrderChanged = function(deviceOrder) {
      return this._emitOrderChanged('deviceOrderChanged', deviceOrder);
    };

    Framework.prototype._emitMessageLoggedEvent = function(level, msg, meta) {
      var ref;
      this.emit('messageLogged', {
        level: level,
        msg: msg,
        meta: meta
      });
      return (ref = this.io) != null ? ref.emit('messageLogged', {
        level: level,
        msg: msg,
        meta: meta
      }) : void 0;
    };

    Framework.prototype._emitOrderChanged = function(eventName, order) {
      var ref;
      this.emit(eventName, order);
      return (ref = this.io) != null ? ref.emit(eventName, order) : void 0;
    };

    Framework.prototype._emitPageEvent = function(eventType, page) {
      var ref;
      this.emit(eventType, page);
      return (ref = this.io) != null ? ref.emit(eventType, page) : void 0;
    };

    Framework.prototype._emitPageAdded = function(page) {
      return this._emitPageEvent('pageAdded', page);
    };

    Framework.prototype._emitPageChanged = function(page) {
      return this._emitPageEvent('pageChanged', page);
    };

    Framework.prototype._emitPageRemoved = function(page) {
      return this._emitPageEvent('pageRemoved', page);
    };

    Framework.prototype._emitPageOrderChanged = function(pageOrder) {
      return this._emitOrderChanged('pageOrderChanged', pageOrder);
    };

    Framework.prototype._emitGroupEvent = function(eventType, group) {
      var ref;
      this.emit(eventType, group);
      return (ref = this.io) != null ? ref.emit(eventType, group) : void 0;
    };

    Framework.prototype._emitGroupAdded = function(group) {
      return this._emitGroupEvent('groupAdded', group);
    };

    Framework.prototype._emitGroupChanged = function(group) {
      return this._emitGroupEvent('groupChanged', group);
    };

    Framework.prototype._emitGroupRemoved = function(group) {
      return this._emitGroupEvent('groupRemoved', group);
    };

    Framework.prototype._emitGroupOrderChanged = function(proupOrder) {
      return this._emitOrderChanged('groupOrderChanged', proupOrder);
    };

    Framework.prototype._emitRuleEvent = function(eventType, rule) {
      var ref;
      this.emit(eventType, rule);
      return (ref = this.io) != null ? ref.emit(eventType, rule.toJson()) : void 0;
    };

    Framework.prototype._emitRuleAdded = function(rule) {
      return this._emitRuleEvent('ruleAdded', rule);
    };

    Framework.prototype._emitRuleRemoved = function(rule) {
      return this._emitRuleEvent('ruleRemoved', rule);
    };

    Framework.prototype._emitRuleChanged = function(rule) {
      return this._emitRuleEvent('ruleChanged', rule);
    };

    Framework.prototype._emitRuleOrderChanged = function(ruleOrder) {
      return this._emitOrderChanged('ruleOrderChanged', ruleOrder);
    };

    Framework.prototype._emitVariableEvent = function(eventType, variable) {
      var ref;
      this.emit(eventType, variable);
      return (ref = this.io) != null ? ref.emit(eventType, variable.toJson()) : void 0;
    };

    Framework.prototype._emitVariableAdded = function(variable) {
      return this._emitVariableEvent('variableAdded', variable);
    };

    Framework.prototype._emitVariableRemoved = function(variable) {
      return this._emitVariableEvent('variableRemoved', variable);
    };

    Framework.prototype._emitVariableChanged = function(variable) {
      return this._emitVariableEvent('variableChanged', variable);
    };

    Framework.prototype._emitVariableValueChanged = function(variable, value) {
      var ref;
      this.emit("variableValueChanged", variable, value);
      return (ref = this.io) != null ? ref.emit("variableValueChanged", {
        variableName: variable.name,
        variableValue: value
      }) : void 0;
    };

    Framework.prototype._emitVariableOrderChanged = function(variableOrder) {
      return this._emitOrderChanged('variableOrderChanged', variableOrder);
    };

    Framework.prototype._emitUpdateProcessStatus = function(status, info) {
      var ref;
      this.emit('updateProcessStatus', status, info);
      return (ref = this.io) != null ? ref.emit("updateProcessStatus", {
        status: status,
        modules: info.modules
      }) : void 0;
    };

    Framework.prototype._emitUpdateProcessMessage = function(message, info) {
      var ref;
      this.emit('updateProcessMessages', message, info);
      return (ref = this.io) != null ? ref.emit("updateProcessMessage", {
        message: message,
        modules: info.modules
      }) : void 0;
    };

    Framework.prototype.init = function() {
      var initActionProvider, initDevices, initPredicateProvider, initRules, initVariables;
      initVariables = (function(_this) {
        return function() {
          _this.variableManager.init();
          _this.variableManager.on("variableChanged", function(changedVar) {
            var j, len, ref, variable;
            ref = _this.config.variables;
            for (j = 0, len = ref.length; j < len; j++) {
              variable = ref[j];
              if (variable.name === changedVar.name) {
                delete variable.value;
                delete variable.expression;
                switch (changedVar.type) {
                  case 'value':
                    variable.value = changedVar.value;
                    break;
                  case 'expression':
                    variable.expression = changedVar.exprInputStr;
                }
                break;
              }
            }
            _this._emitVariableChanged(changedVar);
            return _this.emit("config");
          });
          _this.variableManager.on("variableValueChanged", function(changedVar, value) {
            var j, len, ref, variable;
            if (changedVar.type === 'value') {
              ref = _this.config.variables;
              for (j = 0, len = ref.length; j < len; j++) {
                variable = ref[j];
                if (variable.name === changedVar.name) {
                  variable.value = value;
                  break;
                }
              }
              _this.emit("config");
            }
            return _this._emitVariableValueChanged(changedVar, value);
          });
          _this.variableManager.on("variableAdded", function(addedVar) {
            switch (addedVar.type) {
              case 'value':
                _this.config.variables.push({
                  name: addedVar.name,
                  value: addedVar.value
                });
                break;
              case 'expression':
                _this.config.variables.push({
                  name: addedVar.name,
                  expression: addedVar.exprInputStr
                });
            }
            _this._emitVariableAdded(addedVar);
            return _this.emit("config");
          });
          return _this.variableManager.on("variableRemoved", function(removedVar) {
            var i, j, len, ref, variable;
            ref = _this.config.variables;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              variable = ref[i];
              if (variable.name === removedVar.name) {
                _this.config.variables.splice(i, 1);
                break;
              }
            }
            _this._emitVariableRemoved(removedVar);
            return _this.emit("config");
          });
        };
      })(this);
      initDevices = (function(_this) {
        return function() {
          _this.deviceManager.on("deviceRemoved", function(removedDevice) {
            var device, i, j, len, ref;
            ref = _this.config.devices;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              device = ref[i];
              if (device.id === removedDevice.id) {
                _this.config.devices.splice(i, 1);
                break;
              }
            }
            _this._emitDeviceRemoved(removedDevice);
            return _this.emit("config");
          });
          return _this.deviceManager.on("deviceChanged", function(changedDevice) {
            var device, i, j, len, ref;
            ref = _this.config.devices;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              device = ref[i];
              if (device.id === changedDevice.id) {
                _this.config.devices[i] = changedDevice.config;
                break;
              }
            }
            _this._emitDeviceChanged(changedDevice);
            return _this.emit("config");
          });
        };
      })(this);
      initActionProvider = (function(_this) {
        return function() {
          var actProv, actProvInst, defaultActionProvider, j, len, results;
          defaultActionProvider = [env.actions.SetPresenceActionProvider, env.actions.ContactActionProvider, env.actions.SwitchActionProvider, env.actions.DimmerActionProvider, env.actions.LogActionProvider, env.actions.SetVariableActionProvider, env.actions.ShutterActionProvider, env.actions.StopShutterActionProvider, env.actions.ButtonActionProvider, env.actions.ToggleActionProvider, env.actions.HeatingThermostatModeActionProvider, env.actions.HeatingThermostatSetpointActionProvider, env.actions.TimerActionProvider, env.actions.AVPlayerPauseActionProvider, env.actions.AVPlayerStopActionProvider, env.actions.AVPlayerPlayActionProvider, env.actions.AVPlayerVolumeActionProvider, env.actions.AVPlayerNextActionProvider, env.actions.AVPlayerPrevActionProvider];
          results = [];
          for (j = 0, len = defaultActionProvider.length; j < len; j++) {
            actProv = defaultActionProvider[j];
            actProvInst = new actProv(_this);
            results.push(_this.ruleManager.addActionProvider(actProvInst));
          }
          return results;
        };
      })(this);
      initPredicateProvider = (function(_this) {
        return function() {
          var defaultPredicateProvider, j, len, predProv, predProvInst, results;
          defaultPredicateProvider = [env.predicates.PresencePredicateProvider, env.predicates.SwitchPredicateProvider, env.predicates.DeviceAttributePredicateProvider, env.predicates.VariablePredicateProvider, env.predicates.VariableUpdatedPredicateProvider, env.predicates.ContactPredicateProvider, env.predicates.ButtonPredicateProvider, env.predicates.DeviceAttributeWatchdogProvider, env.predicates.StartupPredicateProvider];
          results = [];
          for (j = 0, len = defaultPredicateProvider.length; j < len; j++) {
            predProv = defaultPredicateProvider[j];
            predProvInst = new predProv(_this);
            results.push(_this.ruleManager.addPredicateProvider(predProvInst));
          }
          return results;
        };
      })(this);
      initRules = (function(_this) {
        return function() {
          var addRulePromises, rule;
          addRulePromises = (function() {
            var j, len, ref, results;
            ref = this.config.rules;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              rule = ref[j];
              results.push((function(_this) {
                return function(rule) {
                  var force, newId;
                  if (rule.active == null) {
                    rule.active = true;
                  }
                  if (!rule.id.match(/^[a-z0-9\-_]+$/i)) {
                    newId = S(rule.id).slugify().s;
                    env.logger.warn("The ID of the rule \"" + rule.id + "\" contains a non alphanumeric letter or symbol.\nChanging the ID of the rule to \"" + newId + "\".");
                    rule.id = newId;
                  }
                  if (rule.rule.match(/^if .+/)) {
                    env.logger.warn("Converting old rule \"" + rule.id + "\" from  \"if ... then ...\" to \"when ... then ...\"!");
                    rule.rule = rule.rule.replace(/^if/, "when");
                  }
                  if (rule.name == null) {
                    rule.name = S(rule.id).humanize().s;
                  }
                  return _this.ruleManager.addRuleByString(rule.id, {
                    name: rule.name,
                    ruleString: rule.rule,
                    active: rule.active,
                    logging: rule.logging
                  }, force = true)["catch"](function(err) {
                    env.logger.error(("Could not parse rule \"" + rule.rule + "\": ") + err.message);
                    return env.logger.debug(err.stack);
                  });
                };
              })(this)(rule));
            }
            return results;
          }).call(_this);
          return Promise.all(addRulePromises).then(function() {
            _this.ruleManager.on("ruleAdded", function(rule) {
              var inConfig;
              inConfig = _.findIndex(_this.config.rules, {
                id: rule.id
              }) !== -1;
              if (!inConfig) {
                _this.config.rules.push({
                  id: rule.id,
                  name: rule.name,
                  rule: rule.string,
                  active: rule.active,
                  logging: rule.logging
                });
              }
              _this._emitRuleAdded(rule);
              return _this.emit("config");
            });
            _this.ruleManager.on("ruleChanged", function(rule) {
              var r;
              _this.config.rules = (function() {
                var j, len, ref, results;
                ref = this.config.rules;
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                  r = ref[j];
                  if (r.id === rule.id) {
                    results.push({
                      id: rule.id,
                      name: rule.name,
                      rule: rule.string,
                      active: rule.active,
                      logging: rule.logging
                    });
                  } else {
                    results.push(r);
                  }
                }
                return results;
              }).call(_this);
              _this._emitRuleChanged(rule);
              return _this.emit("config");
            });
            return _this.ruleManager.on("ruleRemoved", function(rule) {
              var r;
              _this.config.rules = (function() {
                var j, len, ref, results;
                ref = this.config.rules;
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                  r = ref[j];
                  if (r.id !== rule.id) {
                    results.push(r);
                  }
                }
                return results;
              }).call(_this);
              _this._emitRuleRemoved(rule);
              return _this.emit("config");
            });
          });
        };
      })(this);
      return this.database.init().then((function(_this) {
        return function() {
          return _this.pluginManager.checkNpmVersion();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.pluginManager.loadPlugins();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.pluginManager.initPlugins();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.deviceManager.initDevices();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.deviceManager.loadDevices();
        };
      })(this)).then(initVariables).then(initDevices).then(initActionProvider).then(initPredicateProvider).then(initRules).then((function(_this) {
        return function() {
          var context;
          _this.on("config", function() {
            return _this.saveConfig();
          });
          context = {
            waitFor: [],
            waitForIt: function(promise) {
              return this.waitFor.push(promise);
            }
          };
          _this.emit("after init", context);
          return Promise.all(context.waitFor).then(function() {
            return _this.listen();
          });
        };
      })(this));
    };

    Framework.prototype._initRestApi = function() {
      var auth, createPermissionCheck, onError;
      auth = this.config.settings.authentication;
      onError = (function(_this) {
        return function(error) {
          var message;
          if (error instanceof Error) {
            message = error.message;
            env.logger.error(error.message);
            return env.logger.debug(error.stack);
          }
        };
      })(this);
      this.app.get("/api", (function(_this) {
        return function(req, res, nest) {
          return res.send(declapi.stringifyApi(env.api.all));
        };
      })(this));
      this.app.get("/api/decl-api-client.js", declapi.serveClient);
      createPermissionCheck = (function(_this) {
        return function(app, actions) {
          var action, actionName, results;
          results = [];
          for (actionName in actions) {
            action = actions[actionName];
            results.push((function(actionName, action) {
              var type, url;
              if ((action.rest != null) && (action.permission != null)) {
                type = (action.rest.type || 'get').toLowerCase();
                url = action.rest.url;
                return app[type](url, function(req, res, next) {
                  var hasPermission, username;
                  if (auth.enabled === true) {
                    username = req.session.username;
                    if (action.permission.scope != null) {
                      hasPermission = _this.userManager.hasPermission(username, action.permission.scope, action.permission.access);
                    } else if (action.permission.action != null) {
                      hasPermission = _this.userManager.hasPermissionBoolean(username, action.permission.action);
                    } else {
                      throw new Error("Unknown permissions declaration for action " + action);
                    }
                  } else {
                    username = "nobody";
                    hasPermission = true;
                  }
                  if (hasPermission === true) {
                    _this.userManager.requestUsername = username;
                    next();
                    return _this.userManager.requestUsername = null;
                  } else {
                    return res.status(403).send();
                  }
                });
              }
            })(actionName, action));
          }
          return results;
        };
      })(this);
      createPermissionCheck(this.app, env.api.framework.actions);
      createPermissionCheck(this.app, env.api.rules.actions);
      createPermissionCheck(this.app, env.api.variables.actions);
      createPermissionCheck(this.app, env.api.plugins.actions);
      createPermissionCheck(this.app, env.api.database.actions);
      createPermissionCheck(this.app, env.api.groups.actions);
      createPermissionCheck(this.app, env.api.pages.actions);
      createPermissionCheck(this.app, env.api.devices.actions);
      declapi.createExpressRestApi(this.app, env.api.framework.actions, this, onError);
      declapi.createExpressRestApi(this.app, env.api.rules.actions, this.ruleManager, onError);
      declapi.createExpressRestApi(this.app, env.api.variables.actions, this.variableManager, onError);
      declapi.createExpressRestApi(this.app, env.api.plugins.actions, this.pluginManager, onError);
      declapi.createExpressRestApi(this.app, env.api.database.actions, this.database, onError);
      declapi.createExpressRestApi(this.app, env.api.groups.actions, this.groupManager, onError);
      declapi.createExpressRestApi(this.app, env.api.pages.actions, this.pageManager, onError);
      return declapi.createExpressRestApi(this.app, env.api.devices.actions, this.deviceManager, onError);
    };

    Framework.prototype.getConfig = function(password) {
      var blankSecrets, configCopy, schema;
      blankSecrets = function(schema, obj) {
        var e, j, len, n, p, ref, results, results1;
        switch (schema.type) {
          case "object":
            if (schema.properties != null) {
              ref = schema.properties;
              results = [];
              for (n in ref) {
                p = ref[n];
                if (p.secret && (obj[n] != null)) {
                  obj[n] = 'xxxxxxxxxx';
                }
                if (obj[n] != null) {
                  results.push(blankSecrets(p, obj[n]));
                } else {
                  results.push(void 0);
                }
              }
              return results;
            }
            break;
          case "array":
            if ((schema.items != null) && (obj != null)) {
              results1 = [];
              for (j = 0, len = obj.length; j < len; j++) {
                e = obj[j];
                results1.push(blankSecrets(schema.items, e));
              }
              return results1;
            }
        }
      };
      schema = require("../config-schema");
      configCopy = _.cloneDeep(this.config);
      delete configCopy['//'];
      assert(this.userManager.requestUsername);
      if (password != null) {
        if (typeof password !== "string") {
          throw new Error("Password is not a string");
        }
        if (!this.userManager.checkLogin(this.userManager.requestUsername, password)) {
          throw new Error("Invalid password");
        }
      } else {
        blankSecrets(schema, configCopy);
      }
      return configCopy;
    };

    Framework.prototype.updateConfig = function(config) {
      var classInfo, deviceConfig, err, fullPluginName, j, k, len, len1, pConf, packageInfo, pathToSchema, pluginConfigSchema, ref, ref1, schema, warnings;
      schema = require("../config-schema");
      this._normalizeScheme(schema);
      this._validateConfig(config, schema);
      assert(Array.isArray(config.plugins));
      assert(Array.isArray(config.devices));
      assert(Array.isArray(config.pages));
      assert(Array.isArray(config.groups));
      this._checkConfig(config);
      ref = config.plugins;
      for (j = 0, len = ref.length; j < len; j++) {
        pConf = ref[j];
        fullPluginName = "pimatic-" + pConf.plugin;
        packageInfo = null;
        try {
          packageInfo = this.pluginManager.getInstalledPackageInfo(fullPluginName);
        } catch (error1) {
          err = error1;
          env.logger.warn(("Could not open package.json for \"" + fullPluginName + "\": " + err.message + " ") + "Could not validate config.");
          continue;
        }
        if ((packageInfo != null ? packageInfo.configSchema : void 0) != null) {
          pathToSchema = path.resolve(this.pluginManager.pathToPlugin(fullPluginName), packageInfo.configSchema);
          pluginConfigSchema = require(pathToSchema);
          this._normalizeScheme(pluginConfigSchema);
          this._validateConfig(pConf, pluginConfigSchema, "config of " + fullPluginName);
        } else {
          env.logger.warn(("package.json of \"" + fullPluginName + "\" has no \"configSchema\" property. ") + "Could not validate config.");
        }
      }
      ref1 = config.devices;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        deviceConfig = ref1[k];
        classInfo = this.deviceManager.deviceClasses[deviceConfig["class"]];
        if (classInfo == null) {
          env.logger.debug("Unknown device class \"" + deviceConfig["class"] + "\"");
          continue;
        }
        warnings = [];
        if (classInfo.prepareConfig != null) {
          classInfo.prepareConfig(deviceConfig);
        }
        this._normalizeScheme(classInfo.configDef);
        this._validateConfig(deviceConfig, classInfo.configDef, "config of device " + deviceConfig.id);
      }
      this.config = config;
      this.saveConfig();
      this.restart();
    };

    Framework.prototype.destroy = function() {
      if (this._destroying != null) {
        return this._destroying;
      }
      return this._destroying = Promise.resolve().then((function(_this) {
        return function() {
          var context;
          context = {
            waitFor: [],
            waitForIt: function(promise) {
              return this.waitFor.push(promise);
            }
          };
          _this.emit("destroy", context);
          _this.saveConfig();
          return Promise.all(context.waitFor);
        };
      })(this));
    };

    Framework.prototype.saveConfig = function() {
      var err;
      assert(this.config != null);
      try {
        return fs.writeFileSync(this.configFile, JSON.stringify(this.config, null, 2));
      } catch (error1) {
        err = error1;
        env.logger.error("Could not write config file: ", err.message);
        env.logger.debug(err);
        return env.logger.info("config.json updated");
      }
    };

    return Framework;

  })(events.EventEmitter);
  return {
    Framework: Framework
  };
};
