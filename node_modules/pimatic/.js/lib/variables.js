
/*
Variable Manager
===========
 */
var M, Promise, S, _, assert, humanFormat, isNumber, util, varsAst,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

assert = require('cassert');

util = require('util');

Promise = require('bluebird');

_ = require('lodash');

S = require('string');

M = require('./matcher');

humanFormat = require('human-format');

isNumber = function(n) {
  return ("" + n).match(/^-?[0-9]+\.?[0-9]*$/) != null;
};

varsAst = require('./variables-ast-builder');

module.exports = function(env) {
  var DeviceAttributeVariable, ExpressionValueVariable, Variable, VariableManager, exports;
  Variable = (function() {
    Variable.prototype.name = null;

    Variable.prototype.value = null;

    Variable.prototype.type = 'value';

    Variable.prototype.readonly = false;

    Variable.prototype.unit = null;

    function Variable(_vars, name1, type1, unit1, readonly) {
      this._vars = _vars;
      this.name = name1;
      this.type = type1;
      this.unit = unit1;
      this.readonly = readonly;
      assert(this._vars != null);
      assert(this._vars instanceof VariableManager);
      assert(typeof this.name === "string");
      assert(typeof this.type === "string");
      assert(typeof this.readonly === "boolean");
    }

    Variable.prototype.getCurrentValue = function() {
      return this.value;
    };

    Variable.prototype._setValue = function(value) {
      var numValue;
      if (isNumber(value)) {
        numValue = parseFloat(value);
        if (!isNaN(numValue)) {
          value = numValue;
        }
      }
      this.value = value;
      this._vars._emitVariableValueChanged(this, this.value);
      return true;
    };

    Variable.prototype.toJson = function() {
      return {
        name: this.name,
        readonly: this.readonly,
        type: this.type,
        value: this.value,
        unit: this.unit || ''
      };
    };

    return Variable;

  })();
  DeviceAttributeVariable = (function(superClass) {
    extend(DeviceAttributeVariable, superClass);

    function DeviceAttributeVariable(vars, _device, _attrName) {
      this._device = _device;
      this._attrName = _attrName;
      this.destroy = bind(this.destroy, this);
      DeviceAttributeVariable.__super__.constructor.call(this, vars, this._device.id + "." + this._attrName, 'attribute', this._device.attributes[this._attrName].unit, true);
      this._addListener();
    }

    DeviceAttributeVariable.prototype._addListener = function() {
      this._device.on(this._attrName, this._attrListener = (function(_this) {
        return function(value) {
          return _this._setValue(value);
        };
      })(this));
      this._device.on('changed', this._deviceChangedListener = (function(_this) {
        return function(newDevice) {
          if (newDevice.hasAttribute(_this._attrName)) {
            _this.unit = newDevice.attributes[_this._attrName].unit;
            _this._removeListener();
            _this._device = newDevice;
            return _this._addListener();
          } else {
            return _this._vars._removeDeviceAttributeVariable(_this.name);
          }
        };
      })(this));
      return this._device.on('destroyed', this._deviceDestroyedListener = (function(_this) {
        return function() {
          return _this._vars._removeDeviceAttributeVariable(_this.name);
        };
      })(this));
    };

    DeviceAttributeVariable.prototype._removeListener = function() {
      this._device.removeListener(this._attrName, this._attrListener);
      this._device.removeListener("changed", this._deviceChangedListener);
      return this._device.removeListener("destroyed", this._deviceDestroyedListener);
    };

    DeviceAttributeVariable.prototype.getUpdatedValue = function(varsInEvaluation) {
      if (varsInEvaluation == null) {
        varsInEvaluation = {};
      }
      return this._device.getUpdatedAttributeValue(this._attrName, varsInEvaluation);
    };

    DeviceAttributeVariable.prototype.destroy = function() {
      this._removeListener();
    };

    return DeviceAttributeVariable;

  })(Variable);
  ExpressionValueVariable = (function(superClass) {
    extend(ExpressionValueVariable, superClass);

    function ExpressionValueVariable(vars, name, type, unit, valueOrExpr) {
      if (valueOrExpr == null) {
        valueOrExpr = null;
      }
      ExpressionValueVariable.__super__.constructor.call(this, vars, name, type, unit, false);
      assert(type === 'value' || type === 'expression');
      if (valueOrExpr != null) {
        switch (type) {
          case 'value':
            this.setToValue(valueOrExpr, unit);
            break;
          case 'expression':
            this.setToExpression(valueOrExpr, unit);
            break;
          default:
            assert(false);
        }
      }
    }

    ExpressionValueVariable.prototype.setToValue = function(value, unit) {
      this._removeListener();
      this.type = "value";
      this._datatype = null;
      this.exprInputStr = null;
      this.exprTokens = null;
      this.unit = unit;
      return this._setValue(value);
    };

    ExpressionValueVariable.prototype.setToExpression = function(expression, unit) {
      var datatype, doUpdate, ref, t, tokens, variablesInExpr;
      ref = this._vars.parseVariableExpression(expression), tokens = ref.tokens, datatype = ref.datatype;
      this.exprInputStr = expression;
      this.exprTokens = tokens;
      this._datatype = datatype;
      this._removeListener();
      this.type = "expression";
      this.unit = unit;
      variablesInExpr = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = tokens.length; i < len; i++) {
          t = tokens[i];
          if (this._vars.isAVariable(t)) {
            results.push(t.substring(1));
          }
        }
        return results;
      }).call(this);
      doUpdate = ((function(_this) {
        return function() {
          return _this.getUpdatedValue().then(function(value) {
            return _this._setValue(value);
          })["catch"](function(error) {
            env.logger.error("Error updating expression value:", error.message);
            env.logger.debug(error);
            return error;
          });
        };
      })(this));
      this._vars.on('variableValueChanged', this._changeListener = (function(_this) {
        return function(changedVar, value) {
          var ref1;
          if (ref1 = changedVar.name, indexOf.call(variablesInExpr, ref1) < 0) {
            return;
          }
          return doUpdate();
        };
      })(this));
      return doUpdate();
    };

    ExpressionValueVariable.prototype._removeListener = function() {
      if (this._changeListener != null) {
        this._vars.removeListener('variableValueChanged', this._changeListener);
        return this.changeListener = null;
      }
    };

    ExpressionValueVariable.prototype.getUpdatedValue = function(varsInEvaluation) {
      if (varsInEvaluation == null) {
        varsInEvaluation = {};
      }
      if (this.type === "value") {
        return Promise.resolve(this.value);
      } else {
        assert(this.exprTokens != null);
        return this._vars.evaluateExpression(this.exprTokens, varsInEvaluation);
      }
    };

    ExpressionValueVariable.prototype.toJson = function() {
      var jsonObject;
      jsonObject = ExpressionValueVariable.__super__.toJson.call(this);
      if (this.type === "expression") {
        jsonObject.exprInputStr = this.exprInputStr;
        jsonObject.exprTokens = this.exprTokens;
      }
      return jsonObject;
    };

    ExpressionValueVariable.prototype.destroy = function() {
      return this._removeListener();
    };

    return ExpressionValueVariable;

  })(Variable);

  /*
  The Variable Manager
  ----------------
   */
  VariableManager = (function(superClass) {
    extend(VariableManager, superClass);

    VariableManager.prototype.variables = {};

    VariableManager.prototype.functions = {
      min: {
        args: {
          numbers: {
            type: "number",
            multiple: true
          }
        },
        exec: function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _.reduce(_.map(args, parseFloat), function(a, b) {
            return Math.min(a, b);
          });
        }
      },
      max: {
        args: {
          numbers: {
            type: "number",
            multiple: true
          }
        },
        exec: function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _.reduce(_.map(args, parseFloat), function(a, b) {
            return Math.max(a, b);
          });
        }
      },
      avg: {
        args: {
          numbers: {
            type: "number",
            multiple: true
          }
        },
        exec: function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _.reduce(_.map(args, parseFloat), function(a, b) {
            return a + b;
          }) / args.length;
        }
      },
      random: {
        args: {
          min: {
            type: "number"
          },
          max: {
            type: "number"
          }
        },
        exec: function(min, max) {
          var maxf, minf;
          minf = parseFloat(min);
          maxf = parseFloat(max);
          return Math.floor(Math.random() * (maxf + 1 - minf)) + minf;
        }
      },
      pow: {
        description: "Returns the base to the exponent power",
        args: {
          base: {
            description: "A numeric expression for base number",
            type: "number"
          },
          exponent: {
            description: "A numeric expression the exponent. If omitted base 2 is applied",
            type: "number",
            optional: true
          }
        },
        exec: function(base, exponent) {
          if (exponent == null) {
            exponent = 2;
          }
          return Math.pow(base, exponent);
        }
      },
      sqrt: {
        description: "Returns the square root of a number",
        args: {
          x: {
            description: "A numeric expression",
            type: "number"
          }
        },
        exec: function(x) {
          return Math.sqrt(x);
        }
      },
      cos: {
        description: "Returns the cosine of a number",
        args: {
          x: {
            description: "A numeric expression for the radians",
            type: "number"
          }
        },
        exec: function(x) {
          return Math.cos(x);
        }
      },
      acos: {
        description: "Returns the arccosine (in radians) of a number\nif it's between -1 and 1; otherwise, NaN",
        args: {
          x: {
            description: "A numeric expression",
            type: "number"
          }
        },
        exec: function(x) {
          return Math.acos(x);
        }
      },
      round: {
        args: {
          number: {
            type: "number"
          },
          decimals: {
            type: "number",
            optional: true
          }
        },
        exec: function(value, decimals) {
          var multiplier;
          if (decimals == null) {
            decimals = 0;
          }
          multiplier = Math.pow(10, decimals);
          return Math.round(value * multiplier) / multiplier;
        }
      },
      roundToNearest: {
        args: {
          number: {
            type: "number"
          },
          steps: {
            type: "number"
          }
        },
        exec: function(number, steps) {
          var decimals;
          steps = String(steps);
          decimals = (steps % 1 !== 0 ? steps.substr(steps.indexOf(".") + 1).length : 0);
          return Number((Math.round(number / steps) * steps).toFixed(decimals));
        }
      },
      timeFormat: {
        args: {
          number: {
            type: "number"
          }
        },
        exec: function(number) {
          var decimalMinutes, hours, minutes, seconds;
          hours = parseInt(number);
          decimalMinutes = (number - hours) * 60;
          minutes = Math.floor(decimalMinutes);
          seconds = Math.round((decimalMinutes % 1) * 60);
          if (seconds === 60) {
            minutes += 1;
            seconds = "0";
          }
          if (minutes === 60) {
            hours += 1;
            minutes = "0";
          }
          if (hours < 10) {
            hours = "0" + hours;
          }
          if (minutes < 10) {
            minutes = "0" + minutes;
          }
          if (seconds < 10) {
            seconds = "0" + seconds;
          }
          return hours + ":" + minutes + ":" + seconds;
        }
      },
      timeDecimal: {
        args: {
          time: {
            type: "string"
          }
        },
        exec: function(time) {
          var hours, minutes, seconds;
          hours = time.substr(0, time.indexOf(':'));
          minutes = time.substr(hours.length + 1, 2);
          seconds = time.substr(hours.length + minutes.length + 2, 2);
          return parseInt(hours) + parseFloat(minutes / 60) + parseFloat(seconds / 3600);
        }
      },
      date: {
        args: {
          format: {
            type: "string",
            optional: true
          }
        },
        exec: function(format) {
          return (new Date()).format(format != null ? format : 'YYYY-MM-DD hh:mm:ss');
        }
      },
      formatNumber: {
        args: {
          number: {
            type: "number"
          },
          decimals: {
            type: "number",
            optional: true
          },
          unit: {
            type: "string",
            optional: true
          }
        },
        exec: function(number, decimals, unit) {
          var formatted, info;
          if (unit == null) {
            unit = this.units[0];
            info = humanFormat.raw(number, {
              unit: unit
            });
            formatted = (decimals != null ? Number(info.value).toFixed(decimals) : info.value);
            return "" + formatted + info.prefix + unit;
          } else {
            if (decimals == null) {
              decimals = 2;
            }
            formatted = Number(number).toFixed(decimals);
            return "" + formatted + unit;
          }
        }
      },
      hexString: {
        description: "Converts a given number to a hex string",
        args: {
          number: {
            description: "The input number. Negative numbers will be treated as 32-bit\nsigned integers. Thus, numbers smaller than -2147483648 will\nbe cut off which is due to limitation of using bitwise operators\nin JavaScript. Positive integers will be handled up to 53-bit\nas JavaScript uses IEEE 754 double-precision floating point\nnumbers, internally",
            type: "number"
          },
          padding: {
            description: "Specifies the (minimum) number of digits the resulting string\nshall contain. The string will be padded by prepending leading\n\"0\" digits, accordingly. By default, padding is set to 0 which\nmeans no padding is performed",
            type: "number",
            optional: true
          },
          prefix: {
            description: "Specifies a prefix string which will be prepended to the\nresulting hex number. By default, no prefix is set",
            type: "string",
            optional: true
          }
        },
        exec: function(number, padding, prefix) {
          var error, hex;
          if (padding == null) {
            padding = 0;
          }
          if (prefix == null) {
            prefix = "";
          }
          try {
            padding = Math.max(Math.min(padding, 10), 0);
            hex = Number(number < 0 ? number >>> 0 : number).toString(16).toUpperCase();
            if (hex.length < padding) {
              hex = Array(padding + 1 - hex.length).join('0') + hex;
            }
            return prefix + hex;
          } catch (error1) {
            error = error1;
            env.logger.error("Error in hexString expression: " + error.message);
            throw error;
          }
        }
      },
      subString: {
        description: "Returns the substring of the given string matching the given regular expression\nand flags. If the global flag is used the resulting substring is a concatenation\nof all matches. If the expression contains capture groups the group matches will\nbe concatenated to provide the resulting substring. If there is no match the\nempty string is returned",
        args: {
          string: {
            description: "The input string which is a string expression which may also contain variable\nreferences and function calls",
            type: "string"
          },
          expression: {
            description: "A string value which may contain a regular expression",
            type: "string"
          },
          flags: {
            description: "A string with flags for a regular expression: g: global match,\ni: ignore case",
            type: "string",
            optional: true
          }
        },
        exec: function(string, expression, flags) {
          var error, matchResult;
          try {
            matchResult = string.match(new RegExp(expression, flags));
          } catch (error1) {
            error = error1;
            env.logger.error("Error in subString expression: " + error.message);
            throw error;
          }
          if (matchResult != null) {
            if ((flags != null) && flags.includes('g')) {
              return _.reduce(matchResult, function(fullMatch, val) {
                return fullMatch = fullMatch + val;
              });
            } else {
              if (_.isString(matchResult[1])) {
                matchResult.shift();
                return _.reduce(matchResult, function(fullMatch, val) {
                  if (_.isString(val)) {
                    return fullMatch = fullMatch + val;
                  }
                });
              } else {
                return matchResult[0];
              }
            }
          } else {
            env.logger.debug("subString expression did not match");
            return "";
          }
        }
      }
    };

    VariableManager.prototype.inited = false;

    function VariableManager(framework, variablesConfig) {
      this.framework = framework;
      this.variablesConfig = variablesConfig;
      this.framework.on('deviceAdded', (function(_this) {
        return function(device) {
          var attr, attrName, ref, results;
          ref = device.attributes;
          results = [];
          for (attrName in ref) {
            attr = ref[attrName];
            results.push(_this._addVariable(new DeviceAttributeVariable(_this, device, attrName)));
          }
          return results;
        };
      })(this));
    }

    VariableManager.prototype.init = function() {
      var fn, i, j, len, len1, ref, setExpr, setExpressions, variable;
      setExpressions = [];
      ref = this.variablesConfig;
      fn = (function(_this) {
        return function(variable) {
          var e, exprVar;
          assert((variable.name != null) && variable.name.length > 0);
          if (variable.name[0] === '$') {
            variable.name = variable.name.substring(1);
          }
          if (variable.expression != null) {
            try {
              exprVar = new ExpressionValueVariable(_this, variable.name, 'expression', variable.unit);
              _this._addVariable(exprVar);
              return setExpressions.push(function() {
                try {
                  return exprVar.setToExpression(variable.expression.trim());
                } catch (error1) {
                  env.logger.error("Error parsing expression variable " + variable.name + ":", e.message);
                  return env.logger.debug(e);
                }
              });
            } catch (error1) {
              e = error1;
              env.logger.error("Error adding expression variable " + variable.name + ":", e.message);
              return env.logger.debug(e.stack);
            }
          } else {
            return _this._addVariable(new ExpressionValueVariable(_this, variable.name, 'value', variable.unit, variable.value));
          }
        };
      })(this);
      for (i = 0, len = ref.length; i < len; i++) {
        variable = ref[i];
        fn(variable);
      }
      for (j = 0, len1 = setExpressions.length; j < len1; j++) {
        setExpr = setExpressions[j];
        setExpr();
      }
      this.inited = true;
      return this.emit('init');
    };

    VariableManager.prototype.waitForInit = function() {
      return new Promise((function(_this) {
        return function(resolve) {
          if (_this.inited) {
            return resolve();
          }
          return _this.once('init', resolve);
        };
      })(this));
    };

    VariableManager.prototype._addVariable = function(variable) {
      assert(variable instanceof Variable);
      assert(this.variables[variable.name] == null);
      this.variables[variable.name] = variable;
      Promise.resolve().then(function() {
        return variable.getUpdatedValue().then(function(value) {
          return variable._setValue(value);
        });
      })["catch"](function(error) {
        env.logger.warn("Could not update variable " + variable.name + ": " + error.message);
        return env.logger.debug(error);
      });
      this._emitVariableAdded(variable);
    };

    VariableManager.prototype._emitVariableValueChanged = function(variable, value) {
      return this.emit('variableValueChanged', variable, value);
    };

    VariableManager.prototype._emitVariableAdded = function(variable) {
      return this.emit('variableAdded', variable);
    };

    VariableManager.prototype._emitVariableChanged = function(variable) {
      return this.emit('variableChanged', variable);
    };

    VariableManager.prototype._emitVariableRemoved = function(variable) {
      return this.emit('variableRemoved', variable);
    };

    VariableManager.prototype.getVariablesAndFunctions = function(ops) {
      var filteredVars, i, len, v, variables;
      if (ops == null) {
        return {
          variables: this.variables,
          functions: this.functions
        };
      } else {
        filteredVars = _.filter(this.variables, ops);
        variables = {};
        for (i = 0, len = filteredVars.length; i < len; i++) {
          v = filteredVars[i];
          variables[v.name] = v;
        }
        return {
          variables: variables,
          functions: this.functions
        };
      }
    };

    VariableManager.prototype.parseVariableExpression = function(expression) {
      var context, datatype, m, tokens;
      tokens = null;
      context = M.createParseContext(this.variables, this.functions);
      m = M(expression, context).matchAnyExpression((function(_this) {
        return function(m, ts) {
          return tokens = ts;
        };
      })(this));
      if (!(m.hadMatch() && m.getFullMatch() === expression)) {
        throw new Error("Could not parse expression");
      }
      datatype = (tokens[0][0] === '"' ? "string" : "numeric");
      return {
        tokens: tokens,
        datatype: datatype
      };
    };

    VariableManager.prototype.setVariableToExpr = function(name, inputStr, unit) {
      var ref, variable;
      assert((name != null) && typeof name === "string");
      assert(typeof inputStr === "string" && inputStr.length > 0);
      if (this.variables[name] == null) {
        this._addVariable(variable = new ExpressionValueVariable(this, name, 'expression', unit, inputStr));
      } else {
        variable = this.variables[name];
        if ((ref = variable.type) !== "expression" && ref !== "value") {
          throw new Error("Can not set a non expression or value var to an expression");
        }
        variable.setToExpression(inputStr, unit);
        this._emitVariableChanged(variable);
      }
      return variable;
    };

    VariableManager.prototype._checkVariableName = function(name) {
      if (!name.match(/^[a-z0-9\-_]+$/i)) {
        throw new Error("Variable name must only contain alpha numerical symbols, \"-\" and  \"_\"");
      }
    };

    VariableManager.prototype.setVariableToValue = function(name, value, unit) {
      var ref, variable;
      assert((name != null) && typeof name === "string");
      this._checkVariableName(name);
      if (this.variables[name] == null) {
        this._addVariable(variable = new ExpressionValueVariable(this, name, 'value', unit, value));
      } else {
        variable = this.variables[name];
        if ((ref = variable.type) !== "expression" && ref !== "value") {
          throw new Error("Can not set a non expression or value var to an expression");
        }
        if (variable.type === "expression") {
          variable.setToValue(value, unit);
          this._emitVariableChanged(variable);
        } else if (variable.type === "value") {
          variable.setToValue(value, unit);
        }
      }
      return variable;
    };

    VariableManager.prototype.updateVariable = function(name, type, valueOrExpr, unit) {
      assert(type === "value" || type === "expression");
      if (!this.isVariableDefined(name)) {
        throw new Error("No variable with the name \"" + name + "\" found.");
      }
      return ((function() {
        switch (type) {
          case "value":
            return this.setVariableToValue(name, valueOrExpr, unit);
          case "expression":
            return this.setVariableToExpr(name, valueOrExpr, unit);
        }
      }).call(this));
    };

    VariableManager.prototype.addVariable = function(name, type, valueOrExpr, unit) {
      assert(type === "value" || type === "expression");
      if (this.isVariableDefined(name)) {
        throw new Error("There is already a variable with the name \"" + name + "\"");
      }
      return ((function() {
        switch (type) {
          case "value":
            return this.setVariableToValue(name, valueOrExpr, unit);
          case "expression":
            return this.setVariableToExpr(name, valueOrExpr, unit);
        }
      }).call(this));
    };

    VariableManager.prototype.isVariableDefined = function(name) {
      assert((name != null) && typeof name === "string");
      return this.variables[name] != null;
    };

    VariableManager.prototype.getVariableValue = function(name) {
      var ref;
      return (ref = this.variables[name]) != null ? ref.value : void 0;
    };

    VariableManager.prototype.getVariableUpdatedValue = function(name, varsInEvaluation) {
      if (varsInEvaluation == null) {
        varsInEvaluation = {};
      }
      assert((name != null) && typeof name === "string");
      if (this.variables[name] != null) {
        if (varsInEvaluation[name] != null) {
          if (varsInEvaluation[name].value != null) {
            return Promise.resolve(varsInEvaluation[name].value);
          } else {
            return Promise["try"]((function(_this) {
              return function() {
                throw new Error("Dependency cycle detected for variable " + name);
              };
            })(this));
          }
        } else {
          varsInEvaluation[name] = {};
          return this.variables[name].getUpdatedValue(varsInEvaluation).then((function(_this) {
            return function(value) {
              varsInEvaluation[name].value = value;
              return value;
            };
          })(this));
        }
      } else {
        return null;
      }
    };

    VariableManager.prototype.removeVariable = function(name) {
      var variable;
      assert((name != null) && typeof name === "string");
      variable = this.variables[name];
      if (variable != null) {
        if (variable.type === 'attribute') {
          throw new Error("Can not delete a variable for a device attribute.");
        }
        variable.destroy();
        delete this.variables[name];
        return this._emitVariableRemoved(variable);
      }
    };

    VariableManager.prototype._removeDeviceAttributeVariable = function(name) {
      var variable;
      assert((name != null) && typeof name === "string");
      variable = this.variables[name];
      if (variable != null) {
        if (variable.type !== 'attribute') {
          throw new Error("Not a device attribute.");
        }
        variable.destroy();
        delete this.variables[name];
        return this._emitVariableRemoved(variable);
      }
    };

    VariableManager.prototype.getVariables = function() {
      var name, v, variables, variablesInConfig;
      variables = (function() {
        var ref, results;
        ref = this.variables;
        results = [];
        for (name in ref) {
          v = ref[name];
          results.push(v);
        }
        return results;
      }).call(this);
      variablesInConfig = _.map(this.framework.config.variables, (function(_this) {
        return function(r) {
          return r.name;
        };
      })(this));
      return _.sortBy(variables, (function(_this) {
        return function(r) {
          return variablesInConfig.indexOf(r.name);
        };
      })(this));
    };

    VariableManager.prototype.getFunctions = function() {
      return this.functions;
    };

    VariableManager.prototype.getVariableByName = function(name) {
      var v;
      v = this.variables[name];
      if (v == null) {
        return null;
      }
      return v;
    };

    VariableManager.prototype.isAVariable = function(token) {
      return token.length > 0 && token[0] === '$';
    };

    VariableManager.prototype.extractVariables = function(tokens) {
      var t, vars;
      return (vars = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = tokens.length; i < len; i++) {
          t = tokens[i];
          if (this.isAVariable(t)) {
            results.push(t.substring(1));
          }
        }
        return results;
      }).call(this));
    };

    VariableManager.prototype.notifyOnChange = function(tokens, listener) {
      var changeListener, variablesInExpr;
      variablesInExpr = this.extractVariables(tokens);
      this.on('variableValueChanged', changeListener = (function(_this) {
        return function(changedVar, value) {
          var ref;
          if (ref = changedVar.name, indexOf.call(variablesInExpr, ref) < 0) {
            return;
          }
          return listener(changedVar);
        };
      })(this));
      return listener.__variableChangeListener = changeListener;
    };

    VariableManager.prototype.cancelNotifyOnChange = function(listener) {
      assert(typeof listener.__variableChangeListener === "function");
      return this.removeListener('variableValueChanged', listener.__variableChangeListener);
    };

    VariableManager.prototype.evaluateExpression = function(tokens, varsInEvaluation) {
      var builder;
      if (varsInEvaluation == null) {
        varsInEvaluation = {};
      }
      builder = new varsAst.ExpressionTreeBuilder(this.variables, this.functions);
      return Promise.resolve().then((function(_this) {
        return function() {
          var expr;
          expr = builder.build(tokens);
          return expr.evaluate(varsInEvaluation);
        };
      })(this));
    };

    VariableManager.prototype.evaluateExpressionWithUnits = function(tokens, varsInEvaluation) {
      var builder;
      if (varsInEvaluation == null) {
        varsInEvaluation = {};
      }
      builder = new varsAst.ExpressionTreeBuilder(this.variables, this.functions);
      return Promise.resolve().then((function(_this) {
        return function() {
          var expr;
          expr = builder.build(tokens);
          return expr.evaluate(varsInEvaluation).then(function(value) {
            return {
              value: value,
              unit: expr.getUnit()
            };
          });
        };
      })(this));
    };

    VariableManager.prototype.inferUnitOfExpression = function(tokens) {
      var builder, expr;
      builder = new varsAst.ExpressionTreeBuilder(this.variables, this.functions);
      expr = builder.build(tokens);
      return expr.getUnit();
    };

    VariableManager.prototype.evaluateNumericExpression = function(tokens, varsInEvaluation) {
      if (varsInEvaluation == null) {
        varsInEvaluation = {};
      }
      return this.evaluateExpression(tokens, varsInEvaluation);
    };

    VariableManager.prototype.evaluateStringExpression = function(tokens, varsInEvaluation) {
      if (varsInEvaluation == null) {
        varsInEvaluation = {};
      }
      return this.evaluateExpression(tokens, varsInEvaluation);
    };

    VariableManager.prototype.updateVariableOrder = function(variableOrder) {
      assert((variableOrder != null) && Array.isArray(variableOrder));
      this.framework.config.variables = this.variablesConfig = _.sortBy(this.variablesConfig, (function(_this) {
        return function(variable) {
          var index;
          index = variableOrder.indexOf(variable.name);
          if (index === -1) {
            return 99999;
          } else {
            return index;
          }
        };
      })(this));
      this.framework.saveConfig();
      this.framework._emitVariableOrderChanged(variableOrder);
      return variableOrder;
    };

    return VariableManager;

  })(require('events').EventEmitter);
  return exports = {
    VariableManager: VariableManager
  };
};
