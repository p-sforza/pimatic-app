
/*
Plugin Manager
=======
 */
var Promise, S, _, assert, byline, declapi, download, events, fs, https, path, rp, semver, spawn, util,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Promise = require('bluebird');

fs = require('fs.extra');

Promise.promisifyAll(fs);

path = require('path');

util = require('util');

assert = require('cassert');

byline = require('byline');

_ = require('lodash');

spawn = require("cross-spawn");

https = require("https");

semver = require("semver");

events = require('events');

S = require('string');

declapi = require('decl-api');

rp = require('request-promise');

download = require('gethub');

module.exports = function(env) {
  var Plugin, PluginManager, exports, getLatestCompatible, isCompatible, satisfyingVersion;
  isCompatible = function(refVersion, packageInfo) {
    var err, peerVersion, ref;
    try {
      peerVersion = (ref = packageInfo.peerDependencies) != null ? ref.pimatic : void 0;
      if (peerVersion != null) {
        if (semver.satisfies(refVersion, peerVersion)) {
          return true;
        }
      }
    } catch (error1) {
      err = error1;
      env.logger.error(err);
    }
    return false;
  };
  satisfyingVersion = function(p, refVersion) {
    var versions;
    versions = [];
    _.forEach(p.versions, (function(_this) {
      return function(value, key) {
        if (isCompatible(refVersion, value)) {
          return versions.push(key);
        }
      };
    })(this));
    return versions;
  };
  getLatestCompatible = function(packageInfo, refVersion) {
    var latestSatisfying, result, satisfyingV;
    result = packageInfo.versions[packageInfo['dist-tags'].latest];
    if (isCompatible(refVersion, result)) {
      return result;
    } else {
      satisfyingV = satisfyingVersion(packageInfo, refVersion);
      if (satisfyingV.length > 0) {
        latestSatisfying = satisfyingV[satisfyingV.length - 1];
        result = packageInfo.versions[latestSatisfying];
        return result;
      } else {
        return result;
      }
    }
    return result;
  };
  PluginManager = (function(superClass) {
    extend(PluginManager, superClass);

    PluginManager.prototype.plugins = [];

    PluginManager.prototype.updateProcessStatus = 'idle';

    PluginManager.prototype.updateProcessMessages = [];

    PluginManager.prototype.restartRequired = false;

    function PluginManager(framework) {
      this.framework = framework;
      this.modulesParentDir = path.resolve(this.framework.maindir, '../../');
    }

    PluginManager.prototype.checkNpmVersion = function() {
      return this.spawnPpm(['--version'])["catch"]((function(_this) {
        return function(err) {
          return env.logger.error("Could not run ppm, plugin and module installation will not work.");
        };
      })(this));
    };

    PluginManager.prototype.loadPlugin = function(name, config) {
      var packageInfo, packageInfoStr, plugin, pluginEnv;
      packageInfo = this.getInstalledPackageInfo(name);
      packageInfoStr = (packageInfo != null ? "(" + packageInfo.version + ")" : "");
      env.logger.info("Loading plugin: \"" + name + "\" " + packageInfoStr);
      pluginEnv = Object.create(env);
      pluginEnv.logger = env.logger.base.createSublogger(name, config.debug);
      if (config.debug) {
        env.logger.debug("debug is true in plugin config, showing debug output for " + name + ".");
      }
      plugin = (require(name))(pluginEnv, module);
      return Promise.resolve([plugin, packageInfo]);
    };

    PluginManager.prototype.isInstalled = function(name) {
      assert(name != null);
      assert(name.match(/^pimatic.*$/) != null);
      return fs.existsSync(this.pathToPlugin(name));
    };

    PluginManager.prototype.isGitRepo = function(name) {
      assert(name != null);
      assert(name.match(/^pimatic.*$/) != null);
      return fs.existsSync((this.pathToPlugin(name)) + "/.git");
    };

    PluginManager.prototype._getFullPlatfrom = function() {
      var abiVersion, arch, platform;
      abiVersion = process.versions.modules;
      platform = process.platform;
      arch = process.arch === "arm" ? "armhf" : process.arch;
      return "node-" + abiVersion + "-" + arch + "-" + platform;
    };

    PluginManager.prototype._findDist = function(plugin) {
      var dist, fullPlatform, j, len, ref;
      if ((plugin.dists == null) || plugin.dists.length === 0) {
        return null;
      }
      fullPlatform = this._getFullPlatfrom();
      ref = plugin.dists;
      for (j = 0, len = ref.length; j < len; j++) {
        dist = ref[j];
        if (dist.name.indexOf(fullPlatform) === 0) {
          return dist;
        }
      }
      return null;
    };

    PluginManager.prototype.installPlugin = function(name, update) {
      if (update == null) {
        update = false;
      }
      assert(name != null);
      assert(name.match(/^pimatic.*$/) != null);
      if (update) {
        if (this.isGitRepo(name)) {
          throw new Error("Can't update a git repository!");
        }
      }
      return this.getPluginInfo(name).then((function(_this) {
        return function(packageInfo) {
          var dist;
          if (packageInfo == null) {
            env.logger.warn(("Could not determine compatible version for \"" + name + "\"") + ", trying to installing latest version");
            env.logger.info("Installing: \"" + name + "\" from npm-registry.");
            if (update) {
              return _this.spawnPpm(['update', name, '--unsafe-perm']);
            } else {
              return _this.spawnPpm(['install', name, '--unsafe-perm']);
            }
          }
          dist = _this._findDist(packageInfo);
          if (dist) {
            if (update) {
              return _this.updateGitPlugin(name);
            } else {
              return _this.installGitPlugin(name);
            }
          }
          env.logger.info("Installing: \"" + name + "@" + packageInfo.version + "\" from npm-registry.");
          return _this.spawnPpm(['install', name + "@" + packageInfo.version, '--unsafe-perm']);
        };
      })(this));
    };

    PluginManager.prototype.updatePlugin = function(name) {
      return this.installPlugin(name, true);
    };

    PluginManager.prototype.uninstallPlugin = function(name) {
      var pluginDir;
      pluginDir = this.pathToPlugin(name);
      this.requrieRestart();
      return fs.rmrfAsync(pluginDir);
    };

    PluginManager.prototype._emitUpdateProcessStatus = function(status, info) {
      this.updateProcessStatus = status;
      return this.emit('updateProcessStatus', status, info);
    };

    PluginManager.prototype._emitUpdateProcessMessage = function(message, info) {
      this.updateProcessMessages.push(message);
      return this.emit('updateProcessMessage', message, info);
    };

    PluginManager.prototype.getUpdateProcessStatus = function() {
      return {
        status: this.updateProcessStatus,
        messages: this.updateProcessMessages
      };
    };

    PluginManager.prototype.install = function(modules) {
      var hasErrors, info, npmMessageListener;
      info = {
        modules: modules
      };
      this._emitUpdateProcessStatus('running', info);
      npmMessageListener = ((function(_this) {
        return function(line) {
          return _this._emitUpdateProcessMessage(line, info);
        };
      })(this));
      this.on('npmMessage', npmMessageListener);
      hasErrors = false;
      return Promise.each(modules, (function(_this) {
        return function(plugin) {
          return (_this.isInstalled(plugin) ? _this.updatePlugin(plugin) : _this.installPlugin(plugin))["catch"](function(error) {
            env.logger.error("Error installing plugin " + plugin + ": " + error.message);
            return env.logger.debug(error.stack);
          });
        };
      })(this)).then((function(_this) {
        return function() {
          _this._emitUpdateProcessStatus('done', info);
          _this.requrieRestart();
          _this.removeListener('npmMessage', npmMessageListener);
          return modules;
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          _this._emitUpdateProcessStatus('error', info);
          _this.removeListener('npmMessage', npmMessageListener);
          throw error;
        };
      })(this));
    };

    PluginManager.prototype.pathToPlugin = function(name) {
      assert(name != null);
      assert((name.match(/^pimatic.*$/) != null) || name === "pimatic");
      return path.resolve(this.framework.maindir, "..", name);
    };

    PluginManager.prototype.getPluginList = function() {
      if (this._pluginList) {
        return this._pluginList;
      } else {
        return this.searchForPlugin();
      }
    };

    PluginManager.prototype.getCoreInfo = function() {
      if (this._coreInfo) {
        return this._coreInfo;
      } else {
        return this.searchForCoreUpdate();
      }
    };

    PluginManager.prototype._tranformRequestErrors = function(err) {
      if (err.name === 'RequestError') {
        throw new Error("Could not connect to the pimatic update server: " + err.message + "\nEither the update server is currently not available or your internet connection is down.");
      }
      throw err;
    };

    PluginManager.prototype.searchForPlugin = function() {
      var version;
      version = this.framework.packageJson.version;
      return this._pluginList = rp("http://api.pimatic.org/plugins?version=" + version)["catch"](this._tranformRequestErrors).then((function(_this) {
        return function(res) {
          var json;
          json = JSON.parse(res);
          json.sort(function(a, b) {
            return a.name.localeCompare(b.name);
          });
          setTimeout((function() {
            return _this._pluginList = null;
          }), 60 * 1000);
          return json;
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          setTimeout((function() {
            return _this._pluginList = null;
          }), 1 * 1000);
          throw err;
        };
      })(this));
    };

    PluginManager.prototype.searchForCoreUpdate = function() {
      var version;
      version = this.framework.packageJson.version;
      return this._coreInfo = rp("http://api.pimatic.org/core?version=" + version)["catch"](this._tranformRequestErrors).then((function(_this) {
        return function(res) {
          var json;
          json = JSON.parse(res);
          setTimeout((function() {
            return _this._coreInfo = null;
          }), 60 * 1000);
          return json;
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          setTimeout((function() {
            return _this._coreInfo = null;
          }), 1 * 1000);
          throw err;
        };
      })(this));
    };

    PluginManager.prototype.getPluginInfo = function(name) {
      var pluginInfo;
      if (name === "pimatic") {
        return this.getCoreInfo();
      }
      pluginInfo = null;
      return this.getPluginList().then((function(_this) {
        return function(plugins) {
          return pluginInfo = _.find(plugins, function(p) {
            return p.name === name;
          });
        };
      })(this))["finally"]((function(_this) {
        return function() {
          if (pluginInfo == null) {
            env.logger.info("Could not get plugin info from update server, request info from npm");
            return pluginInfo = _this.getPluginInfoFromNpm(name);
          }
        };
      })(this)).then((function(_this) {
        return function() {
          return pluginInfo;
        };
      })(this));
    };

    PluginManager.prototype.getPluginInfoFromNpm = function(name) {
      return rp("https://registry.npmjs.org/" + name).then((function(_this) {
        return function(res) {
          var packageInfos;
          packageInfos = JSON.parse(res);
          if (packageInfos.error != null) {
            throw new Error("Error getting info about " + name + " from npm failed: " + info.reason);
          }
          return getLatestCompatible(packageInfos, _this.framework.packageJson.version);
        };
      })(this));
    };

    PluginManager.prototype.isCompatible = function(packageInfo) {
      var pimaticRange, ref, version;
      version = this.framework.packageJson.version;
      pimaticRange = (ref = packageInfo.peerDependencies) != null ? ref.pimatic : void 0;
      if (!pimaticRange) {
        return null;
      }
      return semver.satisfies(version, pimaticRange);
    };

    PluginManager.prototype.searchForPluginsWithInfo = function() {
      return this.searchForPlugin().then((function(_this) {
        return function(plugins) {
          var installed, listEntry, loadedPlugin, name, p, packageJson, pluginList;
          return pluginList = (function() {
            var j, len, results1;
            results1 = [];
            for (j = 0, len = plugins.length; j < len; j++) {
              p = plugins[j];
              name = p.name.replace('pimatic-', '');
              loadedPlugin = this.framework.pluginManager.getPlugin(name);
              installed = this.isInstalled(p.name);
              packageJson = (installed ? this.getInstalledPackageInfo(p.name) : null);
              results1.push(listEntry = {
                name: name,
                description: p.description,
                version: p.version,
                installed: installed,
                loaded: loadedPlugin != null,
                activated: this.isActivated(name),
                isNewer: (installed ? semver.gt(p.version, packageJson.version) : false),
                isCompatible: this.isCompatible(p)
              });
            }
            return results1;
          }).call(_this);
        };
      })(this));
    };

    PluginManager.prototype.isPimaticOutdated = function() {
      var installed;
      installed = this.getInstalledPackageInfo("pimatic");
      return this.getPluginInfo("pimatic").then((function(_this) {
        return function(latest) {
          if (semver.gt(latest.version, installed.version)) {
            return {
              current: installed.version,
              latest: latest.version
            };
          } else {
            return false;
          }
        };
      })(this));
    };

    PluginManager.prototype.getOutdatedPlugins = function() {
      return this.getInstalledPluginUpdateVersions().then((function(_this) {
        return function(result) {
          var j, len, outdated, p;
          outdated = [];
          for (j = 0, len = result.length; j < len; j++) {
            p = result[j];
            if (semver.gt(p.latest, p.current)) {
              outdated.push(p);
            }
          }
          return outdated;
        };
      })(this));
    };

    PluginManager.prototype.getInstalledPluginUpdateVersions = function() {
      return this.getInstalledPlugins().then((function(_this) {
        return function(plugins) {
          var fn, infos, j, len, p, waiting;
          waiting = [];
          infos = [];
          fn = function(p) {
            var installed;
            installed = _this.getInstalledPackageInfo(p);
            return waiting.push(_this.getPluginInfo(p).then(function(latest) {
              return infos.push({
                plugin: p,
                current: installed.version,
                latest: latest.version
              });
            }));
          };
          for (j = 0, len = plugins.length; j < len; j++) {
            p = plugins[j];
            fn(p);
          }
          return Promise.settle(waiting).then(function(results) {
            var info, k, l, len1, len2, r, ret;
            for (k = 0, len1 = results.length; k < len1; k++) {
              r = results[k];
              if (r.isRejected()) {
                env.logger.error(r.reason());
              }
            }
            ret = [];
            for (l = 0, len2 = infos.length; l < len2; l++) {
              info = infos[l];
              if (info.current == null) {
                env.logger.warn("Could not get the installed package version of " + info.plugin);
                continue;
              }
              if (info.latest == null) {
                env.logger.warn("Could not get the latest version of " + info.plugin);
                continue;
              }
              ret.push(info);
            }
            return ret;
          });
        };
      })(this));
    };

    PluginManager.prototype.spawnPpm = function(args) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var errCode, errorMessage, npm, npmEnv, npmLogger, onLine, output, ppmBin, stderr, stdout;
          if (_this.npmRunning) {
            reject("npm is currently in use");
            return;
          }
          _this.npmRunning = true;
          output = '';
          npmLogger = env.logger.createSublogger("ppm");
          errCode = null;
          errorMessage = null;
          onLine = (function(line) {
            var match;
            line = line.toString();
            if ((match = line.match(/ERR! code (E[A-Z]+)/)) != null) {
              errCode = match[1];
            }
            if ((match = line.match(/error .* requires a C\+\+11 compiler/)) != null) {
              errorMessage = match[0];
            }
            output += line + "\n";
            if (line.indexOf('npm http 304') === 0) {
              return;
            }
            if (line.match(/ERR! peerinvalid .*/)) {
              return;
            }
            _this.emit("npmMessage", line);
            line = S(line).chompLeft('npm ').s;
            return npmLogger.info(line);
          });
          npmEnv = _.clone(process.env);
          npmEnv['HOME'] = require('path').resolve(_this.framework.maindir, '../..');
          npmEnv['NPM_CONFIG_UNSAFE_PERM'] = true;
          ppmBin = './node_modules/pimatic/ppm.js';
          npm = spawn(ppmBin, args, {
            cwd: _this.modulesParentDir,
            env: npmEnv
          });
          stdout = byline(npm.stdout);
          stdout.on("data", onLine);
          stderr = byline(npm.stderr);
          stderr.on("data", onLine);
          return npm.on("close", function(code) {
            var command;
            _this.npmRunning = false;
            command = ppmBin + " " + _.reduce(args, function(akk, a) {
              return akk + " " + a;
            });
            if (code !== 0) {
              return reject(new Error(("Error running \"" + command + "\"") + (errorMessage != null ? ": " + errorMessage : "")));
            } else {
              return resolve(output);
            }
          });
        };
      })(this));
    };

    PluginManager.prototype.installGitPlugin = function(name) {
      return this.getPluginInfo(name).then((function(_this) {
        return function(plugin) {
          var destdir, dist, tmpDir;
          dist = _this._findDist(plugin);
          if (dist == null) {
            throw new Error("dist package not found");
          }
          env.logger.info("Installing: \"" + name + "\" from precompiled source (" + dist.name + ")");
          tmpDir = path.resolve(_this.framework.maindir, "..", "." + name + ".tmp");
          destdir = _this.pathToPlugin(name);
          return fs.rmrfAsync(tmpDir)["catch"]().then(function() {
            return download('pimatic-ci', name, dist.name, tmpDir);
          }).then(function() {
            return fs.rmrfAsync(destdir)["catch"]().then(function() {
              return fs.moveAsync(tmpDir, destdir);
            });
          })["finally"](function() {
            return fs.rmrfAsync(tmpDir);
          });
        };
      })(this));
    };

    PluginManager.prototype.updateGitPlugin = function(name) {
      return this.installGitPlugin(name);
    };

    PluginManager.prototype.getInstalledPlugins = function() {
      return fs.readdirAsync(this.framework.maindir + "/..").then((function(_this) {
        return function(files) {
          var f, plugins;
          return plugins = (function() {
            var j, len, results1;
            results1 = [];
            for (j = 0, len = files.length; j < len; j++) {
              f = files[j];
              if (f.match(/^pimatic-.*/) != null) {
                results1.push(f);
              }
            }
            return results1;
          })();
        };
      })(this));
    };

    PluginManager.prototype.getInstalledPluginsWithInfo = function() {
      return this.getInstalledPlugins().then((function(_this) {
        return function(plugins) {
          var listEntry, loadedPlugin, name, packageJson, pluginList;
          return pluginList = (function() {
            var j, len, results1;
            results1 = [];
            for (j = 0, len = plugins.length; j < len; j++) {
              name = plugins[j];
              packageJson = this.getInstalledPackageInfo(name);
              name = name.replace('pimatic-', '');
              loadedPlugin = this.framework.pluginManager.getPlugin(name);
              results1.push(listEntry = {
                name: name,
                loaded: loadedPlugin != null,
                activated: this.isActivated(name),
                description: packageJson.description,
                version: packageJson.version,
                homepage: packageJson.homepage,
                isCompatible: this.isCompatible(packageJson)
              });
            }
            return results1;
          }).call(_this);
        };
      })(this));
    };

    PluginManager.prototype.installUpdatesAsync = function(modules) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          _this.install(modules).then(resolve)["catch"](reject);
          return Promise.delay('still running', 10000).then(resolve);
        };
      })(this));
    };

    PluginManager.prototype.getInstalledPackageInfo = function(name) {
      assert(name != null);
      assert((name.match(/^pimatic.*$/) != null) || name === "pimatic");
      return JSON.parse(fs.readFileSync((this.pathToPlugin(name)) + "/package.json", 'utf-8'));
    };

    PluginManager.prototype.getNpmInfo = function(name) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return https.get("https://registry.npmjs.org/" + name + "/latest", function(res) {
            var str;
            str = "";
            res.on("data", function(chunk) {
              return str += chunk;
            });
            return res.on("end", function() {
              var e, info;
              try {
                info = JSON.parse(str);
                if (info.error != null) {
                  throw new Error("Getting info about " + name + " failed: " + info.reason);
                }
                return resolve(info);
              } catch (error1) {
                e = error1;
                return reject(e.message);
              }
            });
          }).on("error", reject);
        };
      })(this));
    };

    PluginManager.prototype.loadPlugins = function() {
      var chain, fn, i, j, len, pConf, ref;
      chain = Promise.resolve();
      ref = this.pluginsConfig;
      fn = (function(_this) {
        return function(pConf, i) {
          return chain = chain.then(function() {
            var fullPluginName;
            assert(pConf != null);
            assert(pConf instanceof Object);
            assert((pConf.plugin != null) && typeof pConf.plugin === "string");
            if (pConf.active === false) {
              return Promise.resolve();
            }
            fullPluginName = "pimatic-" + pConf.plugin;
            return Promise["try"](function() {
              return (_this.isInstalled(fullPluginName) ? Promise.resolve() : _this.installPlugin(fullPluginName)).then(function() {
                return _this.loadPlugin(fullPluginName, pConf).then(function(arg) {
                  var configSchema, packageInfo, plugin;
                  plugin = arg[0], packageInfo = arg[1];
                  configSchema = _this._getConfigSchemaFromPackageInfo(packageInfo);
                  if (typeof plugin.prepareConfig === "function") {
                    plugin.prepareConfig(pConf);
                  }
                  if (configSchema != null) {
                    _this.framework._validateConfig(pConf, configSchema, "config of " + fullPluginName);
                    pConf = declapi.enhanceJsonSchemaWithDefaults(configSchema, pConf);
                  } else {
                    env.logger.warn(("package.json of \"" + fullPluginName + "\" has no \"configSchema\" property. ") + "Could not validate config.");
                  }
                  return _this.registerPlugin(plugin, pConf, configSchema);
                });
              });
            });
          })["catch"](function(error) {
            env.logger.error(error.message);
            return env.logger.debug(error.stack);
          });
        };
      })(this);
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        pConf = ref[i];
        fn(pConf, i);
      }
      return chain;
    };

    PluginManager.prototype._getConfigSchemaFromPackageInfo = function(packageInfo) {
      var configSchema, pathToSchema;
      if (packageInfo.configSchema == null) {
        return null;
      }
      pathToSchema = path.resolve(this.pathToPlugin(packageInfo.name), packageInfo.configSchema);
      configSchema = require(pathToSchema);
      if (!configSchema._normalized) {
        configSchema.properties.plugin = {
          type: "string"
        };
        configSchema.properties.active = {
          type: "boolean",
          required: false
        };
        this.framework._normalizeScheme(configSchema);
      }
      return configSchema;
    };

    PluginManager.prototype.initPlugins = function() {
      var err, j, len, plugin, ref, results1;
      ref = this.plugins;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        plugin = ref[j];
        try {
          results1.push(plugin.plugin.init(this.framework.app, this.framework, plugin.config));
        } catch (error1) {
          err = error1;
          env.logger.error(("Could not initialize the plugin \"" + plugin.config.plugin + "\": ") + err.message);
          results1.push(env.logger.debug(err.stack));
        }
      }
      return results1;
    };

    PluginManager.prototype.registerPlugin = function(plugin, config, packageInfo) {
      assert((plugin != null) && plugin instanceof env.plugins.Plugin);
      assert((config != null) && config instanceof Object);
      this.plugins.push({
        plugin: plugin,
        config: config,
        packageInfo: packageInfo
      });
      return this.emit("plugin", plugin);
    };

    PluginManager.prototype.getPlugin = function(name) {
      var j, len, p, ref;
      assert(name != null);
      assert(typeof name === "string");
      ref = this.plugins;
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        if (p.config.plugin === name) {
          return p.plugin;
        }
      }
      return null;
    };

    PluginManager.prototype.getPluginConfig = function(name) {
      var j, len, plugin, ref;
      ref = this.framework.config.plugins;
      for (j = 0, len = ref.length; j < len; j++) {
        plugin = ref[j];
        if (plugin.plugin === name) {
          return plugin;
        }
      }
      return null;
    };

    PluginManager.prototype.isActivated = function(name) {
      var j, len, plugin, ref;
      ref = this.framework.config.plugins;
      for (j = 0, len = ref.length; j < len; j++) {
        plugin = ref[j];
        if (plugin.plugin === name) {
          if (plugin.active != null) {
            return plugin.active;
          } else {
            return true;
          }
        }
      }
      return false;
    };

    PluginManager.prototype.getPluginConfigSchema = function(name) {
      var packageInfo;
      assert(name != null);
      assert(typeof name === "string");
      packageInfo = this.getInstalledPackageInfo(name);
      return this._getConfigSchemaFromPackageInfo(packageInfo);
    };

    PluginManager.prototype.updatePluginConfig = function(pluginName, config) {
      var configSchema, fullPluginName, i, j, len, plugin, ref;
      assert(pluginName != null);
      assert(typeof pluginName === "string");
      config.plugin = pluginName;
      fullPluginName = "pimatic-" + pluginName;
      configSchema = this.getPluginConfigSchema(fullPluginName);
      if (configSchema != null) {
        this.framework._validateConfig(config, configSchema, "config of " + fullPluginName);
      }
      ref = this.framework.config.plugins;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        plugin = ref[i];
        if (plugin.plugin === pluginName) {
          this.framework.config.plugins[i] = config;
          this.framework.emit('config');
          return;
        }
      }
      this.framework.config.plugins.push(config);
      return this.framework.emit('config');
    };

    PluginManager.prototype.removePluginFromConfig = function(pluginName) {
      var removed;
      removed = _.remove(this.framework.config.plugins, (function(_this) {
        return function(p) {
          return p.plugin === pluginName;
        };
      })(this));
      if (removed.length > 0) {
        this.framework.emit('config');
      }
      return removed.length > 0;
    };

    PluginManager.prototype.setPluginActivated = function(pluginName, active) {
      var i, j, len, plugin, ref;
      ref = this.framework.config.plugins;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        plugin = ref[i];
        if (plugin.plugin === pluginName) {
          if (!!plugin.active !== !!active) {
            this.requrieRestart();
          }
          plugin.active = active;
          this.framework.emit('config');
          return true;
        }
      }
      return false;
    };

    PluginManager.prototype.getCallingPlugin = function() {
      var matches, stack;
      stack = new Error().stack.toString();
      matches = stack.match(/^.+?\/node_modules\/(pimatic-.+?)\//m);
      if (matches != null) {
        return matches[1];
      } else {
        return 'pimatic';
      }
    };

    PluginManager.prototype.requrieRestart = function() {
      return this.restartRequired = true;
    };

    PluginManager.prototype.doesRequireRestart = function() {
      return this.restartRequired;
    };

    return PluginManager;

  })(events.EventEmitter);
  Plugin = (function(superClass) {
    extend(Plugin, superClass);

    function Plugin() {
      return Plugin.__super__.constructor.apply(this, arguments);
    }

    Plugin.prototype.name = null;

    Plugin.prototype.init = function() {
      throw new Error("Your plugin must implement init");
    };

    return Plugin;

  })(require('events').EventEmitter);
  return exports = {
    PluginManager: PluginManager,
    Plugin: Plugin
  };
};
