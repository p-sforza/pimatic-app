var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = function(env) {
  var BaseCronPredicateHandler, CronJob, CronPlugin, CronPredicateProvider, EveryCronPredicateHandler, EveryCronPredicateProvider, ExprCronPredicateHandler, M, Promise, StringCronPredicateHandler, assert, chrono, milliseconds, plugin, spawn, util;
  spawn = require("child_process").spawn;
  util = require('util');
  Promise = env.require('bluebird');
  assert = env.require('cassert');
  M = env.matcher;
  chrono = require('chrono-node');
  CronJob = env.CronJob || require('cron').CronJob;
  milliseconds = env.require('./lib/milliseconds');
  CronPlugin = (function(superClass) {
    extend(CronPlugin, superClass);

    function CronPlugin() {
      this.init = bind(this.init, this);
      return CronPlugin.__super__.constructor.apply(this, arguments);
    }

    CronPlugin.prototype.init = function(app, framework1, config) {
      this.framework = framework1;
      this.config = config;
      this.framework.ruleManager.addPredicateProvider(new CronPredicateProvider(this.framework, this.config));
      return this.framework.ruleManager.addPredicateProvider(new EveryCronPredicateProvider(this.framework, this.config));
    };

    return CronPlugin;

  })(env.plugins.Plugin);
  plugin = new CronPlugin();
  CronPredicateProvider = (function(superClass) {
    extend(CronPredicateProvider, superClass);

    CronPredicateProvider.prototype.presets = [
      {
        name: "time",
        input: "its 8:00"
      }, {
        name: "before/after time",
        input: "its after 8:00"
      }
    ];

    function CronPredicateProvider(framework1, config) {
      this.framework = framework1;
      this.config = config;
      env.logger.info("the time is: " + (this.getTime()));
      return;
    }

    CronPredicateProvider.prototype.getTime = function() {
      return new Date();
    };

    CronPredicateProvider.prototype.parsePredicate = function(input, context) {
      var dateDetected, dateMatch, dateString, exprTokens, fullMatch, hadPrefix, modifier, nextInput, onDateStringExprMatch, onDateStringMatch, parseDateResults, parseResult, theTime;
      modifier = null;
      parseDateResults = null;
      dateMatch = null;
      dateDetected = false;
      dateString = null;
      fullMatch = null;
      nextInput = null;
      exprTokens = null;
      theTime = this.getTime();
      onDateStringMatch = ((function(_this) {
        return function(m, match) {
          var possibleDateString;
          possibleDateString = match.trim();
          parseDateResults = chrono.parse(possibleDateString, theTime);
          if (parseDateResults.length > 0 && parseDateResults[0].index === 0) {
            dateDetected = true;
            fullMatch = m.getFullMatch();
            dateString = possibleDateString;
            nextInput = m.getRemainingInput();
          }
          return m;
        };
      })(this));
      onDateStringExprMatch = ((function(_this) {
        return function(m, tokens) {
          exprTokens = tokens;
          dateDetected = true;
          fullMatch = m.getFullMatch();
          nextInput = m.getRemainingInput();
          return m;
        };
      })(this));
      hadPrefix = false;
      M(input, context).match(['its ', 'it is '], {
        optional: true,
        type: 'static'
      }, (function(_this) {
        return function(m, match) {
          return hadPrefix = true;
        };
      })(this)).match(['before ', 'after '], {
        param: 'modifier',
        type: 'select',
        optional: true
      }, (function(_this) {
        return function(m, match) {
          modifier = match.trim();
          return hadPrefix = true;
        };
      })(this)).or([
        ((function(_this) {
          return function(m) {
            return m.match(/^(.+?)($| for .*| and .*| or .*|\).*|\].*)/, {
              param: 'time',
              type: 'time'
            }, onDateStringMatch);
          };
        })(this)), ((function(_this) {
          return function(m) {
            if (hadPrefix) {
              return m.matchStringWithVars(onDateStringExprMatch);
            } else {
              return M(null, context);
            }
          };
        })(this)), ((function(_this) {
          return function(m) {
            if (hadPrefix) {
              return m.matchVariable(function(m, v) {
                return onDateStringExprMatch(m, [v]);
              });
            } else {
              return M(null, context);
            }
          };
        })(this))
      ]);
      if (dateDetected) {
        if (dateString != null) {
          if (parseDateResults.length === 0) {
            if (context != null) {
              context.addError("Could not parse date: \"" + dateMatch + "\"");
            }
            return null;
          } else if (parseDateResults.length > 1) {
            if (context != null) {
              context.addError("Multiple dates given: \"" + dateMatch + "\"");
            }
            return null;
          }
          parseResult = parseDateResults[0];
          if ((modifier === 'after' || modifier === 'before') && (parseResult.end != null)) {
            if (context != null) {
              context.addError("You can't give a date range when using \"" + modifier + "\"");
            }
          }
          if (modifier == null) {
            if (parseResult.end != null) {
              modifier = 'range';
            } else {
              modifier = 'exact';
            }
          }
        } else {
          assert(Array.isArray(exprTokens));
          if (modifier == null) {
            modifier = 'exact';
          }
        }
        assert(fullMatch != null);
        assert(nextInput != null);
        return {
          token: fullMatch,
          nextInput: nextInput,
          predicateHandler: (dateString != null ? new StringCronPredicateHandler(this, modifier, dateString) : new ExprCronPredicateHandler(this, modifier, exprTokens))
        };
      } else {
        return null;
      }
    };

    return CronPredicateProvider;

  })(env.predicates.PredicateProvider);
  BaseCronPredicateHandler = (function(superClass) {
    extend(BaseCronPredicateHandler, superClass);

    function BaseCronPredicateHandler(provider1, modifier1) {
      this.provider = provider1;
      this.modifier = modifier1;
    }

    BaseCronPredicateHandler.prototype._createJobs = function(dateString) {
      var day, dayOfWeek, hour, minute, month, parseResult, ref, ref1, second;
      parseResult = this._reparseDateString(dateString);
      if (parseResult == null) {
        throw new Error("\"" + dateString + "\" is not a valid date or time.");
      }
      ref = this._parseDateToCronFormat(parseResult.start), second = ref.second, minute = ref.minute, hour = ref.hour, day = ref.day, month = ref.month, dayOfWeek = ref.dayOfWeek;
      this.jobs = [];
      switch (this.modifier) {
        case 'exact':
          return this.jobs.push(new CronJob({
            cronTime: second + " " + minute + " " + hour + " " + day + " " + month + " " + dayOfWeek,
            onTick: (function(_this) {
              return function() {
                return _this.emit("change", 'event');
              };
            })(this),
            start: false
          }));
        case 'before':

          /*
          before means same day but before the time so the cronjob must trigger at 0:00
           */
          this.jobs.push(new CronJob({
            cronTime: "0 0 0 " + day + " " + month + " " + dayOfWeek,
            onTick: (function(_this) {
              return function() {
                return _this.emit("change", true);
              };
            })(this),
            start: false
          }));
          return this.jobs.push(new CronJob({
            cronTime: second + " " + minute + " " + hour + " " + day + " " + month + " " + dayOfWeek,
            onTick: (function(_this) {
              return function() {
                return _this.emit("change", false);
              };
            })(this),
            start: false
          }));
        case 'after':
          this.jobs.push(new CronJob({
            cronTime: second + " " + minute + " " + hour + " " + day + " " + month + " " + dayOfWeek,
            onTick: (function(_this) {
              return function() {
                return _this.emit("change", true);
              };
            })(this),
            start: false
          }));
          return this.jobs.push(new CronJob({
            cronTime: "59 59 23 " + day + " " + month + " " + dayOfWeek,
            onTick: (function(_this) {
              return function() {
                return _this.emit("change", false);
              };
            })(this),
            start: false
          }));
        case 'range':
          this.jobs.push(new CronJob({
            cronTime: second + " " + minute + " " + hour + " " + day + " " + month + " " + dayOfWeek,
            onTick: (function(_this) {
              return function() {
                return _this.emit("change", true);
              };
            })(this),
            start: false
          }));
          ref1 = this._parseDateToCronFormat(parseResult.end), second = ref1.second, minute = ref1.minute, hour = ref1.hour, day = ref1.day, month = ref1.month, dayOfWeek = ref1.dayOfWeek;
          return this.jobs.push(new CronJob({
            cronTime: second + " " + minute + " " + hour + " " + day + " " + month + " " + dayOfWeek,
            onTick: (function(_this) {
              return function() {
                return _this.emit("change", false);
              };
            })(this),
            start: false
          }));
        default:
          return assert(false);
      }
    };

    BaseCronPredicateHandler.prototype._setup = function(dateString) {
      var i, job, len, ref, results;
      this._createJobs(dateString);
      ref = this.jobs;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        job = ref[i];
        results.push(job.start());
      }
      return results;
    };

    BaseCronPredicateHandler.prototype.getType = function() {
      if (this.modifier === 'exact') {
        return 'event';
      } else {
        return 'state';
      }
    };

    BaseCronPredicateHandler.prototype._reparseDateString = function(dateString) {
      var theTime;
      theTime = this.provider.getTime();
      return chrono.parse(dateString, theTime)[0];
    };

    BaseCronPredicateHandler.prototype._getValue = function(dateString) {
      var end, now, parseResult, start;
      parseResult = this._reparseDateString(dateString);
      if (parseResult == null) {
        throw new Error("\"" + dateString + "\" is not a valid date or time.");
      }
      now = parseResult.referenceDate;
      start = parseResult.startDate;
      end = parseResult.endDate;
      if (parseResult.start.hour == null) {
        start.setHours(now.getHours());
      }
      if (parseResult.start.minute == null) {
        start.setMinutes(now.getMinutes());
      }
      if (parseResult.start.second == null) {
        start.setSeconds(now.getSeconds());
      }
      if (indexOf.call(parseResult.start.impliedComponents, 'year') >= 0) {
        start.setFullYear(now.getFullYear());
      }
      if (indexOf.call(parseResult.start.impliedComponents, 'month') >= 0) {
        start.setMonth(now.getMonth());
      }
      if (indexOf.call(parseResult.start.impliedComponents, 'day') >= 0) {
        start.setDate(now.getDate());
      }
      if (this.modifier === 'exact') {
        start.setMilliseconds(now.getMilliseconds());
        if (parseResult.start.dayOfWeek != null) {
          if (parseResult.start.dayOfWeek !== now.getDay()) {
            return Promise.resolve(false);
          }
        }
      }
      return Promise.resolve((function() {
        switch (this.modifier) {
          case 'exact':
            return start >= now && start <= now;
          case 'after':
            return now >= start;
          case 'before':
            return now <= start;
          case 'range':
            return (start <= now && now <= end);
          default:
            return assert(false);
        }
      }).call(this));
    };

    BaseCronPredicateHandler.prototype._destroy = function() {
      var cj, i, len, ref, results;
      if (this.jobs != null) {
        ref = this.jobs;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          cj = ref[i];
          results.push(cj.stop());
        }
        return results;
      }
    };

    BaseCronPredicateHandler.prototype._parseDateToCronFormat = function(date) {
      var day, dayOfWeek, hour, minute, month, second;
      second = date.second;
      minute = date.minute;
      hour = date.hour;
      if ((second == null) && (minute == null) && !hour) {
        second = 0;
        minute = 0;
        hour = 0;
      } else {
        if (second == null) {
          second = "*";
        }
        if (minute == null) {
          minute = "*";
        }
        if (hour == null) {
          hour = "*";
        }
      }
      if (date.impliedComponents != null) {
        month = indexOf.call(date.impliedComponents, 'month') >= 0 ? "*" : date.month;
        day = indexOf.call(date.impliedComponents, 'day') >= 0 ? "*" : date.day;
      }
      dayOfWeek = date.dayOfWeek != null ? date.dayOfWeek : "*";
      return {
        second: second,
        minute: minute,
        hour: hour,
        day: day,
        month: month,
        dayOfWeek: dayOfWeek
      };
    };

    return BaseCronPredicateHandler;

  })(env.predicates.PredicateHandler);
  StringCronPredicateHandler = (function(superClass) {
    extend(StringCronPredicateHandler, superClass);

    function StringCronPredicateHandler(provider, modifier, dateString1) {
      this.dateString = dateString1;
      StringCronPredicateHandler.__super__.constructor.call(this, provider, modifier);
    }

    StringCronPredicateHandler.prototype.setup = function() {
      this._setup(this.dateString);
      return StringCronPredicateHandler.__super__.setup.call(this);
    };

    StringCronPredicateHandler.prototype.destroy = function() {
      this._destroy();
      return StringCronPredicateHandler.__super__.destroy.call(this);
    };

    StringCronPredicateHandler.prototype.getValue = function() {
      return this._getValue(this.dateString);
    };

    return StringCronPredicateHandler;

  })(BaseCronPredicateHandler);
  ExprCronPredicateHandler = (function(superClass) {
    extend(ExprCronPredicateHandler, superClass);

    function ExprCronPredicateHandler(provider, modifier, exprTokens1) {
      this.exprTokens = exprTokens1;
      ExprCronPredicateHandler.__super__.constructor.call(this, provider, modifier);
      this._variableManager = this.provider.framework.variableManager;
    }

    ExprCronPredicateHandler.prototype._setupJobs = function() {
      return this._variableManager.evaluateStringExpression(this.exprTokens).then((function(_this) {
        return function(dateString) {
          if (_this.destroyed) {
            return;
          }
          return _this._setup("" + dateString);
        };
      })(this))["catch"](function(error) {
        env.logger.error("Error creating cron predicate handler: " + error.message);
        return env.logger.debug(error.stack);
      });
    };

    ExprCronPredicateHandler.prototype.setup = function() {
      this.destroyed = false;
      this._setupJobs();
      this._variableManager.notifyOnChange(this.exprTokens, this.expChangeListener = (function(_this) {
        return function() {
          _this._destroy();
          return _this._setupJobs();
        };
      })(this));
      return ExprCronPredicateHandler.__super__.setup.call(this);
    };

    ExprCronPredicateHandler.prototype.getValue = function() {
      return this._variableManager.evaluateStringExpression(this.exprTokens).then((function(_this) {
        return function(dateString) {
          return _this._getValue("" + dateString);
        };
      })(this));
    };

    ExprCronPredicateHandler.prototype.destroy = function() {
      this._variableManager.cancelNotifyOnChange(this.expChangeListener);
      this.destroyed = true;
      return ExprCronPredicateHandler.__super__.destroy.call(this);
    };

    return ExprCronPredicateHandler;

  })(BaseCronPredicateHandler);
  EveryCronPredicateProvider = (function(superClass) {
    extend(EveryCronPredicateProvider, superClass);

    function EveryCronPredicateProvider(framework1, config) {
      this.framework = framework1;
      this.config = config;
      EveryCronPredicateProvider.__super__.constructor.call(this);
    }

    EveryCronPredicateProvider.prototype.parsePredicate = function(input, context) {
      var exprTokens, fullMatch, matchingUnit, nextInput;
      exprTokens = null;
      fullMatch = null;
      nextInput = null;
      matchingUnit = null;
      M(input, context).match('every ').matchTimeDurationExpression((function(_this) {
        return function(m, arg) {
          var tokens, unit;
          tokens = arg.tokens, unit = arg.unit;
          exprTokens = tokens;
          matchingUnit = unit;
          fullMatch = m.getFullMatch();
          return nextInput = m.getRemainingInput();
        };
      })(this));
      if (fullMatch != null) {
        assert(matchingUnit != null);
        assert(exprTokens != null);
        return {
          token: fullMatch,
          nextInput: nextInput,
          predicateHandler: new EveryCronPredicateHandler(this.framework, exprTokens, matchingUnit)
        };
      } else {
        return null;
      }
    };

    return EveryCronPredicateProvider;

  })(env.predicates.PredicateProvider);
  EveryCronPredicateHandler = (function(superClass) {
    extend(EveryCronPredicateHandler, superClass);

    function EveryCronPredicateHandler(framework, exprTokens1, unit1) {
      this.exprTokens = exprTokens1;
      this.unit = unit1;
      EveryCronPredicateHandler.__super__.constructor.call(this);
      this._variableManager = framework.variableManager;
    }

    EveryCronPredicateHandler.prototype.setup = function() {
      this._setupTimeout();
      this._variableManager.notifyOnChange(this.exprTokens, this.expChangeListener = (function(_this) {
        return function() {
          _this._lastTime = null;
          return _this._setupTimeout();
        };
      })(this));
      return EveryCronPredicateHandler.__super__.setup.call(this);
    };

    EveryCronPredicateHandler.prototype._setupTimeout = function() {
      this.destroyed = false;
      return this._variableManager.evaluateStringExpression(this.exprTokens).then((function(_this) {
        return function(time) {
          var now, timeDiff, timeMs;
          if (_this.destroyed) {
            return;
          }
          timeMs = milliseconds.parse(time + " " + _this.unit);
          now = new Date().getTime();
          if (_this._lastTime == null) {
            _this._lastTime = now - (now % timeMs);
          }
          timeDiff = (_this._lastTime + timeMs) - now;
          if (timeDiff < 0) {
            timeDiff = 0;
          }
          clearTimeout(_this._timeout);
          return _this._timeout = setTimeout((function() {
            _this.emit("change", 'event');
            _this._lastTime += timeMs;
            return _this._setupTimeout();
          }), timeDiff);
        };
      })(this))["catch"](function(error) {
        env.logger.error("Error creating cron predicate handler: " + error.message);
        return env.logger.debug(error.stack);
      });
    };

    EveryCronPredicateHandler.prototype.getValue = function() {
      return Promise.resolve(false);
    };

    EveryCronPredicateHandler.prototype.getType = function() {
      return 'event';
    };

    EveryCronPredicateHandler.prototype.destroy = function() {
      if (this.expChangeListener != null) {
        clearTimeout(this._timeout);
        this._variableManager.cancelNotifyOnChange(this.expChangeListener);
        this.expChangeListener = null;
      }
      this.destroyed = true;
      return EveryCronPredicateHandler.__super__.destroy.call(this);
    };

    return EveryCronPredicateHandler;

  })(env.predicates.PredicateHandler);
  return plugin;
};
