var Promise, S, _, __, assert, crypto;

__ = require("i18n").__;

Promise = require('bluebird');

assert = require('cassert');

_ = require('lodash');

S = require('string');

crypto = require('crypto');

module.exports = function(env) {
  var UserManager, exports;
  UserManager = (function() {
    UserManager.prototype._allowPublicAccessCallbacks = [];

    function UserManager(framework, users, roles) {
      this.framework = framework;
      this.users = users;
      this.roles = roles;
    }

    UserManager.prototype.addUser = function(username, user) {
      if (_.findIndex(this.users, {
        username: username
      }) !== -1) {
        throw new Error('A user with this username already exists');
      }
      if (user.username == null) {
        throw new Error('No username given');
      }
      if (user.role == null) {
        throw new Error('No role given');
      }
      this.users.push(user = {
        username: username,
        password: user.password,
        role: user.role
      });
      this.framework.saveConfig();
      this.framework._emitUserAdded(user);
      return page;
    };

    UserManager.prototype.updateUser = function(username, user) {
      var theuser;
      assert(typeof username === "string");
      assert(typeof page === "object");
      assert(user.username != null ? typeof user.username === "string" : true);
      assert(user.password != null ? typeof user.password === "string" : true);
      assert(user.role != null ? typeof user.role === "string" : true);
      theuser = this.getUserByUsername(username);
      if (theuser == null) {
        throw new Error('User not found');
      }
      if (page.username != null) {
        theuser.username = page.username;
      }
      if (page.password != null) {
        theuser.password = page.password;
      }
      if (page.role != null) {
        theuser.role = page.role;
      }
      this.framework.saveConfig();
      this.framework._emitUserChanged(theuser);
      return theuser;
    };

    UserManager.prototype.getUserByUsername = function(username) {
      return _.find(this.users, {
        username: username
      });
    };

    UserManager.prototype.hasPermission = function(username, scope, access) {
      var permission, role, user;
      assert(scope === "pages" || scope === "rules" || scope === "variables" || scope === "messages" || scope === "config" || scope === "events" || scope === "devices" || scope === "groups" || scope === "plugins" || scope === "updates" || scope === "database");
      assert(access === "read" || access === "write" || access === "none");
      user = this.getUserByUsername(username);
      if (user == null) {
        throw new Error('User not found');
      }
      assert(typeof user.role === "string");
      role = this.getRoleByName(user.role);
      if (role == null) {
        throw new Error("No role with name " + user.role + " found.");
      }
      permission = role.permissions[scope];
      if (permission == null) {
        throw new Error("No permissions for " + scope + " of " + user.role + " found.");
      }
      switch (access) {
        case "read":
          return permission === "read" || permission === "write";
        case "write":
          return permission === "write";
        case "none":
          return true;
        default:
          return false;
      }
    };

    UserManager.prototype.hasPermissionBoolean = function(username, scope) {
      var permission, role, user;
      user = this.getUserByUsername(username);
      if (user == null) {
        throw new Error('User not found');
      }
      assert(typeof user.role === "string");
      role = this.getRoleByName(user.role);
      if (role == null) {
        throw new Error("No role with name " + user.role + " found.");
      }
      permission = role.permissions[scope];
      if (permission == null) {
        throw new Error("No permissions for " + scope + " of " + user.role + " found.");
      }
      return permission === true;
    };

    UserManager.prototype.checkLogin = function(username, password) {
      var user;
      assert(typeof username === "string");
      assert(typeof password === "string");
      if (username.length === 0) {
        return false;
      }
      user = this.getUserByUsername(username);
      if (user == null) {
        return false;
      }
      return password === user.password;
    };

    UserManager.prototype.getRoleByName = function(name) {
      var role;
      assert(typeof name === "string");
      role = _.find(this.roles, {
        name: name
      });
      return role;
    };

    UserManager.prototype.getPermissionsByUsername = function(username) {
      var role, user;
      user = this.getUserByUsername(username);
      if (user == null) {
        throw new Error('User not found');
      }
      role = this.getRoleByName(user.role);
      if (role == null) {
        throw new Error("No role with name " + user.role + " found.");
      }
      return role.permissions;
    };

    UserManager.prototype.getLoginTokenForUsername = function(secret, username) {
      var loginToken, shasum, user;
      assert(typeof username === "string");
      assert(username.length > 0);
      assert(typeof secret === "string");
      assert(secret.length >= 32);
      user = this.getUserByUsername(username);
      if (user == null) {
        throw new Error('User not found');
      }
      assert(typeof user.password === "string");
      assert(user.password.length > 0);
      shasum = crypto.createHash('sha256');
      shasum.update(secret, 'utf8');
      shasum.update(user.password, 'utf8');
      loginToken = shasum.digest('hex');
      return loginToken;
    };

    UserManager.prototype.checkLoginToken = function(secret, username, loginToken) {
      return loginToken === this.getLoginTokenForUsername(secret, username);
    };

    UserManager.prototype.isPublicAccessAllowed = function(req) {
      var allow, i, len, ref;
      ref = this._allowPublicAccessCallbacks;
      for (i = 0, len = ref.length; i < len; i++) {
        allow = ref[i];
        if (allow(req)) {
          return true;
        }
      }
      return false;
    };

    UserManager.prototype.addAllowPublicAccessCallback = function(callback) {
      return this._allowPublicAccessCallbacks.push(callback);
    };

    return UserManager;

  })();
  return exports = {
    UserManager: UserManager
  };
};
