var Promise, assert, env, fs, path, startup,
  slice = [].slice;

assert = require('cassert');

fs = require('fs');

path = require('path');

Promise = require('bluebird');

env = {
  logger: require('./lib/logger')
};

env.api = require('./lib/api');

env.users = require('./lib/users')(env);

env.devices = require('./lib/devices')(env);

env.matcher = require('./lib/matcher');

env.variables = require('./lib/variables')(env);

env.actions = require('./lib/actions')(env);

env.predicates = require('./lib/predicates')(env);

env.rules = require('./lib/rules')(env);

env.plugins = require('./lib/plugins')(env);

env.database = require('./lib/database')(env);

env.groups = require('./lib/groups')(env);

env.pages = require('./lib/pages')(env);

env.require = function() {
  var args;
  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  return module.require.apply(module, args);
};

startup = (function(_this) {
  return function() {
    var configFile, exit, hijackSocketConnectToTraceUncaughtException, initComplete, uncaughtException;
    configFile = (process.env.PIMATIC_CONFIG != null ? process.env.PIMATIC_CONFIG : path.resolve(__dirname, '../../config.json'));
    env.exit = exit = function(code) {
      env.logger.info("exiting...");
      if (process.logStream != null) {
        process.stdout.write = process.stdout.writeOut;
        process.stderr.write = process.stderr.writeOut;
        process.logStream.writer.on('finish', function() {
          return process.exit(code);
        });
        return process.logStream.end();
      } else {
        return process.exit(code);
      }
    };
    (hijackSocketConnectToTraceUncaughtException = function() {
      var net, orgConnect;
      net = require('net');
      orgConnect = net.Socket.prototype.connect;
      return net.Socket.prototype.__defineGetter__('connect', function() {
        var orgEmit;
        this.__connectStack = new Error("From connect").stack;
        if (this.__emitModified != null) {
          return orgConnect;
        }
        orgEmit = this.emit;
        this.emit = function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          if (args.length >= 2 && args[0] === 'error') {
            args[1].__trace = this.__connectStack;
          }
          return orgEmit.apply(this, args);
        };
        this.__emitModified = true;
        return orgConnect;
      });
    })();
    initComplete = false;
    uncaughtException = function(err) {
      var trace;
      if (!err.silent) {
        trace = (err.__trace != null ? err.__trace.toString().replace('Error: ', '\n') : '');
        env.logger.error("An uncaught exception occurred: " + err.stack + trace + "\n This is most probably a bug in pimatic or in a module, please report it!");
      }
      if (initComplete) {
        if (process.env['PIMATIC_DAEMONIZED']) {
          return env.logger.warn("Keeping pimatic alive, but could be in an undefined state, please restart pimatic as soon as possible!");
        } else {
          env.logger.warn("shutting pimatic down...");
          return framework.destroy().then(function() {
            return exit(1);
          });
        }
      } else {
        return exit(1);
      }
    };
    process.on('uncaughtException', uncaughtException);
    env.framework = (require('./lib/framework'))(env);
    return Promise["try"](function() {
      var framework, promise;
      framework = new env.framework.Framework(configFile);
      promise = framework.init().then(function() {
        var onKill;
        initComplete = true;
        onKill = function() {
          return framework.destroy().then(function() {
            return exit(0);
          });
        };
        process.on('SIGINT', onKill);
        return process.on('SIGTERM', onKill);
      });
      return promise.then(function() {
        return framework;
      });
    })["catch"](function(err) {
      if (!err.silent) {
        env.logger.error("Startup error: " + err.stack);
      }
      return exit(1);
    });
  };
})(this);

module.exports.startup = startup;

module.exports.env = env;
