// Generated by CoffeeScript 1.6.3
(function() {
  var fromObject, fromTokens;

  module.exports = function(data) {
    if (Array.isArray(data)) {
      return fromTokens(data);
    }
    if (Array.isArray(data.tokens)) {
      return fromTokens(data);
    }
    return fromObject(data);
  };

  fromObject = function(data) {
    var comment, entry, fallback, hasComments, lines, pattern, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
    if (!data.cache) {
      data.cache = [];
    }
    if (!data.network) {
      data.network = [];
    }
    if (!data.fallback) {
      data.fallback = {};
    }
    if (!data.comments) {
      data.comments = [];
    }
    if (data.comment) {
      data.comments.push(data.comment);
    }
    hasComments = data.comments.length > 0 || data.lastModified || data.unique;
    lines = [];
    lines.push("CACHE MANIFEST");
    lines.push("");
    _ref = data.cache;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      entry = _ref[_i];
      lines.push(entry);
    }
    if (data.network.length > 0) {
      lines.push("");
      lines.push("NETWORK:");
      _ref1 = data.network;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        entry = _ref1[_j];
        lines.push(entry);
      }
    }
    if (Object.keys(data.fallback).length > 0) {
      lines.push("");
      lines.push("FALLBACK:");
      _ref2 = data.fallback;
      for (pattern in _ref2) {
        fallback = _ref2[pattern];
        lines.push("" + pattern + " " + fallback);
      }
    }
    if (data.timestamp || data.unique) {
      lines.push("");
    }
    _ref3 = data.comments;
    for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
      comment = _ref3[_k];
      lines.push("# " + comment);
    }
    if (data.lastModified) {
      lines.push("# Last modified at " + (data.lastModified.toUTCString()) + ".");
    }
    if (data.unique) {
      lines.push("# Math.random() == " + (Math.random()));
    }
    return lines.join("\n");
  };

  fromTokens = function(tokens) {
    var line, out, t, _i, _len;
    out = '';
    for (_i = 0, _len = tokens.length; _i < _len; _i++) {
      t = tokens[_i];
      line = null;
      if (t.type === 'magic signature') {
        line = t.value;
      } else if (t.type === 'newline') {
        out += '\n';
      } else if (t.type === 'comment') {
        line = '# ' + t.value.trim();
      } else if (t.type === 'mode' && t.value !== 'unknown') {
        line = t.value + ':';
      } else if (t.type === 'data') {
        line = t.tokens.join(' ');
      }
      if (line) {
        out = out + line + '\n';
      }
    }
    return out;
  };

}).call(this);

/*
//@ sourceMappingURL=render-appcache-manifest.map
*/
