
/*
Database
===========
 */
var Knex, M, Promise, S, _, assert, path, util,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

assert = require('cassert');

util = require('util');

Promise = require('bluebird');

_ = require('lodash');

S = require('string');

Knex = require('knex');

path = require('path');

M = require('./matcher');

module.exports = function(env) {
  var Database, dbMapping, exports;
  dbMapping = {
    logLevelToInt: {
      'error': 0,
      'warn': 1,
      'info': 2,
      'debug': 3
    },
    typeMap: {
      'number': "attributeValueNumber",
      'string': "attributeValueString",
      'boolean': "attributeValueNumber",
      'date': "attributeValueNumber"
    },
    attributeValueTables: {
      "attributeValueNumber": {
        valueColumnType: "float"
      },
      "attributeValueString": {
        valueColumnType: "string"
      }
    },
    toDBBool: (function(_this) {
      return function(v) {
        if (v) {
          return 1;
        } else {
          return 0;
        }
      };
    })(this),
    fromDBBool: (function(_this) {
      return function(v) {
        return v === 1 || v === "1";
      };
    })(this),
    deviceAttributeCache: {},
    typeToAttributeTable: function(type) {
      return this.typeMap[type];
    }
  };
  dbMapping.logIntToLevel = _.invert(dbMapping.logLevelToInt);

  /*
  The Database
  ----------------
   */
  Database = (function(superClass) {
    extend(Database, superClass);

    function Database(framework, dbSettings) {
      this.framework = framework;
      this.dbSettings = dbSettings;
    }

    Database.prototype.init = function() {
      var connection, dbPackageToInstall, e, pending;
      connection = _.clone(this.dbSettings.connection);
      if (this.dbSettings.client === 'sqlite3') {
        if (connection.filename === ':memory:') {
          connection.filename = 'file::memory:?cache=shared';
        } else {
          connection.filename = path.resolve(this.framework.maindir, '../..', connection.filename);
        }
      }
      pending = Promise.resolve();
      dbPackageToInstall = this.dbSettings.client;
      try {
        require.resolve(dbPackageToInstall);
      } catch (error1) {
        e = error1;
        if (e.code !== 'MODULE_NOT_FOUND') {
          throw e;
        }
        env.logger.info("Installing database package " + dbPackageToInstall + ", this can take some minutes");
        if (dbPackageToInstall === "sqlite3") {
          dbPackageToInstall = "sqlite3@3.1.8";
        }
        pending = this.framework.pluginManager.spawnPpm(['install', dbPackageToInstall, '--unsafe-perm']);
      }
      return pending.then((function(_this) {
        return function() {
          _this.knex = Knex({
            client: _this.dbSettings.client,
            connection: connection,
            pool: {
              min: 1,
              max: 1
            },
            useNullAsDefault: true
          });
          _this.framework.on('destroy', function(context) {
            _this.framework.removeListener("messageLogged", _this.messageLoggedListener);
            _this.framework.removeListener('deviceAttributeChanged', _this.deviceAttributeChangedListener);
            clearTimeout(_this.deleteExpiredTimeout);
            _this._isDestroying = true;
            env.logger.info("Flushing database to disk, please wait...");
            return context.waitForIt(_this.commitLoggingTransaction().then(function() {
              return _this.knex.destroy();
            }).then(function() {
              return env.logger.info("Flushing database to disk, please wait... Done.");
            }));
          });
          _this.knex.subquery = function(query) {
            return this.raw("(" + (query.toString()) + ")");
          };
          if (_this.dbSettings.client === "sqlite3") {
            return Promise.all([_this.knex.raw("PRAGMA locking_mode=EXCLUSIVE"), _this.knex.raw("PRAGMA synchronous=NORMAL;"), _this.knex.raw("PRAGMA auto_vacuum=FULL;"), _this.knex.raw("PRAGMA cache_spill=false;"), _this.knex.raw("PRAGMA cache_size=20000;"), _this.knex.raw("PRAGMA journal_mode=WAL;")]);
          }
        };
      })(this)).then((function(_this) {
        return function() {
          return _this._createTables();
        };
      })(this)).then((function(_this) {
        return function() {
          var deleteExpiredInterval, deleteNo, diskSyncInterval, doDeleteExpired, minExpireInterval, syncAllNo;
          _this.framework.on("messageLogged", _this.messageLoggedListener = function(arg) {
            var level, meta, msg;
            level = arg.level, msg = arg.msg, meta = arg.meta;
            return _this.saveMessageEvent(meta.timestamp, level, meta.tags, msg).done();
          });
          _this.framework.on('deviceAttributeChanged', _this.deviceAttributeChangedListener = function(arg) {
            var attributeName, device, time, value;
            device = arg.device, attributeName = arg.attributeName, time = arg.time, value = arg.value;
            return _this.saveDeviceAttributeEvent(device.id, attributeName, time, value).done();
          });
          _this._updateDeviceAttributeExpireInfos();
          _this._updateMessageseExpireInfos();
          deleteExpiredInterval = _this._parseTime(_this.dbSettings.deleteExpiredInterval);
          diskSyncInterval = _this._parseTime(_this.dbSettings.diskSyncInterval);
          minExpireInterval = 1 * 60 * 1000;
          if (deleteExpiredInterval < minExpireInterval) {
            env.logger.warn("deleteExpiredInterval can't be less then 1 min, setting it to 1 min.");
            deleteExpiredInterval = minExpireInterval;
          }
          if ((diskSyncInterval / deleteExpiredInterval % 1) !== 0) {
            env.logger.warn("diskSyncInterval should be a multiple of deleteExpiredInterval.");
          }
          syncAllNo = Math.max(Math.ceil(diskSyncInterval / deleteExpiredInterval), 1);
          deleteNo = 0;
          doDeleteExpired = (function() {
            if (_this.dbSettings.debug) {
              env.logger.debug("Deleting expired logged values");
            }
            deleteNo++;
            return Promise.resolve().then(function() {
              if (_this.dbSettings.debug) {
                env.logger.debug("Deleting expired events");
              }
              return _this._deleteExpiredDeviceAttributes().then(function() {
                if (_this.dbSettings.debug) {
                  return env.logger.debug("Deleting expired events... Done.");
                }
              });
            }).then(function() {
              if (_this.dbSettings.debug) {
                env.logger.debug("Deleting expired message");
              }
              return _this._deleteExpiredMessages().then(function() {
                if (_this.dbSettings.debug) {
                  return env.logger.debug("Deleting expired message... Done.");
                }
              });
            }).then(function() {
              var next;
              if (deleteNo % syncAllNo === 0) {
                if (_this.dbSettings.debug) {
                  env.logger.debug("Done -> flushing to disk");
                }
                next = _this.commitLoggingTransaction().then(function() {
                  if (_this.dbSettings.debug) {
                    return env.logger.debug("-> done.");
                  }
                });
              } else {
                next = Promise.resolve();
              }
              return next.then(function() {
                return _this.deleteExpiredTimeout = setTimeout(doDeleteExpired, deleteExpiredInterval);
              });
            })["catch"](function(error) {
              env.logger.error(error.message);
              return env.logger.debug(error.stack);
            }).done();
          });
          _this.deleteExpiredTimeout = setTimeout(doDeleteExpired, deleteExpiredInterval);
        };
      })(this));
    };

    Database.prototype.loggingTransaction = function() {
      if (this._loggingTransaction == null) {
        this._loggingTransaction = new Promise((function(_this) {
          return function(resolve, reject) {
            return _this.knex.transaction(function(trx) {
              var transactionInfo;
              transactionInfo = {
                trx: trx,
                count: 0,
                resolve: null
              };
              return resolve(transactionInfo);
            })["catch"](reject);
          };
        })(this));
      }
      return this._loggingTransaction;
    };

    Database.prototype.doInLoggingTransaction = function(callback) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this._loggingTransaction = _this.loggingTransaction().then(function(transactionInfo) {
            var action, actionCompleted;
            action = callback(transactionInfo.trx);
            transactionInfo.count++;
            actionCompleted = function() {
              transactionInfo.count--;
              if (transactionInfo.count === 0 && (transactionInfo.resolve != null)) {
                return transactionInfo.resolve();
              }
            };
            action.then(actionCompleted, actionCompleted);
            resolve(action);
            return transactionInfo;
          })["catch"](reject);
        };
      })(this));
    };

    Database.prototype.commitLoggingTransaction = function() {
      var promise;
      promise = Promise.resolve();
      if (this._loggingTransaction != null) {
        promise = this._loggingTransaction.then((function(_this) {
          return function(transactionInfo) {
            var doCommit;
            if (_this.dbSettings.debug) {
              env.logger.debug("Committing");
            }
            doCommit = function() {
              return transactionInfo.trx.commit();
            };
            if (transactionInfo.count === 0) {
              return doCommit();
            } else {
              return new Promise(function(resolve) {
                return transactionInfo.resolve = function() {
                  doCommit();
                  return resolve();
                };
              });
            }
          };
        })(this));
        this._loggingTransaction = null;
      }
      return promise["catch"]((function(_this) {
        return function(error) {
          env.logger.error(error.message);
          return env.logger.debug(error.stack);
        };
      })(this));
    };

    Database.prototype._createTables = function() {
      var createTableIfNotExists, pending, ref, tableInfo, tableName;
      pending = [];
      createTableIfNotExists = ((function(_this) {
        return function(tableName, cb) {
          return _this.knex.schema.hasTable(tableName).then(function(exists) {
            if (!exists) {
              return _this.knex.schema.createTable(tableName, cb).then((function() {
                return env.logger.info(tableName + " table created!");
              }), function(error) {
                env.logger.error(error);
                return env.logger.debug(error.stack);
              });
            } else {

            }
          });
        };
      })(this));
      pending.push(createTableIfNotExists('message', (function(_this) {
        return function(table) {
          table.increments('id').primary();
          table.timestamp('time').index();
          table.integer('level');
          table.text('tags');
          return table.text('text');
        };
      })(this)));
      pending.push(createTableIfNotExists('deviceAttribute', (function(_this) {
        return function(table) {
          table.increments('id').primary().unique();
          table.string('deviceId');
          table.string('attributeName');
          table.string('type');
          table.boolean('discrete');
          table.timestamp('lastUpdate').nullable();
          table.string('lastValue').nullable();
          table.index(['deviceId', 'attributeName'], 'deviceAttributeDeviceIdAttributeName');
          table.index(['deviceId'], 'deviceAttributeDeviceId');
          return table.index(['attributeName'], 'deviceAttributeAttributeName');
        };
      })(this)));
      ref = dbMapping.attributeValueTables;
      for (tableName in ref) {
        tableInfo = ref[tableName];
        pending.push(createTableIfNotExists(tableName, (function(_this) {
          return function(table) {
            table.increments('id').primary();
            table.timestamp('time').index();
            table.integer('deviceAttributeId').unsigned().references('id').inTable('deviceAttribute');
            return table[tableInfo.valueColumnType]('value');
          };
        })(this)).then(tableName, (function(_this) {
          return function(table) {
            return table.index(['deviceAttributeId', 'time'], 'deviceAttributeIdTime');
          };
        })(this)));
      }
      return Promise.all(pending);
    };

    Database.prototype.getDeviceAttributeLogging = function() {
      return _.clone(this.dbSettings.deviceAttributeLogging);
    };

    Database.prototype.setDeviceAttributeLogging = function(deviceAttributeLogging) {
      this.dbSettings.deviceAttributeLogging = deviceAttributeLogging;
      this._updateDeviceAttributeExpireInfos();
      this.framework.saveConfig();
    };

    Database.prototype._updateDeviceAttributeExpireInfos = function() {
      var entries, entry, expireInfo, i, info, j, len, ownWhere, possibleTypes, ref, ref1, results1, sqlNot;
      ref = dbMapping.deviceAttributeCache;
      for (j = 0, len = ref.length; j < len; j++) {
        info = ref[j];
        info.expireMs = null;
        info.intervalMs = null;
      }
      entries = this.dbSettings.deviceAttributeLogging;
      i = entries.length - 1;
      sqlNot = "";
      possibleTypes = ["number", "string", "boolean", "date", "discrete", "continuous", "*"];
      results1 = [];
      while (i >= 0) {
        entry = entries[i];
        if (entry.time != null) {
          entry.expire = entry.time;
          delete entry.time;
        }
        if (entry.type == null) {
          entry.type = "*";
        }
        if (ref1 = entry.type, indexOf.call(possibleTypes, ref1) < 0) {
          throw new Error("Type option in database config must be one of " + possibleTypes);
        }
        expireInfo = entry.expireInfo;
        if (expireInfo == null) {
          expireInfo = {
            expireMs: 0,
            interval: 0,
            whereSQL: ""
          };
          info = {
            expireInfo: expireInfo
          };
          info.__proto__ = entry.__proto__;
          entry.__proto__ = info;
        }
        ownWhere = ["1=1"];
        if (entry.expire != null) {
          if (entry.deviceId !== '*') {
            ownWhere.push("deviceId='" + entry.deviceId + "'");
          }
          if (entry.attributeName !== '*') {
            ownWhere.push("attributeName='" + entry.attributeName + "'");
          }
          if (entry.type !== '*') {
            if (entry.type === "continuous") {
              ownWhere.push("discrete=0");
            } else if (entry.type === "discrete") {
              ownWhere.push("discrete=1");
            } else {
              ownWhere.push("type='" + entry.type + "'");
            }
          }
        }
        if (entry.expire != null) {
          ownWhere = ownWhere.join(" and ");
          expireInfo.whereSQL = "(" + ownWhere + ")" + sqlNot;
          sqlNot = " AND NOT (" + ownWhere + ")" + sqlNot;
        }
        if (entry.expire != null) {
          expireInfo.expireMs = this._parseTime(entry.expire);
        }
        if (entry.interval != null) {
          expireInfo.interval = this._parseTime(entry.interval);
        }
        results1.push(i--);
      }
      return results1;
    };

    Database.prototype._parseTime = function(time) {
      var timeMs;
      if (time === "0") {
        return 0;
      } else {
        timeMs = null;
        M(time).matchTimeDuration((function(_this) {
          return function(m, info) {
            return timeMs = info.timeMs;
          };
        })(this));
        if (timeMs == null) {
          throw new Error("Can not parse time in database config: " + time);
        }
        return timeMs;
      }
    };

    Database.prototype._updateMessageseExpireInfos = function() {
      var entries, entry, expireInfo, i, info, j, len, levelInt, ownWhere, ref, results1, sqlNot, tag;
      entries = this.dbSettings.messageLogging;
      i = entries.length - 1;
      sqlNot = "";
      results1 = [];
      while (i >= 0) {
        entry = entries[i];
        if (entry.time != null) {
          entry.expire = entry.time;
          delete entry.time;
        }
        expireInfo = entry.expireInfo;
        if (expireInfo == null) {
          expireInfo = {
            expireMs: 0,
            whereSQL: ""
          };
          info = {
            expireInfo: expireInfo
          };
          info.__proto__ = entry.__proto__;
          entry.__proto__ = info;
        }
        ownWhere = "1=1";
        if (entry.level !== '*') {
          levelInt = dbMapping.logLevelToInt[entry.level];
          ownWhere += " AND level=" + levelInt;
        }
        ref = entry.tags;
        for (j = 0, len = ref.length; j < len; j++) {
          tag = ref[j];
          ownWhere += " AND tags LIKE \"''" + tag + "''%\"";
        }
        expireInfo.whereSQL = "(" + ownWhere + ")" + sqlNot;
        sqlNot = " AND NOT (" + ownWhere + ")" + sqlNot;
        if (entry.expire != null) {
          expireInfo.expireMs = this._parseTime(entry.expire);
        }
        results1.push(i--);
      }
      return results1;
    };

    Database.prototype.getDeviceAttributeLoggingTime = function(deviceId, attributeName, type, discrete) {
      var entry, expire, expireMs, interval, intervalMs, j, len, matches, ref;
      expireMs = 0;
      expire = "0";
      intervalMs = 0;
      interval = "0";
      ref = this.dbSettings.deviceAttributeLogging;
      for (j = 0, len = ref.length; j < len; j++) {
        entry = ref[j];
        matches = (entry.deviceId === '*' || entry.deviceId === deviceId) && (entry.attributeName === '*' || entry.attributeName === attributeName) && ((function() {
          switch (entry.type) {
            case '*':
              return true;
            case "discrete":
              return discrete;
            case "continuous":
              return !discrete;
            default:
              return entry.type === type;
          }
        })());
        if (matches) {
          if (entry.expire != null) {
            expireMs = entry.expireInfo.expireMs;
            expire = entry.expire;
          }
          if (entry.interval != null) {
            intervalMs = entry.expireInfo.interval;
            interval = entry.interval;
          }
        }
      }
      return {
        expireMs: expireMs,
        intervalMs: intervalMs,
        expire: expire,
        interval: interval
      };
    };

    Database.prototype.getMessageLoggingTime = function(time, level, tags, text) {
      var entry, expireMs, j, len, ref, t;
      expireMs = null;
      ref = this.dbSettings.messageLogging;
      for (j = 0, len = ref.length; j < len; j++) {
        entry = ref[j];
        if ((entry.level === "*" || entry.level === level) && (entry.tags.length === 0 || ((function() {
          var k, len1, ref1, results1;
          ref1 = entry.tags;
          results1 = [];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            t = ref1[k];
            if (indexOf.call(tags, t) >= 0) {
              results1.push(t);
            }
          }
          return results1;
        })()).length > 0)) {
          expireMs = entry.expireInfo.expireMs;
        }
      }
      return expireMs;
    };

    Database.prototype._deleteExpiredDeviceAttributes = function() {
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          return Promise.each(_this.dbSettings.deviceAttributeLogging, function(entry) {
            var subquery, subqueryRaw;
            if (entry.expire != null) {
              subquery = _this.knex('deviceAttribute').select('id');
              subquery.whereRaw(entry.expireInfo.whereSQL);
              subqueryRaw = "deviceAttributeId in (" + (subquery.toString()) + ")";
              return Promise.each(_.keys(dbMapping.attributeValueTables), function(tableName) {
                var del, query;
                if (_this._isDestroying) {
                  return;
                }
                del = _this.knex(tableName).transacting(trx);
                if (_this.dbSettings.client === "sqlite3") {
                  del.where('time', '<', (new Date()).getTime() - entry.expireInfo.expireMs);
                } else {
                  del.whereRaw('time < FROM_UNIXTIME(?)', [_this._convertTimeForDatabase(parseFloat((new Date()).getTime() - entry.expireInfo.expireMs))]);
                }
                del.whereRaw(subqueryRaw);
                query = del.del();
                if (_this.dbSettings.debug) {
                  env.logger.debug("query:", query.toString());
                }
                return query;
              });
            }
          });
        };
      })(this));
    };

    Database.prototype._deleteExpiredMessages = function() {
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          return Promise.each(_this.dbSettings.messageLogging, function(entry) {
            var del, query;
            if (_this._isDestroying) {
              return;
            }
            del = _this.knex('message').transacting(trx);
            if (_this.dbSettings.client === "sqlite3") {
              del.where('time', '<', (new Date()).getTime() - entry.expireInfo.expireMs);
            } else {
              del.whereRaw('time < FROM_UNIXTIME(?)', [_this._convertTimeForDatabase(parseFloat((new Date()).getTime() - entry.expireInfo.expireMs))]);
            }
            del.whereRaw(entry.expireInfo.whereSQL);
            query = del.del();
            if (_this.dbSettings.debug) {
              env.logger.debug("query:", query.toString());
            }
            return query;
          });
        };
      })(this));
    };

    Database.prototype.saveMessageEvent = function(time, level, tags, text) {
      var expireMs;
      this.emit('log', {
        time: time,
        level: level,
        tags: tags,
        text: text
      });
      assert(Array.isArray(tags));
      assert(typeof level === 'string');
      assert(indexOf.call(_.keys(dbMapping.logLevelToInt), level) >= 0);
      expireMs = this.getMessageLoggingTime(time, level, tags, text);
      if (expireMs === 0) {
        return Promise.resolve();
      }
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          return _this.knex('message').transacting(trx).insert({
            time: time,
            level: dbMapping.logLevelToInt[level],
            tags: JSON.stringify(tags),
            text: text
          })["return"]();
        };
      })(this));
    };

    Database.prototype.saveDeviceAttributeEvent = function(deviceId, attributeName, time, value) {
      assert(typeof deviceId === 'string' && deviceId.length > 0);
      assert(typeof attributeName === 'string' && attributeName.length > 0);
      this.emit('device-attribute-save', {
        deviceId: deviceId,
        attributeName: attributeName,
        time: time,
        value: value
      });
      if (value !== value) {
        return Promise.resolve();
      }
      return this._getDeviceAttributeInfo(deviceId, attributeName).then((function(_this) {
        return function(info) {
          return _this.doInLoggingTransaction(function(trx) {
            var doInsert, insert1, insert2, tableName, timestamp;
            tableName = dbMapping.typeToAttributeTable(info.type);
            timestamp = time.getTime();
            if (info.expireMs === 0) {
              doInsert = false;
            } else {
              if (info.intervalMs === 0 || timestamp - info.lastInsertTime > info.intervalMs) {
                doInsert = true;
              } else {
                doInsert = false;
              }
            }
            if (doInsert) {
              info.lastInsertTime = timestamp;
              insert1 = _this.knex(tableName).transacting(trx).insert({
                time: time,
                deviceAttributeId: info.id,
                value: value
              });
            } else {
              insert1 = Promise.resolve();
            }
            insert2 = _this.knex('deviceAttribute').transacting(trx).where({
              id: info.id
            }).update({
              lastUpdate: time,
              lastValue: value
            });
            return Promise.all([insert1, insert2]);
          });
        };
      })(this));
    };

    Database.prototype._buildMessageWhere = function(query, arg) {
      var after, before, j, len, level, levelOp, limit, offset, tag, tags;
      level = arg.level, levelOp = arg.levelOp, after = arg.after, before = arg.before, tags = arg.tags, offset = arg.offset, limit = arg.limit;
      if (level != null) {
        if (!levelOp) {
          levelOp = '=';
        }
        if (Array.isArray(level)) {
          level = _.map(level, (function(_this) {
            return function(l) {
              return dbMapping.logLevelToInt[l];
            };
          })(this));
          query.whereIn('level', level);
        } else {
          query.where('level', levelOp, dbMapping.logLevelToInt[level]);
        }
      }
      if (after != null) {
        if (this.dbSettings.client === "sqlite3") {
          query.where('time', '>=', after);
        } else {
          query.whereRaw('time >= FROM_UNIXTIME(?)', [this._convertTimeForDatabase(parseFloat(after))]);
        }
      }
      if (before != null) {
        if (this.dbSettings.client === "sqlite3") {
          query.where('time', '<=', before);
        } else {
          query.whereRaw('time <= FROM_UNIXTIME(?)', [this._convertTimeForDatabase(parseFloat(before))]);
        }
      }
      if (tags != null) {
        if (!Array.isArray(tags)) {
          tags = [tags];
        }
        for (j = 0, len = tags.length; j < len; j++) {
          tag = tags[j];
          query.where('tags', 'like', "%\"" + tag + "\"%");
        }
      }
      query.orderBy('time', 'desc');
      if (offset != null) {
        query.offset(offset);
      }
      if (limit != null) {
        return query.limit(limit);
      }
    };

    Database.prototype.queryMessagesCount = function(criteria) {
      if (criteria == null) {
        criteria = {};
      }
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          var query;
          query = _this.knex('message').transacting(trx).count('*');
          _this._buildMessageWhere(query, criteria);
          return Promise.resolve(query).then(function(result) {
            return result[0]["count(*)"];
          });
        };
      })(this));
    };

    Database.prototype.queryMessagesTags = function(criteria) {
      if (criteria == null) {
        criteria = {};
      }
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          var query;
          query = _this.knex('message').transacting(trx).distinct('tags').select();
          _this._buildMessageWhere(query, criteria);
          return Promise.resolve(query).then(function(tags) {
            return _(tags).map(function(r) {
              return JSON.parse(r.tags);
            }).flatten().uniq().valueOf();
          });
        };
      })(this));
    };

    Database.prototype.queryMessages = function(criteria) {
      if (criteria == null) {
        criteria = {};
      }
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          var query;
          query = _this.knex('message').transacting(trx).select('time', 'level', 'tags', 'text');
          _this._buildMessageWhere(query, criteria);
          return Promise.resolve(query).then(function(msgs) {
            var j, len, m;
            for (j = 0, len = msgs.length; j < len; j++) {
              m = msgs[j];
              m.tags = JSON.parse(m.tags);
              m.level = dbMapping.logIntToLevel[m.level];
            }
            return msgs;
          });
        };
      })(this));
    };

    Database.prototype.deleteMessages = function(criteria) {
      if (criteria == null) {
        criteria = {};
      }
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          var query;
          query = _this.knex('message').transacting(trx);
          _this._buildMessageWhere(query, criteria);
          return Promise.resolve(query.del());
        };
      })(this));
    };

    Database.prototype._buildQueryDeviceAttributeEvents = function(queryCriteria) {
      var after, attributeName, before, buildQueryForType, deviceId, j, len, limit, offset, order, orderDirection, query, ref, tableName;
      if (queryCriteria == null) {
        queryCriteria = {};
      }
      deviceId = queryCriteria.deviceId, attributeName = queryCriteria.attributeName, after = queryCriteria.after, before = queryCriteria.before, order = queryCriteria.order, orderDirection = queryCriteria.orderDirection, offset = queryCriteria.offset, limit = queryCriteria.limit;
      if (order == null) {
        order = "time";
        orderDirection = "desc";
      }
      buildQueryForType = (function(_this) {
        return function(tableName, query) {
          var timeSelect;
          if (_this.dbSettings.client === "sqlite3") {
            timeSelect = 'time AS time';
          } else {
            timeSelect = _this.knex.raw('(UNIX_TIMESTAMP(time)*1000) AS time');
          }
          query.select('deviceAttribute.deviceId AS deviceId', 'deviceAttribute.attributeName AS attributeName', 'deviceAttribute.type AS type', timeSelect, 'value AS value').from(tableName).join('deviceAttribute', tableName + ".deviceAttributeId", '=', 'deviceAttribute.id');
          if (deviceId != null) {
            query.where('deviceId', deviceId);
          }
          if (attributeName != null) {
            return query.where('attributeName', attributeName);
          }
        };
      })(this);
      query = null;
      ref = _.keys(dbMapping.attributeValueTables);
      for (j = 0, len = ref.length; j < len; j++) {
        tableName = ref[j];
        if (query == null) {
          query = this.knex(tableName);
          buildQueryForType(tableName, query);
        } else {
          query.unionAll(function() {
            return buildQueryForType(tableName, this);
          });
        }
      }
      if (after != null) {
        if (this.dbSettings.client === "sqlite3") {
          query.where('time', '>=', after);
        } else {
          query.whereRaw('time >= FROM_UNIXTIME(?)', [this._convertTimeForDatabase(parseFloat(after))]);
        }
      }
      if (before != null) {
        if (this.dbSettings.client === "sqlite3") {
          query.where('time', '<=', before);
        } else {
          query.whereRaw('time <= FROM_UNIXTIME(?)', [this._convertTimeForDatabase(parseFloat(before))]);
        }
      }
      query.orderBy(order, orderDirection);
      if (offset != null) {
        query.offset(offset);
      }
      if (limit != null) {
        query.limit(limit);
      }
      return query;
    };

    Database.prototype.queryDeviceAttributeEvents = function(queryCriteria) {
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          var query, time;
          query = _this._buildQueryDeviceAttributeEvents(queryCriteria).transacting(trx);
          if (_this.dbSettings.debug) {
            env.logger.debug("Query:", query.toString());
          }
          time = new Date().getTime();
          return Promise.resolve(query).then(function(result) {
            var j, len, r, timeDiff;
            timeDiff = new Date().getTime() - time;
            if (_this.dbSettings.debug) {
              env.logger.debug("Quering " + result.length + " events took " + timeDiff + "ms.");
            }
            for (j = 0, len = result.length; j < len; j++) {
              r = result[j];
              if (r.type === "boolean") {
                r.value = dbMapping.fromDBBool(r.value);
              } else if (r.type === "number") {
                r.value = parseFloat(r.value);
              }
            }
            return result;
          });
        };
      })(this));
    };

    Database.prototype.queryDeviceAttributeEventsCount = function() {
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          var j, len, pending, ref, tableName;
          pending = [];
          ref = _.keys(dbMapping.attributeValueTables);
          for (j = 0, len = ref.length; j < len; j++) {
            tableName = ref[j];
            pending.push(_this.knex(tableName).transacting(trx).count('* AS count'));
          }
          return Promise.all(pending).then(function(counts) {
            var c, count, k, len1;
            count = 0;
            for (k = 0, len1 = counts.length; k < len1; k++) {
              c = counts[k];
              count += c[0].count;
            }
            return count;
          });
        };
      })(this));
    };

    Database.prototype.queryDeviceAttributeEventsDevices = function() {
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          return _this.knex('deviceAttribute').transacting(trx).select('id', 'deviceId', 'attributeName', 'type');
        };
      })(this));
    };

    Database.prototype.queryDeviceAttributeEventsInfo = function() {
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          return _this.knex('deviceAttribute').transacting(trx).select('id', 'deviceId', 'attributeName', 'type', 'discrete').then(function(results) {
            var info, j, len, result;
            for (j = 0, len = results.length; j < len; j++) {
              result = results[j];
              result.discrete = dbMapping.fromDBBool(result.discrete);
              info = _this.getDeviceAttributeLoggingTime(result.deviceId, result.attributeName, result.type, result.discrete);
              result.interval = info.interval;
              result.expire = info.expire;
            }
            return results;
          });
        };
      })(this));
    };

    Database.prototype.queryDeviceAttributeEventsCounts = function() {
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          var j, len, queries, ref, tableName;
          queries = [];
          ref = _.keys(dbMapping.attributeValueTables);
          for (j = 0, len = ref.length; j < len; j++) {
            tableName = ref[j];
            queries.push(_this.knex(tableName).transacting(trx).select('deviceAttributeId').count('id').groupBy('deviceAttributeId'));
          }
          return Promise.reduce(queries, function(all, result) {
            return all.concat(result);
          }).each(function(entry) {
            entry.count = entry['count("id")'];
            return entry['count("id")'] = void 0;
          });
        };
      })(this));
    };

    Database.prototype.runVacuum = function() {
      return this.commitLoggingTransaction().then((function(_this) {
        return function() {
          return _this.knex.raw('VACUUM;');
        };
      })(this));
    };

    Database.prototype.checkDatabase = function() {
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          return _this.knex('deviceAttribute').transacting(trx).select('id', 'deviceId', 'attributeName', 'type', 'discrete').then(function(results) {
            var attribute, device, j, len, problems, result;
            problems = [];
            for (j = 0, len = results.length; j < len; j++) {
              result = results[j];
              result.discrete = dbMapping.fromDBBool(result.discrete);
              device = _this.framework.deviceManager.getDeviceById(result.deviceId);
              if (device == null) {
                problems.push({
                  id: result.id,
                  deviceId: result.deviceId,
                  attribute: result.attributeName,
                  description: "No device with the ID \"" + result.deviceId + "\" found.",
                  action: "delete"
                });
              } else {
                if (!device.hasAttribute(result.attributeName)) {
                  problems.push({
                    id: result.id,
                    deviceId: result.deviceId,
                    attribute: result.attributeName,
                    description: ("Device \"" + result.deviceId + "\" has no attribute with the name ") + ("\"" + result.attributeName + "\" found."),
                    action: "delete"
                  });
                } else {
                  attribute = device.attributes[result.attributeName];
                  if (attribute.type !== result.type) {
                    problems.push({
                      id: result.id,
                      deviceId: result.deviceId,
                      attribute: result.attributeName,
                      description: ("Attribute \"" + result.attributeName + "\" of  ") + ("\"" + result.deviceId + "\" has the wrong type"),
                      action: "delete"
                    });
                  } else if (attribute.discrete !== result.discrete) {
                    problems.push({
                      id: result.id,
                      deviceId: result.deviceId,
                      attribute: result.attributeName,
                      description: ("Attribute \"" + result.attributeName + "\" of") + ("\"" + result.deviceId + "\" discrete flag is wrong."),
                      action: "update"
                    });
                  }
                }
              }
            }
            return problems;
          });
        };
      })(this));
    };

    Database.prototype.deleteDeviceAttribute = function(id) {
      assert(typeof id === "number");
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          return _this.knex('deviceAttribute').transacting(trx).where('id', id).del().then(function() {
            var awaiting, entry, key, ref, ref1, tableInfo, tableName;
            ref = dbMapping.deviceAttributeCache;
            for (key in ref) {
              entry = ref[key];
              if (entry.id === id) {
                delete dbMapping.deviceAttributeCache[key];
              }
            }
            awaiting = [];
            ref1 = dbMapping.attributeValueTables;
            for (tableName in ref1) {
              tableInfo = ref1[tableName];
              awaiting.push(_this.knex(tableName).transacting(trx).where('deviceAttributeId', id).del());
            }
            return Promise.all(awaiting);
          });
        };
      })(this));
    };

    Database.prototype.updateDeviceAttribute = function(id) {
      assert(typeof id === "number");
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          return _this.knex('deviceAttribute').transacting(trx).select('deviceId', 'attributeName').where({
            id: id
          }).then(function(results) {
            var attribute, device, fullQualifier, info, result, update;
            if (results.length === 1) {
              result = results[0];
              fullQualifier = result.deviceId + "." + result.attributeName;
              device = _this.framework.deviceManager.getDeviceById(result.deviceId);
              if (device == null) {
                throw new Error(result.deviceId + " not found.");
              }
              attribute = device.attributes[result.attributeName];
              if (attribute == null) {
                new Error(result.deviceId + " has no attribute " + result.attributeName + ".");
              }
              info = dbMapping.deviceAttributeCache[fullQualifier];
              if (info != null) {
                info.discrete = attribute.discrete;
              }
              return update = _this.knex('deviceAttribute').transacting(trx).where({
                id: id
              }).update({
                discrete: dbMapping.toDBBool(attribute.discrete)
              })["return"]();
            } else {

            }
          });
        };
      })(this));
    };

    Database.prototype.querySingleDeviceAttributeEvents = function(deviceId, attributeName, queryCriteria) {
      var after, before, groupByTime, limit, offset, order, orderDirection;
      if (queryCriteria == null) {
        queryCriteria = {};
      }
      after = queryCriteria.after, before = queryCriteria.before, order = queryCriteria.order, orderDirection = queryCriteria.orderDirection, offset = queryCriteria.offset, limit = queryCriteria.limit, groupByTime = queryCriteria.groupByTime;
      if (order == null) {
        order = "time";
        orderDirection = "asc";
      }
      return this._getDeviceAttributeInfo(deviceId, attributeName).then((function(_this) {
        return function(info) {
          return _this.doInLoggingTransaction(function(trx) {
            var query, time;
            query = _this.knex(dbMapping.typeToAttributeTable(info.type)).transacting(trx);
            if (groupByTime == null) {
              query.select('time', 'value');
            } else {
              if (_this.dbSettings.client === "sqlite3") {
                query.select(_this.knex.raw('MIN(time) AS time'), _this.knex.raw('AVG(value) AS value'));
              } else {
                query.select(_this.knex.raw('MIN(UNIX_TIMESTAMP(time) * 1000) AS time'), _this.knex.raw('AVG(value) AS value'));
              }
            }
            query.where('deviceAttributeId', info.id);
            if (after != null) {
              if (_this.dbSettings.client === "sqlite3") {
                query.where('time', '>=', _this._convertTimeForDatabase(parseFloat(after)));
              } else {
                query.whereRaw('time >= FROM_UNIXTIME(?)', [_this._convertTimeForDatabase(parseFloat(after))]);
              }
            }
            if (before != null) {
              if (_this.dbSettings.client === "sqlite3") {
                query.where('time', '<=', _this._convertTimeForDatabase(parseFloat(before)));
              } else {
                query.whereRaw('time <= FROM_UNIXTIME(?)', [_this._convertTimeForDatabase(parseFloat(before))]);
              }
            }
            if (order != null) {
              query.orderBy(order, orderDirection);
            }
            if (groupByTime != null) {
              groupByTime = parseFloat(groupByTime);
              if (_this.dbSettings.client === "sqlite3") {
                query.groupByRaw("time/" + groupByTime);
              } else {
                query.groupByRaw("UNIX_TIMESTAMP(time)/" + groupByTime);
              }
            }
            if (offset != null) {
              query.offset(offset);
            }
            if (limit != null) {
              query.limit(limit);
            }
            if (_this.dbSettings.debug) {
              env.logger.debug("query:", query.toString());
            }
            time = new Date().getTime();
            return Promise.resolve(query).then(function(result) {
              var j, k, len, len1, r, timeDiff;
              timeDiff = new Date().getTime() - time;
              if (_this.dbSettings.debug) {
                env.logger.debug("querying " + result.length + " events took " + timeDiff + "ms.");
              }
              if (info.type === "boolean") {
                for (j = 0, len = result.length; j < len; j++) {
                  r = result[j];
                  r.value = dbMapping.fromDBBool(r.value);
                }
              } else if (info.type === "number") {
                for (k = 0, len1 = result.length; k < len1; k++) {
                  r = result[k];
                  r.value = parseFloat(r.value);
                }
              }
              return result;
            });
          });
        };
      })(this));
    };

    Database.prototype._getDeviceAttributeInfo = function(deviceId, attributeName) {
      var expireInfo, fullQualifier, info;
      fullQualifier = deviceId + "." + attributeName;
      info = dbMapping.deviceAttributeCache[fullQualifier];
      return (info != null ? (info.expireMs == null ? (expireInfo = this.getDeviceAttributeLoggingTime(deviceId, attributeName, info.type, info.discrete), info.expireMs = expireInfo.expireMs, info.intervalMs = expireInfo.intervalMs, info.lastInsertTime = 0) : void 0, Promise.resolve(info)) : this._insertDeviceAttribute(deviceId, attributeName));
    };

    Database.prototype.getLastDeviceState = function(deviceId) {
      if (this._lastDevicesStateCache != null) {
        return this._lastDevicesStateCache.then(function(devices) {
          return devices[deviceId];
        });
      }
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          _this._lastDevicesStateCache = _this.knex('deviceAttribute').transacting(trx).select('deviceId', 'attributeName', 'type', 'lastUpdate', 'lastValue').then(function(result) {
            var convertValue, d, devices, j, len, r;
            devices = {};
            convertValue = function(value, type) {
              if (value == null) {
                return null;
              }
              return ((function() {
                switch (type) {
                  case 'number':
                    return parseFloat(value);
                  case 'boolean':
                    return dbMapping.fromDBBool(value);
                  default:
                    return value;
                }
              })());
            };
            for (j = 0, len = result.length; j < len; j++) {
              r = result[j];
              d = devices[r.deviceId];
              if (d == null) {
                d = devices[r.deviceId] = {};
              }
              d[r.attributeName] = {
                time: r.lastUpdate,
                value: convertValue(r.lastValue, r.type)
              };
            }
            clearTimeout(_this._lastDevicesStateCacheTimeout);
            _this._lastDevicesStateCacheTimeout = setTimeout((function() {
              return _this._lastDevicesStateCache = null;
            }), 60 * 1000);
            return devices;
          });
          return _this._lastDevicesStateCache.then(function(devices) {
            return devices[deviceId];
          });
        };
      })(this));
    };

    Database.prototype._convertTimeForDatabase = function(timestamp) {
      if (this.dbSettings.client === "sqlite3") {
        return timestamp;
      } else {
        return Math.floor(timestamp / 1000);
      }
    };

    Database.prototype._insertDeviceAttribute = function(deviceId, attributeName) {
      var attribute, device, expireInfo, info;
      assert(typeof deviceId === 'string' && deviceId.length > 0);
      assert(typeof attributeName === 'string' && attributeName.length > 0);
      device = this.framework.deviceManager.getDeviceById(deviceId);
      if (device == null) {
        throw new Error(deviceId + " not found.");
      }
      attribute = device.attributes[attributeName];
      if (attribute == null) {
        throw new Error(deviceId + " has no attribute " + attributeName + ".");
      }
      expireInfo = this.getDeviceAttributeLoggingTime(deviceId, attributeName, attribute.type, attribute.discrete);
      info = {
        id: null,
        type: attribute.type,
        discrete: attribute.discrete,
        expireMs: expireInfo.expireMs,
        intervalMs: expireInfo.intervalMs,
        lastInsertTime: 0
      };

      /*
        Don't create a new entry for the device if an entry with the attributeName and deviceId
        already exists.
       */
      return this.doInLoggingTransaction((function(_this) {
        return function(trx) {
          var statement;
          if (_this.dbSettings.client === "sqlite3") {
            statement = "INSERT INTO deviceAttribute(deviceId, attributeName, type, discrete)\nSELECT\n  '" + deviceId + "' AS deviceId,\n  '" + attributeName + "' AS attributeName,\n  '" + info.type + "' as type,\n  " + (dbMapping.toDBBool(info.discrete)) + " as discrete\nWHERE 0 = (\n  SELECT COUNT(*)\n  FROM deviceAttribute\n  WHERE deviceId = '" + deviceId + "' and attributeName = '" + attributeName + "'\n);";
          } else {
            statement = "INSERT INTO deviceAttribute(deviceId, attributeName, type, discrete)\nSELECT * FROM\n  ( SELECT '" + deviceId + "' AS deviceId,\n  '" + attributeName + "' AS attributeName,\n  '" + info.type + "' as type,\n  " + (dbMapping.toDBBool(info.discrete)) + " as discrete\n  ) as tmp\nWHERE NOT EXISTS (\n  SELECT deviceId, attributeName\n  FROM deviceAttribute\n  WHERE deviceId = '" + deviceId + "' and attributeName = '" + attributeName + "'\n) LIMIT 1;";
          }
          return _this.knex.raw(statement).transacting(trx).then(function() {
            return _this.knex('deviceAttribute').transacting(trx).select('id').where({
              deviceId: deviceId,
              attributeName: attributeName
            }).then(function(arg) {
              var fullQualifier, result, update;
              result = arg[0];
              info.id = result.id;
              assert((info.id != null) && typeof info.id === "number");
              update = Promise.resolve();
              if ((info.discrete == null) || dbMapping.fromDBBool(info.discrete) !== attribute.discrete) {
                update = _this.knex('deviceAttribute').transacting(trx).where({
                  id: info.id
                }).update({
                  discrete: dbMapping.toDBBool(attribute.discrete)
                });
              }
              info.discrete = attribute.discrete;
              fullQualifier = deviceId + "." + attributeName;
              return update.then(function() {
                return dbMapping.deviceAttributeCache[fullQualifier] = info;
              });
            });
          });
        };
      })(this));
    };

    return Database;

  })(require('events').EventEmitter);
  return exports = {
    Database: Database
  };
};
