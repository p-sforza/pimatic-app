
/*
Matcher/Parser helper for predicate and action strings
=================
 */
var M, Matcher, Promise, S, _, __, assert, milliseconds,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

__ = require("i18n").__;

Promise = require('bluebird');

S = require('string');

assert = require('cassert');

_ = require('lodash');

milliseconds = require('./milliseconds');

Matcher = (function() {
  var comparators, k, len, normalizeComparator, ref, sign;

  comparators = {
    '==': ['equals', 'is equal to', 'is equal', 'is'],
    '!=': ['is not', 'isnt'],
    '<': ['less', 'lower', 'below'],
    '>': ['greater', 'higher', 'above'],
    '>=': ['greater or equal', 'higher or equal', 'above or equal', 'equal or greater', 'equal or higher', 'equal or above'],
    '<=': ['less or equal', 'lower or equal', 'below or equal', 'equal or less', 'equal or lower', 'equal or below']
  };

  ref = ['<', '>', '<=', '>='];
  for (k = 0, len = ref.length; k < len; k++) {
    sign = ref[k];
    comparators[sign] = _(comparators[sign]).map(function(c) {
      return [c, "is " + c, "is " + c + " than", "is " + c + " as", c + " than", c + " as"];
    }).flatten().value();
  }

  for (sign in comparators) {
    comparators[sign].push(sign);
  }

  comparators['=='].push('=');

  normalizeComparator = function(comparator) {
    var c, found;
    found = false;
    for (sign in comparators) {
      c = comparators[sign];
      if (indexOf.call(c, comparator) >= 0) {
        comparator = sign;
        found = true;
        break;
      }
    }
    assert(found);
    return comparator;
  };

  function Matcher(input1, context1, prevInput, elements1) {
    this.input = input1;
    this.context = context1 != null ? context1 : null;
    this.prevInput = prevInput != null ? prevInput : "";
    this.elements = elements1 != null ? elements1 : [];
  }


  /*
  Matches the current inputs against the given pattern.
  Pattern can be a string, a regexp or an array of strings or regexps.
  If a callback is given it is called with a new Matcher for the remaining part of the string
  and the matching part of the input.
  In addition a matcher is returned that has the remaining parts as input.
   */

  Matcher.prototype.match = function(patterns, options, callback) {
    var doesMatch, element, elements, inputT, j, l, len1, longestMatch, match, matchId, matches, nextInput, nextToken, p, pT, prevInputAndMatch, ref1, ref2, ref3, ref4, regexpMatch, showAc, wildcardMatch;
    if (options == null) {
      options = {};
    }
    if (callback == null) {
      callback = null;
    }
    if (this.input == null) {
      return this;
    }
    if (!Array.isArray(patterns)) {
      patterns = [patterns];
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    matches = [];
    for (j = l = 0, len1 = patterns.length; l < len1; j = ++l) {
      p = patterns[j];
      matchId = null;
      if (Array.isArray(p)) {
        assert(p.length === 2);
        ref1 = p, matchId = ref1[0], p = ref1[1];
      }
      ref2 = (options.ignoreCase && typeof p === "string" ? [p.toLowerCase(), this.input.toLowerCase()] : [p, this.input]), pT = ref2[0], inputT = ref2[1];
      if (typeof p === "string" && this.context) {
        showAc = (options.acFilter != null ? options.acFilter(p) : true);
        if (showAc) {
          if (S(pT).startsWith(inputT) && this.input.length < p.length) {
            if ((ref3 = this.context) != null) {
              ref3.addHint({
                autocomplete: p
              });
            }
          }
        }
      }
      wildcardMatch = false;
      doesMatch = false;
      match = null;
      nextToken = null;
      if (options.wildcard != null) {
        wildcardMatch = S(inputT).startsWith(options.wildcard);
      }
      switch (false) {
        case typeof p !== "string":
          doesMatch = S(inputT).startsWith(pT);
          if (doesMatch) {
            match = p;
            nextToken = this.input.substring(p.length);
          }
          break;
        case !(p instanceof RegExp):
          if (options.ignoreCase != null) {
            throw new Error("ignoreCase option can't be used with regexp");
          }
          if (options.wildcard != null) {
            throw new Error("wildcard option can't be used with regexp");
          }
          regexpMatch = this.input.match(p);
          if (regexpMatch != null) {
            doesMatch = true;
            match = regexpMatch[1];
            nextToken = regexpMatch[2];
          }
          break;
        default:
          throw new Error("Illegal object in patterns");
      }
      if (wildcardMatch || doesMatch) {
        if (wildcardMatch) {
          match = p;
          nextToken = this.input.substring(options.wildcard.length);
        }
        assert(match != null);
        assert(nextToken != null);
        if (matchId == null) {
          matchId = match;
        }
        matches.push({
          matchId: matchId,
          match: match,
          nextToken: nextToken
        });
        if (wildcardMatch) {
          break;
        }
      }
    }
    nextInput = null;
    match = null;
    prevInputAndMatch = "";
    elements = [];
    if (matches.length > 0) {
      longestMatch = _(matches).sortBy((function(_this) {
        return function(m) {
          return m.match.length;
        };
      })(this)).last();
      nextInput = longestMatch.nextToken;
      match = longestMatch.match;
      prevInputAndMatch = this.prevInput + match;
      element = {
        match: match,
        param: options.param,
        options: _.filter(_.map(patterns, (function(_this) {
          return function(p) {
            if (Array.isArray(p)) {
              return p[1];
            } else {
              return p;
            }
          };
        })(this)), (function(_this) {
          return function(p) {
            return p === match || ((options != null ? options.acFilter : void 0) != null ? options.acFilter(p) : true);
          };
        })(this)),
        type: options.type,
        wildcard: options.wildcard,
        wildcardMatch: wildcardMatch
      };
      if (p instanceof RegExp) {
        element.options = null;
        if (element.type == null) {
          element.type = "text";
        }
      } else {
        if (element.type == null) {
          if (element.options.length === 1) {
            element.type = "static";
          } else {
            element.type = "select";
          }
        }
      }
      elements = this.elements.concat(element);
      if (wildcardMatch && (element.options != null)) {
        element.options.unshift(options.wildcard);
      }
      if (callback != null) {
        callback(M(nextInput, this.context, prevInputAndMatch, elements), longestMatch.matchId);
      }
      if ((ref4 = this.context) != null) {
        ref4.addElements(prevInputAndMatch, elements);
      }
    } else if (options.optional) {
      nextInput = this.input;
      prevInputAndMatch = this.prevInput;
      elements = _.clone(this.elements);
    }
    return M(nextInput, this.context, prevInputAndMatch, elements);
  };


  /*
  Matches any number.
   */

  Matcher.prototype.matchNumber = function(options, callback) {
    var next, ref1, showFormatHint;
    if (this.input == null) {
      return this;
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (options.type == null) {
      options.type = "number";
    }
    if ((options.wildcard != null) && S(this.input).startsWith(options.wildcard)) {
      return this.match("0", options, callback);
    }
    next = this.match(/^(-?[0-9]+\.?[0-9]*)(.*?)$/, callback);
    showFormatHint = this.input === "" || next.input === "";
    if (showFormatHint) {
      if ((ref1 = this.context) != null) {
        ref1.addHint({
          format: 'Number'
        });
      }
    }
    return next;
  };

  Matcher.prototype.matchVariable = function(varsAndFuns, callback) {
    var match, matches, next, options, ref1, variables, varsWithDollar;
    if (this.input == null) {
      return this;
    }
    if (typeof varsAndFuns === "function") {
      callback = varsAndFuns;
      varsAndFuns = this.context;
    }
    variables = varsAndFuns.variables;
    assert((variables != null) && typeof variables === "object");
    assert(typeof callback === "function");
    options = {
      wildcard: "{variable}",
      type: "select"
    };
    varsWithDollar = _(variables).keys().map((function(_this) {
      return function(v) {
        return "$" + v;
      };
    })(this)).valueOf();
    matches = [];
    next = this.match(varsWithDollar, options, (function(_this) {
      return function(m, match) {
        return matches.push([m, match]);
      };
    })(this));
    if (matches.length > 0) {
      ref1 = _(matches).sortBy((function(_this) {
        return function(arg1) {
          var m, s;
          m = arg1[0], s = arg1[1];
          return s.length;
        };
      })(this)).last(), next = ref1[0], match = ref1[1];
      callback(next, match);
    }
    return next;
  };

  Matcher.prototype.matchString = function(options, callback) {
    var ret;
    if (this.input == null) {
      return this;
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.type) {
      options.type = "text";
    }
    if ((options.wildcard != null) && S(this.input).startsWith(options.wildcard)) {
      return this.match("\"\"", options, callback);
    }
    ret = M(null, this.context);
    this.match('"').match(/^([^"]*)(.*?)$/, (function(_this) {
      return function(m, str) {
        return ret = m.match('"', function(m) {
          return callback(m, str);
        });
      };
    })(this));
    return ret;
  };

  Matcher.prototype.matchOpenParenthese = function(token, callback) {
    var m, next, openedParentheseMatch, tokens;
    if (this.input == null) {
      return this;
    }
    tokens = [];
    openedParentheseMatch = true;
    next = this;
    while (openedParentheseMatch) {
      m = next.match(token, (function(_this) {
        return function(m) {
          tokens.push(token);
          return next = m.match(' ', {
            optional: true
          });
        };
      })(this));
      if (m.hadNoMatch()) {
        openedParentheseMatch = false;
      }
    }
    if (tokens.length > 0) {
      callback(next, tokens);
    }
    return next;
  };

  Matcher.prototype.matchCloseParenthese = function(token, openedParentheseCount, callback) {
    var closeParentheseMatch, m, next, tokens;
    if (this.input == null) {
      return this;
    }
    assert(typeof openedParentheseCount === "number");
    tokens = [];
    closeParentheseMatch = true;
    next = this;
    while (closeParentheseMatch && openedParentheseCount > 0) {
      m = next.match(' ', {
        optional: true
      }).match(token, (function(_this) {
        return function(m) {
          tokens.push(token);
          openedParentheseCount--;
          return next = m;
        };
      })(this));
      if (m.hadNoMatch()) {
        closeParentheseMatch = false;
      }
    }
    if (tokens.length > 0) {
      callback(next, tokens);
    }
    return next;
  };

  Matcher.prototype.matchFunctionCallArgs = function(varsAndFuns, arg1, callback) {
    var arg, argName, argn, func, funcName, functions, hint, i, last, ref1, ref2, ref3, ref4, tokens, variables;
    funcName = arg1.funcName, argn = arg1.argn;
    if (this.input == null) {
      return this;
    }
    if (typeof varsAndFuns === "function") {
      callback = varsAndFuns;
      varsAndFuns = this.context;
    }
    variables = varsAndFuns.variables, functions = varsAndFuns.functions;
    assert((variables != null) && typeof variables === "object");
    assert((functions != null) && typeof functions === "object");
    assert(typeof callback === "function");
    tokens = [];
    last = this;
    hint = true;
    this.matchAnyExpression(varsAndFuns, (function(_this) {
      return function(next, ts) {
        tokens = tokens.concat(ts);
        last = next;
        return next.match([',', ' , ', ' ,', ', '], {
          acFilter: function(op) {
            return op === ', ';
          }
        }, function() {
          return hint = false;
        }).matchFunctionCallArgs(varsAndFuns, {
          funcName: funcName,
          argn: argn + 1
        }, function(m, ts) {
          tokens.push(',');
          tokens = tokens.concat(ts);
          return last = m;
        });
      };
    })(this));
    if (hint && last.input === "") {
      func = functions[funcName];
      if (func.args != null) {
        i = 0;
        ref1 = func.args;
        for (argName in ref1) {
          arg = ref1[argName];
          if (arg.multiple != null) {
            if (argn > i) {
              if ((ref2 = this.context) != null) {
                ref2.addHint({
                  format: argName
                });
              }
            }
            break;
          }
          if (argn === i) {
            if (arg.optional) {
              if ((ref3 = this.context) != null) {
                ref3.addHint({
                  format: "[" + argName + "]"
                });
              }
            } else {
              if ((ref4 = this.context) != null) {
                ref4.addHint({
                  format: argName
                });
              }
            }
          }
          i++;
        }
      }
    }
    callback(last, tokens);
    return last;
  };

  Matcher.prototype.matchFunctionCall = function(varsAndFuns, callback) {
    var functions, last, tokens, variables;
    if (this.input == null) {
      return this;
    }
    if (typeof varsAndFuns === "function") {
      callback = varsAndFuns;
      varsAndFuns = this.context;
    }
    variables = varsAndFuns.variables, functions = varsAndFuns.functions;
    assert((variables != null) && typeof variables === "object");
    assert((functions != null) && typeof functions === "object");
    assert(typeof callback === "function");
    tokens = [];
    last = null;
    this.match(_.keys(functions), (function(_this) {
      return function(next, funcName) {
        tokens.push(funcName);
        return next.match(['(', ' (', ' ( ', '( '], {
          acFilter: function(op) {
            return op === '(';
          }
        }, function(next) {
          tokens.push('(');
          return next.matchFunctionCallArgs(varsAndFuns, {
            funcName: funcName,
            argn: 0
          }, function(next, ts) {
            tokens = tokens.concat(ts);
            return next.match([')', ' )'], {
              acFilter: function(op) {
                return op === ')';
              }
            }, function(next) {
              tokens.push(')');
              return last = next;
            });
          });
        });
      };
    })(this));
    if (last != null) {
      callback(last, tokens);
      return last;
    } else {
      return M(null, this.context);
    }
  };

  Matcher.prototype.matchNumericExpression = function(varsAndFuns, openParanteses, callback) {
    var binarOps, binarOpsFull, functions, last, options, tokens, variables;
    if (openParanteses == null) {
      openParanteses = 0;
    }
    if (this.input == null) {
      return this;
    }
    if (typeof varsAndFuns === "function") {
      callback = varsAndFuns;
      varsAndFuns = this.context;
      openParanteses = 0;
    }
    variables = varsAndFuns.variables, functions = varsAndFuns.functions;
    if (typeof openParanteses === "function") {
      callback = openParanteses;
      openParanteses = 0;
    }
    assert((callback != null) && typeof callback === "function");
    assert((openParanteses != null) && typeof openParanteses === "number");
    assert((variables != null) && typeof variables === "object");
    assert((functions != null) && typeof functions === "object");
    options = {
      wildcard: "{expr}",
      type: "text"
    };
    if ((options.wildcard != null) && S(this.input).startsWith(options.wildcard)) {
      return this.match([[[0], "0"]], options, callback);
    }
    binarOps = ['+', '-', '*', '/'];
    binarOpsFull = _(binarOps).map((function(_this) {
      return function(op) {
        return [op, " " + op + " ", " " + op, op + " "];
      };
    })(this)).flatten().valueOf();
    last = null;
    tokens = [];
    this.matchOpenParenthese('(', (function(_this) {
      return function(m, ptokens) {
        tokens = tokens.concat(ptokens);
        return openParanteses += ptokens.length;
      };
    })(this)).or([
      ((function(_this) {
        return function(m) {
          return m.matchNumber(function(m, match) {
            tokens.push(parseFloat(match));
            return last = m;
          });
        };
      })(this)), ((function(_this) {
        return function(m) {
          return m.matchVariable(varsAndFuns, function(m, match) {
            tokens.push(match);
            return last = m;
          });
        };
      })(this)), ((function(_this) {
        return function(m) {
          return m.matchFunctionCall(varsAndFuns, function(m, match) {
            tokens = tokens.concat(match);
            return last = m;
          });
        };
      })(this))
    ]).matchCloseParenthese(')', openParanteses, (function(_this) {
      return function(m, ptokens) {
        tokens = tokens.concat(ptokens);
        openParanteses -= ptokens.length;
        return last = m;
      };
    })(this)).match(binarOpsFull, {
      acFilter: (function(_this) {
        return function(op) {
          return op[0] === ' ' && op[op.length - 1] === ' ';
        };
      })(this)
    }, (function(_this) {
      return function(m, op) {
        return m.matchNumericExpression(varsAndFuns, openParanteses, function(m, nextTokens) {
          tokens.push(op.trim());
          tokens = tokens.concat(nextTokens);
          return last = m;
        });
      };
    })(this));
    if (last != null) {
      last.reduceElementsFrom(this, options);
      callback(last, tokens);
      return last;
    } else {
      return M(null, this.context);
    }
  };

  Matcher.prototype.matchStringWithVars = function(varsAndFuns, callback) {
    var functions, last, next, options, tokens, variables;
    if (this.input == null) {
      return this;
    }
    if (typeof varsAndFuns === "function") {
      callback = varsAndFuns;
      varsAndFuns = this.context;
    }
    variables = varsAndFuns.variables, functions = varsAndFuns.functions;
    assert((variables != null) && typeof variables === "object");
    assert((functions != null) && typeof functions === "object");
    assert(typeof callback === "function");
    options = {
      wildcard: "{expr}",
      type: "text"
    };
    if ((options.wildcard != null) && S(this.input).startsWith(options.wildcard)) {
      return this.match([[["\"\""], "\"\""]], options, callback);
    }
    last = null;
    tokens = [];
    next = this.match('"');
    while (next.hadMatch() && (last == null)) {
      next.match(/((?:(?:\\\\)*(?:\\.|[^"\$\{]))*)(.*?)$/, (function(_this) {
        return function(m, strPart) {
          var end;
          strPart = strPart.replace(/(^|[^\\]|(\\\\)+)(\\n)/g, '$1$2\n');
          strPart = strPart.replace(/(^|[^\\]|(\\\\)+)(\\r)/g, '$1$2\r');
          strPart = strPart.replace(/\\(["\$\\\\{\\}])/g, '$1');
          tokens.push('"' + strPart + '"');
          end = m.match('"');
          if (end.hadMatch()) {
            return last = end;
          } else {
            return next = m.or([
              (function(m) {
                next = m.matchVariable(varsAndFuns, function(m, match) {
                  return tokens.push(match);
                });
                return next;
              }), (function(m) {
                var retMatcher;
                retMatcher = M(null, _this.context);
                m.match(['{', '{ '], {
                  acFilter: function(t) {
                    return t === '{';
                  }
                }, function(m, match) {
                  return m.matchAnyExpression(varsAndFuns, function(m, ts) {
                    return m.match(['}', ' }'], {
                      acFilter: function(t) {
                        return t === '}';
                      }
                    }, function(m) {
                      tokens.push('(');
                      tokens = tokens.concat(ts);
                      tokens.push(')');
                      return retMatcher = m;
                    });
                  });
                });
                return retMatcher;
              })
            ]);
          }
        };
      })(this));
    }
    if (last != null) {
      last.reduceElementsFrom(this, options);
      callback(last, tokens);
      return last;
    } else {
      return M(null, this.context);
    }
  };

  Matcher.prototype.reduceElementsFrom = function(matcher, options) {
    var fullMatch, ref1;
    fullMatch = this.getFullMatch();
    this.elements = matcher.elements.concat({
      type: "text",
      match: fullMatch.substring(matcher.getFullMatch().length),
      wildcard: options.wildcard
    });
    return (ref1 = this.context) != null ? ref1.addElements(fullMatch, this.elements) : void 0;
  };

  Matcher.prototype.matchAnyExpression = function(varsAndFuns, callback) {
    var functions, next, tokens, variables;
    if (this.input == null) {
      return this;
    }
    if (typeof varsAndFuns === "function") {
      callback = varsAndFuns;
      varsAndFuns = this.context;
    }
    variables = varsAndFuns.variables, functions = varsAndFuns.functions;
    assert((variables != null) && typeof variables === "object");
    assert((functions != null) && typeof functions === "object");
    assert(typeof callback === "function");
    tokens = null;
    next = this.or([
      ((function(_this) {
        return function(m) {
          return m.matchStringWithVars(varsAndFuns, function(m, ts) {
            tokens = ts;
            return m;
          });
        };
      })(this)), ((function(_this) {
        return function(m) {
          return m.matchNumericExpression(varsAndFuns, function(m, ts) {
            tokens = ts;
            return m;
          });
        };
      })(this))
    ]);
    if (tokens != null) {
      callback(next, tokens);
    }
    return next;
  };

  Matcher.prototype.matchComparator = function(type, callback) {
    var autocompleteFilter, possibleComparators;
    if (this.input == null) {
      return this;
    }
    assert(type === 'number' || type === 'string' || type === 'boolean');
    assert(typeof callback === "function");
    possibleComparators = ((function() {
      switch (type) {
        case 'number':
          return _(comparators).values().flatten();
        case 'string':
        case 'boolean':
          return _(comparators['=='].concat(comparators['!=']));
      }
    })()).map((function(_this) {
      return function(c) {
        return " " + c + " ";
      };
    })(this)).value();
    autocompleteFilter = (function(_this) {
      return function(v) {
        var ref1;
        return (ref1 = v.trim()) === 'is' || ref1 === 'is not' || ref1 === 'equals' || ref1 === 'is greater than' || ref1 === 'is less than' || ref1 === 'is greater or equal than' || ref1 === 'is less or equal than' || ref1 === '<' || ref1 === '=' || ref1 === '>' || ref1 === '<=' || ref1 === '>=';
      };
    })(this);
    return this.match(possibleComparators, {
      acFilter: autocompleteFilter
    }, ((function(_this) {
      return function(m, token) {
        var comparator;
        comparator = normalizeComparator(token.trim());
        return callback(m, comparator);
      };
    })(this)));
  };


  /*
  Matches any of the given devices.
   */

  Matcher.prototype.matchDevice = function(devices, callback) {
    var d, devicesWithId, devicesWithNames, id, m, matchingDevices, next, onIdMatch, onNameMatch, ref1;
    if (callback == null) {
      callback = null;
    }
    if (this.input == null) {
      return this;
    }
    devicesWithId = _(devices).map((function(_this) {
      return function(d) {
        return [d, d.id];
      };
    })(this)).value();
    devicesWithNames = _(devices).map((function(_this) {
      return function(d) {
        return [d, d.name];
      };
    })(this)).value();
    matchingDevices = {};
    onIdMatch = (function(_this) {
      return function(m, d) {
        if (matchingDevices[d.id] == null) {
          return matchingDevices[d.id] = {
            m: m,
            d: d
          };
        } else {
          if (d.id.length > d.name.length) {
            return matchingDevices[d.id].m = m;
          }
        }
      };
    })(this);
    onNameMatch = (function(_this) {
      return function(m, d) {
        if (matchingDevices[d.id] == null) {
          return matchingDevices[d.id] = {
            m: m,
            d: d
          };
        } else {
          if (d.name.length > d.id.length) {
            return matchingDevices[d.id].m = m;
          }
        }
      };
    })(this);
    next = this.match('the ', {
      optional: true,
      type: "static"
    }).or([
      (function(_this) {
        return function(m) {
          return m.match(devicesWithId, {
            wildcard: "{device}",
            type: "select"
          }, onIdMatch);
        };
      })(this), (function(_this) {
        return function(m) {
          return m.match(devicesWithNames, {
            wildcard: "{device}",
            type: "select",
            ignoreCase: true
          }, onNameMatch);
        };
      })(this)
    ]);
    for (id in matchingDevices) {
      ref1 = matchingDevices[id], m = ref1.m, d = ref1.d;
      callback(m, d);
    }
    return next;
  };

  Matcher.prototype.matchTimeDurationExpression = function(varsAndFuns, callback) {
    var functions, m, onMatchUnit, onTimeExpressionMatch, timeUnits, tokens, unit, variables;
    if (this.input == null) {
      return this;
    }
    if (typeof varsAndFuns === "function") {
      callback = varsAndFuns;
      varsAndFuns = this.context;
    }
    variables = varsAndFuns.variables, functions = varsAndFuns.functions;
    assert((variables != null) && typeof variables === "object");
    assert((functions != null) && typeof functions === "object");
    assert(typeof callback === "function");
    timeUnits = ["ms", "second", "seconds", "s", "minute", "minutes", "m", "hour", "hours", "h", "day", "days", "d", "year", "years", "y"];
    tokens = 0;
    unit = "";
    onTimeExpressionMatch = (function(_this) {
      return function(m, ts) {
        return tokens = ts;
      };
    })(this);
    onMatchUnit = (function(_this) {
      return function(m, u) {
        return unit = u.trim();
      };
    })(this);
    m = this.matchNumericExpression(varsAndFuns, onTimeExpressionMatch).match(_(timeUnits).map((function(_this) {
      return function(u) {
        return [" " + u, u];
      };
    })(this)).flatten().valueOf(), {
      acFilter: (function(_this) {
        return function(u) {
          return u[0] === ' ';
        };
      })(this)
    }, onMatchUnit);
    if (m.hadMatch()) {
      callback(m, {
        tokens: tokens,
        unit: unit
      });
    }
    return m;
  };

  Matcher.prototype.matchTimeDuration = function(options, callback) {
    var m, onMatchUnit, onTimeMatch, time, timeMs, timeUnits, unit;
    if (options == null) {
      options = null;
    }
    if (this.input == null) {
      return this;
    }
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    timeUnits = ["ms", "second", "seconds", "s", "minute", "minutes", "m", "hour", "hours", "h", "day", "days", "d", "year", "years", "y"];
    time = 0;
    unit = "";
    onTimeMatch = (function(_this) {
      return function(m, n) {
        return time = parseFloat(n);
      };
    })(this);
    onMatchUnit = (function(_this) {
      return function(m, u) {
        return unit = u;
      };
    })(this);
    m = this.matchNumber(options, onTimeMatch).match(_(timeUnits).map((function(_this) {
      return function(u) {
        return [" " + u, u];
      };
    })(this)).flatten().valueOf(), {
      acFilter: (function(_this) {
        return function(u) {
          return u[0] === ' ';
        };
      })(this)
    }, onMatchUnit);
    if (m.hadMatch()) {
      timeMs = milliseconds.parse(time + " " + unit);
      callback(m, {
        time: time,
        unit: unit,
        timeMs: timeMs
      });
    }
    return m;
  };

  Matcher.prototype.optional = function(callback) {
    var next;
    if (this.input == null) {
      return this;
    }
    next = callback(this);
    if (next.hadMatch()) {
      return next;
    } else {
      return this;
    }
  };


  /*
  The given callback will be called for every empty string in the inputs of the current matcher.
   */

  Matcher.prototype.onEnd = function(callback) {
    var ref1;
    if (((ref1 = this.input) != null ? ref1.length : void 0) === 0) {
      return callback();
    }
  };


  /*
  The given callback will be called for every string in the inputs of the current matcher.
   */

  Matcher.prototype.ifhadMatches = function(callback) {
    if (this.input != null) {
      return callback(this.input);
    }
  };


  /*
    m.inAnyOrder([
      (m) => m.match(' title:').matchString(setTitle)
      (m) => m.match(' message:').matchString(setMessage)  
    ]).onEnd(...)
   */

  Matcher.prototype.inAnyOrder = function(callbacks) {
    var current, hadMatch, l, len1, m, next;
    assert(Array.isArray(callbacks));
    hadMatch = true;
    current = this;
    while (hadMatch) {
      hadMatch = false;
      for (l = 0, len1 = callbacks.length; l < len1; l++) {
        next = callbacks[l];
        assert(typeof next === "function");
        m = next(current);
        assert(m instanceof Matcher);
        if (!m.hadNoMatch()) {
          hadMatch = true;
          current = m;
        }
      }
    }
    return current;
  };

  Matcher.prototype.or = function(callbacks) {
    var cb, l, len1, m, matches, next;
    assert(Array.isArray(callbacks));
    matches = [];
    for (l = 0, len1 = callbacks.length; l < len1; l++) {
      cb = callbacks[l];
      m = cb(this);
      assert(m instanceof Matcher);
      matches.push(m);
    }
    next = _.max(matches, (function(_this) {
      return function(m) {
        if (m.input != null) {
          return m.prevInput.length;
        } else {
          return 0;
        }
      };
    })(this));
    return next;
  };

  Matcher.prototype.hadNoMatch = function() {
    return this.input == null;
  };

  Matcher.prototype.hadMatch = function() {
    return this.input != null;
  };

  Matcher.prototype.getFullMatch = function() {
    if (this.input == null) {
      return null;
    } else {
      return this.prevInput;
    }
  };

  Matcher.prototype.getRemainingInput = function() {
    return this.input;
  };

  Matcher.prototype.dump = function(info) {
    if (info != null) {
      console.log(info + ":");
    }
    console.log("prevInput: \"" + this.prevInput + "\" ");
    console.log("input: \"" + this.input + "\"");
    return this;
  };

  return Matcher;

})();

M = function() {
  var args;
  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  return (function(func, args, ctor) {
    ctor.prototype = func.prototype;
    var child = new ctor, result = func.apply(child, args);
    return Object(result) === result ? result : child;
  })(Matcher, args, function(){});
};

M.createParseContext = function(variables, functions) {
  var context;
  return context = {
    autocomplete: [],
    format: [],
    errors: [],
    warnings: [],
    elements: {},
    variables: variables,
    functions: functions,
    addHint: function(arg1) {
      var a, f;
      a = arg1.autocomplete, f = arg1.format;
      if (a != null) {
        if (Array.isArray(a)) {
          this.autocomplete = this.autocomplete.concat(a);
        } else {
          this.autocomplete.push(a);
        }
      }
      if (f != null) {
        if (Array.isArray(f)) {
          return this.format = this.format.concat(f);
        } else {
          return this.format.push(f);
        }
      }
    },
    addError: function(message) {
      return this.errors.push(message);
    },
    addWarning: function(message) {
      return this.warnings.push(message);
    },
    hasErrors: function() {
      return this.errors.length > 0;
    },
    getErrorsAsString: function() {
      return _(this.errors).reduce((function(_this) {
        return function(ms, m) {
          return ms + ", " + m;
        };
      })(this));
    },
    addElements: function(input, elements) {
      return this.elements[input] = elements;
    },
    finalize: function() {
      this.autocomplete = _(this.autocomplete).uniq().sortBy((function(_this) {
        return function(s) {
          return s.toLowerCase();
        };
      })(this)).value();
      return this.format = _(this.format).uniq().sortBy((function(_this) {
        return function(s) {
          return s.toLowerCase();
        };
      })(this)).value();
    }
  };
};

module.exports = M;

module.exports.Matcher = Matcher;
