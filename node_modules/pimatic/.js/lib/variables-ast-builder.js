
/*
variables AST Builder
===========
Builds a Abstract Syntax Tree (AST) from a variable expression token sequence.
 */
var AddExpression, DivExpression, Expression, ExpressionTreeBuilder, FunctionCallExpression, MulExpression, NumberExpression, Promise, S, StringConcatExpression, StringExpression, SubExpression, VariableExpression, _, assert, cassert, util,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

cassert = require('cassert');

assert = require('assert');

util = require('util');

Promise = require('bluebird');

_ = require('lodash');

S = require('string');

Expression = (function() {
  function Expression() {}

  return Expression;

})();

AddExpression = (function(superClass) {
  extend(AddExpression, superClass);

  function AddExpression(left1, right1) {
    this.left = left1;
    this.right = right1;
  }

  AddExpression.prototype.evaluate = function(cache) {
    return this.left.evaluate(cache, true).then((function(_this) {
      return function(val1) {
        return _this.right.evaluate(cache, true).then(function(val2) {
          return parseFloat(val1) + parseFloat(val2);
        });
      };
    })(this));
  };

  AddExpression.prototype.toString = function() {
    return "add(" + (this.left.toString()) + ", " + (this.right.toString()) + ")";
  };

  AddExpression.prototype.getUnit = function() {
    var leftUnit, rightUnit;
    leftUnit = this.left.getUnit();
    rightUnit = this.right.getUnit();
    if (leftUnit != null) {
      return leftUnit;
    } else {
      return rightUnit;
    }
  };

  return AddExpression;

})(Expression);

SubExpression = (function(superClass) {
  extend(SubExpression, superClass);

  function SubExpression(left1, right1) {
    this.left = left1;
    this.right = right1;
  }

  SubExpression.prototype.evaluate = function(cache) {
    return this.left.evaluate(cache, true).then((function(_this) {
      return function(val1) {
        return _this.right.evaluate(cache, true).then(function(val2) {
          return parseFloat(val1) - parseFloat(val2);
        });
      };
    })(this));
  };

  SubExpression.prototype.toString = function() {
    return "sub(" + (this.left.toString()) + ", " + (this.right.toString()) + ")";
  };

  SubExpression.prototype.getUnit = function() {
    var leftUnit, rightUnit;
    leftUnit = this.left.getUnit();
    rightUnit = this.right.getUnit();
    if ((leftUnit != null) && leftUnit.length > 0) {
      return leftUnit;
    } else {
      return rightUnit;
    }
  };

  return SubExpression;

})(Expression);

MulExpression = (function(superClass) {
  extend(MulExpression, superClass);

  function MulExpression(left1, right1) {
    this.left = left1;
    this.right = right1;
  }

  MulExpression.prototype.evaluate = function(cache) {
    return this.left.evaluate(cache, true).then((function(_this) {
      return function(val1) {
        return _this.right.evaluate(cache, true).then(function(val2) {
          return parseFloat(val1) * parseFloat(val2);
        });
      };
    })(this));
  };

  MulExpression.prototype.toString = function() {
    return "mul(" + (this.left.toString()) + ", " + (this.right.toString()) + ")";
  };

  MulExpression.prototype.getUnit = function() {
    var leftUnit, rightUnit;
    leftUnit = this.left.getUnit();
    rightUnit = this.right.getUnit();
    if ((leftUnit != null) && leftUnit.length > 0) {
      if ((rightUnit != null) && rightUnit.length > 0) {
        return leftUnit + "*" + rightUnit;
      } else {
        return leftUnit;
      }
    } else {
      return rightUnit;
    }
  };

  return MulExpression;

})(Expression);

DivExpression = (function(superClass) {
  extend(DivExpression, superClass);

  function DivExpression(left1, right1) {
    this.left = left1;
    this.right = right1;
  }

  DivExpression.prototype.evaluate = function(cache) {
    return this.left.evaluate(cache, true).then((function(_this) {
      return function(val1) {
        return _this.right.evaluate(cache, true).then(function(val2) {
          return parseFloat(val1) / parseFloat(val2);
        });
      };
    })(this));
  };

  DivExpression.prototype.toString = function() {
    return "div(" + (this.left.toString()) + ", " + (this.right.toString()) + ")";
  };

  DivExpression.prototype.getUnit = function() {
    var leftUnit, rightUnit;
    leftUnit = this.left.getUnit();
    rightUnit = this.right.getUnit();
    if ((leftUnit != null) && leftUnit.length > 0) {
      if ((rightUnit != null) && rightUnit.length > 0) {
        return leftUnit + "/" + rightUnit;
      } else {
        return leftUnit;
      }
    } else {
      if ((rightUnit != null) && rightUnit.length > 0) {
        return "1/" + rightUnit;
      } else {
        return null;
      }
    }
  };

  return DivExpression;

})(Expression);

NumberExpression = (function(superClass) {
  extend(NumberExpression, superClass);

  function NumberExpression(value1) {
    this.value = value1;
  }

  NumberExpression.prototype.evaluate = function(cache) {
    return Promise.resolve(this.value);
  };

  NumberExpression.prototype.toString = function() {
    return "num(" + this.value + ")";
  };

  NumberExpression.prototype.getUnit = function() {
    return null;
  };

  return NumberExpression;

})(Expression);

VariableExpression = (function(superClass) {
  extend(VariableExpression, superClass);

  function VariableExpression(variable1) {
    this.variable = variable1;
  }

  VariableExpression.prototype.evaluate = function(cache, expectNumeric) {
    var name, val;
    name = this.variable.name;
    val = cache[name];
    return Promise.resolve().then((function(_this) {
      return function() {
        if (cache[name] != null) {
          if (cache[name].value != null) {
            return cache[name].value;
          } else {
            throw new Error("Dependency cycle detected for variable " + name);
          }
        } else {
          cache[name] = {};
          return _this.variable.getUpdatedValue(cache).then(function(value) {
            cache[name].value = value;
            return value;
          });
        }
      };
    })(this)).then((function(_this) {
      return function(val) {
        var numVal;
        if (expectNumeric) {
          numVal = parseFloat(val);
          if (isNaN(numVal)) {
            throw new Error("Expected variable " + _this.variable.name + " to have a numeric value.");
          }
          return numVal;
        } else {
          return val;
        }
      };
    })(this));
  };

  VariableExpression.prototype.getUnit = function() {
    return this.variable.unit;
  };

  VariableExpression.prototype.toString = function() {
    return "var(" + this.variable.name + ")";
  };

  return VariableExpression;

})(Expression);

FunctionCallExpression = (function(superClass) {
  extend(FunctionCallExpression, superClass);

  function FunctionCallExpression(name1, func1, args1) {
    this.name = name1;
    this.func = func1;
    this.args = args1;
  }

  FunctionCallExpression.prototype.evaluate = function(cache) {
    var context;
    context = {
      units: _.map(this.args, function(a) {
        return a.getUnit();
      })
    };
    return Promise.map(this.args, (function(a) {
      return a.evaluate(cache);
    }), {
      concurrency: 1
    }).then((function(_this) {
      return function(args) {
        return _this.func.exec.apply(context, args);
      };
    })(this));
  };

  FunctionCallExpression.prototype.toString = function() {
    var argsStr;
    argsStr = (this.args.length > 0 ? _.reduce(this.args, function(l, r) {
      return (l.toString()) + ", " + (r.toString());
    }) : "");
    return "fun(" + this.name + ", [" + argsStr + "])";
  };

  FunctionCallExpression.prototype.getUnit = function() {
    if (this.func.unit != null) {
      return this.func.unit();
    }
    return '';
  };

  return FunctionCallExpression;

})(Expression);

StringExpression = (function(superClass) {
  extend(StringExpression, superClass);

  function StringExpression(value1) {
    this.value = value1;
  }

  StringExpression.prototype.evaluate = function() {
    return Promise.resolve(this.value);
  };

  StringExpression.prototype.toString = function() {
    return "str('" + this.value + "')";
  };

  StringExpression.prototype.getUnit = function() {
    return null;
  };

  return StringExpression;

})(Expression);

StringConcatExpression = (function(superClass) {
  extend(StringConcatExpression, superClass);

  function StringConcatExpression(left1, right1) {
    this.left = left1;
    this.right = right1;
  }

  StringConcatExpression.prototype.evaluate = function(cache) {
    return this.left.evaluate(cache).then((function(_this) {
      return function(val1) {
        return _this.right.evaluate(cache).then(function(val2) {
          return "" + val1 + val2;
        });
      };
    })(this));
  };

  StringConcatExpression.prototype.toString = function() {
    return "con(" + (this.left.toString()) + ", " + (this.right.toString()) + ")";
  };

  StringConcatExpression.prototype.getUnit = function() {
    return null;
  };

  return StringConcatExpression;

})(Expression);

ExpressionTreeBuilder = (function() {
  function ExpressionTreeBuilder(variables, functions) {
    this.variables = variables;
    this.functions = functions;
    assert((this.variables != null) && typeof this.variables === "object");
    assert((this.functions != null) && typeof this.functions === "object");
  }

  ExpressionTreeBuilder.prototype._nextToken = function() {
    if (this.pos < this.tokens.length) {
      return this.token = this.tokens[this.pos++];
    } else {
      return this.token = '';
    }
  };

  ExpressionTreeBuilder.prototype.build = function(tokens) {
    this.tokens = tokens;
    this.pos = 0;
    this._nextToken();
    return this._buildExpression();
  };

  ExpressionTreeBuilder.prototype._buildExpression = function() {
    var left;
    left = this._buildTerm();
    return this._buildExpressionPrime(left);
  };

  ExpressionTreeBuilder.prototype._buildExpressionPrime = function(left) {
    var right;
    switch (this.token) {
      case '+':
        this._nextToken();
        right = this._buildTerm();
        return this._buildExpressionPrime(new AddExpression(left, right));
      case '-':
        this._nextToken();
        right = this._buildTerm();
        return this._buildExpressionPrime(new SubExpression(left, right));
      case ')':
      case '':
      case ',':
        return left;
      default:
        return assert(false, "unexpected token: '" + this.token + "'");
    }
  };

  ExpressionTreeBuilder.prototype._buildTerm = function() {
    var left;
    left = this._buildFactor();
    return this._buildTermPrime(left);
  };

  ExpressionTreeBuilder.prototype._buildTermPrime = function(left) {
    var right;
    switch (this.token) {
      case '*':
        this._nextToken();
        right = this._buildFactor();
        return this._buildTermPrime(new MulExpression(left, right));
      case '/':
        this._nextToken();
        right = this._buildFactor();
        return this._buildTermPrime(new DivExpression(left, right));
      case '+':
      case '-':
      case ')':
      case '':
      case ',':
        return left;
      default:
        right = this._buildFactor();
        return this._buildTermPrime(new StringConcatExpression(left, right));
    }
  };

  ExpressionTreeBuilder.prototype._buildFactor = function() {
    var args, expr, func, funcCallExpr, funcName, numberExpr, ref, str, strExpr, varExpr, varName, variable;
    switch (false) {
      case this.token !== '(':
        this._nextToken();
        expr = this._buildExpression();
        cassert(this.token === ')');
        this._nextToken();
        return expr;
      case !this._isNumberToken():
        numberExpr = new NumberExpression(this.token);
        this._nextToken();
        return numberExpr;
      case !this._isVariableToken():
        varName = this.token.substr(1);
        variable = this.variables[varName];
        if (variable == null) {
          throw new Error("Could not find variable " + this.token);
        }
        varExpr = new VariableExpression(variable);
        this._nextToken();
        return varExpr;
      case !this._isStringToken():
        str = this.token.slice(1, this.token.length - 1);
        strExpr = new StringExpression(str);
        this._nextToken();
        return strExpr;
      case this.token.match(/[_a-zA-Z][_a-zA-Z0-9]*/) == null:
        funcName = this.token;
        func = this.functions[funcName];
        if (func == null) {
          throw new Error("Could not find function " + funcName);
        }
        this._nextToken();
        cassert(this.token === '(');
        this._nextToken();
        args = [];
        while (this.token !== ')') {
          args.push(this._buildExpression());
          cassert((ref = this.token) === ')' || ref === ',');
          if (this.token === ',') {
            this._nextToken();
          }
        }
        cassert(this.token === ')');
        this._nextToken();
        funcCallExpr = new FunctionCallExpression(funcName, func, args);
        return funcCallExpr;
      default:
        return assert(false, "unexpected token: '" + this.token + "'");
    }
  };

  ExpressionTreeBuilder.prototype._isStringToken = function() {
    return this.token.length > 0 && this.token[0] === '"';
  };

  ExpressionTreeBuilder.prototype._isVariableToken = function() {
    return this.token.length > 0 && this.token[0] === '$';
  };

  ExpressionTreeBuilder.prototype._isNumberToken = function() {
    return typeof this.token === "number";
  };

  return ExpressionTreeBuilder;

})();

module.exports = {
  AddExpression: AddExpression,
  SubExpression: SubExpression,
  MulExpression: MulExpression,
  DivExpression: DivExpression,
  NumberExpression: NumberExpression,
  VariableExpression: VariableExpression,
  ExpressionTreeBuilder: ExpressionTreeBuilder
};
