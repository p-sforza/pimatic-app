
/*
Devices
=======
 */
var Promise, _, assert, cassert, declapi, events, t,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

cassert = require('cassert');

assert = require('assert');

Promise = require('bluebird');

_ = require('lodash');

t = require('decl-api').types;

declapi = require('decl-api');

events = require('events');

module.exports = function(env) {

  /*
  Device
  -----
  The Device class is the common superclass for all devices like actuators or sensors.
   */
  var AVPlayer, Actuator, AttributeOptionsConfigExtension, ButtonsDevice, ConfirmDeviceConfigExtention, ContactLabelConfigExtension, ContactSensor, Device, DeviceConfigExtension, DeviceManager, DimmerActuator, DummyContactSensor, DummyDimmer, DummyHeatingThermostat, DummyPresenceSensor, DummyShutter, DummySwitch, DummyTemperatureSensor, ErrorDevice, HeatingThermostat, InputDevice, LinkDeviceConfigExtention, PowerSwitch, PresenceSensor, PresentLabelConfigExtension, Sensor, ShutterController, SwitchActuator, SwitchLabelConfigExtension, TemperatureSensor, Timer, VariableInputDevice, VariableTimeInputDevice, VariablesDevice, XButtonDeviceConfigExtension, exports, upperCaseFirst;
  Device = (function(superClass) {
    extend(Device, superClass);

    Device.prototype.id = null;

    Device.prototype.name = null;

    Device.prototype.actions = {};

    Device.prototype.attributes = {};

    Device.prototype.template = "device";

    Device.prototype.config = {};

    Device.prototype._checkAttributes = function() {
      var attr, results;
      results = [];
      for (attr in this.attributes) {
        results.push(this._checkAttribute(attr));
      }
      return results;
    };

    Device.prototype._checkAttribute = function(attrName) {
      var attr, isValidType;
      attr = this.attributes[attrName];
      assert(attr.description != null, "No description for " + attrName + " of " + this.name + " given");
      assert(attr.type != null, "No type for " + attrName + " of " + this.name + " given");
      isValidType = (function(_this) {
        return function(type) {
          return indexOf.call(_.values(t), type) >= 0;
        };
      })(this);
      assert(isValidType(attr.type), attrName + " of " + this.name + " has no valid type.");
      if (attr.type === t.number && (attr.unit == null)) {
        attr.unit = '';
      }
      if (attr.type === t.boolean && !attr.labels) {
        attr.labels = ["true", "false"];
      }
      if (!attr.label) {
        attr.label = upperCaseFirst(attrName);
      }
      if (attr.discrete == null) {
        return attr.discrete = (attr.type === "number" ? false : true);
      }
    };

    function Device() {
      var attr, attrName, ref;
      assert(this.id != null, "The device has no ID");
      assert(this.name != null, "The device has no name");
      assert(this.id.length !== 0, "The ID of the device is empty");
      assert(this.name.length !== 0, "The name of the device is empty");
      this._checkAttributes();
      this._constructorCalled = true;
      this._attributesMeta = {};
      ref = this.attributes;
      for (attrName in ref) {
        attr = ref[attrName];
        this._initAttributeMeta(attrName, attr);
      }
    }

    Device.prototype._initAttributeMeta = function(attrName, attr) {
      var attrListener, device;
      device = this;
      this._attributesMeta[attrName] = {
        value: null,
        error: null,
        history: [],
        update: function(value) {
          var ref, timestamp;
          if (((ref = attr.type) === "number" || ref === "integer") && typeof value === "string") {
            env.logger.error(("Got string value for attribute " + attrName + " of " + device.constructor.name + " but ") + ("attribute type is " + attr.type + "."));
          }
          timestamp = (new Date()).getTime();
          this.value = value;
          this.lastUpdate = timestamp;
          if (this.history.length === 30) {
            this.history.shift();
          }
          return this.history.push({
            t: timestamp,
            v: value
          });
        }
      };
      attrListener = (function(_this) {
        return function(value) {
          return _this._attributesMeta[attrName].update(value);
        };
      })(this);
      this._attributesMeta[attrName].attrListener = attrListener;
      return this.on(attrName, attrListener);
    };

    Device.prototype.destroy = function() {
      var attrName;
      this.emit('destroy', this);
      this.removeAllListeners('destroy');
      for (attrName in this.attributes) {
        this.removeAllListeners(attrName);
      }
      this._destroyed = true;
    };

    Device.prototype.afterRegister = function() {
      var attrName, results;
      results = [];
      for (attrName in this.attributes) {
        results.push((function(_this) {
          return function(attrName) {
            var meta;
            meta = _this._attributesMeta[attrName];
            if (meta.value == null) {
              return _this.getUpdatedAttributeValue(attrName).then(function(value) {
                if ((meta.lastUpdate == null) || (new Date().getTime() - meta.lastUpdate)) {
                  return _this.emit(attrName, value);
                }
              })["catch"](function(err) {
                return _this.logAttributeError(attrName, err);
              }).done();
            }
          };
        })(this)(attrName));
      }
      return results;
    };

    Device.prototype.hasAction = function(name) {
      return this.actions[name] != null;
    };

    Device.prototype.hasAttribute = function(name) {
      return this.attributes[name] != null;
    };

    Device.prototype.getLastAttributeValue = function(attrName) {
      return this._attributesMeta[attrName].value;
    };

    Device.prototype.addAttribute = function(name, attribute) {
      assert(!this._constructorCalled, "Attributes can only be added in the constructor");
      if (this.attributes === this.constructor.prototype.attributes) {
        this.attributes = _.clone(this.attributes);
      }
      return this.attributes[name] = attribute;
    };

    Device.prototype.addAction = function(name, action) {
      assert(!this._constructorCalled, "Actions can only be added in the constructor");
      if (this.actions === this.constructor.prototype.actions) {
        this.actions = _.clone(this.actions);
      }
      return this.actions[name] = action;
    };

    Device.prototype.updateName = function(name) {
      if (name === this.name) {
        return;
      }
      this.name = name;
      return this.emit("nameChanged", this);
    };

    Device.prototype.getUpdatedAttributeValue = function(attrName, arg) {
      var getter, result;
      getter = 'get' + upperCaseFirst(attrName);
      assert(this[getter] != null, "Method " + getter + " of " + this.name + " does not exist!");
      result = Promise.resolve().then((function(_this) {
        return function() {
          return _this[getter](arg);
        };
      })(this));
      return result;
    };

    Device.prototype.getUpdatedAttributeValueCached = function(attrName, arg) {
      if (!this._promiseCache) {
        this._promiseCache = {};
      }
      if (this._promiseCache[attrName] != null) {
        return this._promiseCache[attrName];
      }
      this._promiseCache[attrName] = this.getUpdatedAttributeValue(attrName, arg).then((function(_this) {
        return function(value) {
          delete _this._promiseCache[attrName];
          return value;
        };
      })(this), (function(_this) {
        return function(error) {
          delete _this._promiseCache[attrName];
          throw error;
        };
      })(this));
      return this._promiseCache[attrName];
    };

    Device.prototype._createGetter = function(attributeName, fn) {
      var getterName;
      getterName = 'get' + attributeName[0].toUpperCase() + attributeName.slice(1);
      this[getterName] = fn;
    };

    Device.prototype.toJson = function() {
      var action, actionJson, attr, attrJson, json, meta, name, predicate, ref, ref1;
      json = {
        id: this.id,
        name: this.name,
        template: this.template,
        attributes: [],
        actions: [],
        config: this.config,
        configDefaults: this.config.__proto__
      };
      ref = this.attributes;
      for (name in ref) {
        attr = ref[name];
        meta = this._attributesMeta[name];
        attrJson = _.cloneDeep(attr);
        attrJson.name = name;
        attrJson.value = meta.value;
        attrJson.history = meta.history;
        attrJson.lastUpdate = meta.lastUpdate;
        json.attributes.push(attrJson);
      }
      ref1 = this.actions;
      for (name in ref1) {
        action = ref1[name];
        actionJson = _.cloneDeep(action);
        actionJson.name = name;
        json.actions.push(actionJson);
      }
      predicate = (function(_this) {
        return function(accumulator, value) {
          if ((_this instanceof value) && (_this.constructor.name !== value.name)) {
            accumulator.push(value.name);
          }
          return accumulator;
        };
      })(this);
      json.capabilities = [ErrorDevice, Actuator, SwitchActuator, PowerSwitch, DimmerActuator, ShutterController, Sensor, TemperatureSensor, PresenceSensor, ContactSensor, HeatingThermostat, ButtonsDevice, InputDevice, VariablesDevice, VariableInputDevice, VariableTimeInputDevice, AVPlayer, Timer].reduce(predicate, []);
      return json;
    };

    Device.prototype._setupPolling = function(attrName, interval) {
      var doPolling;
      if (typeof interval !== 'number') {
        throw new Error("Illegal polling interval " + interval + "!");
      }
      if (!(interval > 0)) {
        throw new Error("Polling interval must be greater then 0, was " + interval);
      }
      doPolling = (function(_this) {
        return function() {
          if (_this._destroyed) {
            return;
          }
          return Promise.resolve().then(function() {
            return _this.getUpdatedAttributeValue(attrName);
          }).then(function(value) {
            var lastUpdate;
            lastUpdate = _this._attributesMeta[attrName].lastUpdate;
            if ((lastUpdate != null) && (new Date().getTime() - lastUpdate) < 500) {
              return;
            }
            return _this.emit(attrName, value);
          })["catch"](function(err) {
            return _this.logAttributeError(attrName, err);
          })["finally"](function() {
            if (_this._destroyed) {
              return;
            }
            return setTimeout(doPolling, interval);
          }).done();
        };
      })(this);
      return setTimeout(doPolling, interval);
    };

    Device.prototype.logAttributeError = function(attrName, err) {
      var lastError;
      lastError = this._attributesMeta[attrName].error;
      if ((lastError != null) && err.message === lastError.message) {
        this.logger.debug("Suppressing repeated error for " + this.id + "." + attrName + " " + err.message);
        this.logger.debug(err.stack);
        return;
      }
      this._attributesMeta[attrName].error = err;
      this.once(attrName, (function(_this) {
        return function() {
          return _this._attributesMeta[attrName].error = null;
        };
      })(this));
      this.logger.error("Error getting attribute value " + this.id + "." + attrName + ": " + err.message);
      return this.logger.debug(err.stack);
    };

    return Device;

  })(require('events').EventEmitter);

  /*
  ErrorDevice
  -----
  Devices of this type are created if the create operation
  for the real type cant be created
   */
  ErrorDevice = (function(superClass) {
    extend(ErrorDevice, superClass);

    function ErrorDevice(config1, error1) {
      this.config = config1;
      this.error = error1;
      this.name = this.config.name;
      this.id = this.config.id;
      ErrorDevice.__super__.constructor.call(this);
    }

    ErrorDevice.prototype.destroy = function() {
      return ErrorDevice.__super__.destroy.call(this);
    };

    return ErrorDevice;

  })(Device);

  /*
  Actuator
  -----
  An Actuator is an physical or logical element you can control by triggering an action on it.
  For example a power outlet, a light or door opener.
   */
  Actuator = (function(superClass) {
    extend(Actuator, superClass);

    function Actuator() {
      return Actuator.__super__.constructor.apply(this, arguments);
    }

    return Actuator;

  })(Device);

  /*
  SwitchActuator
  -----
  A class for all devices you can switch on and off.
   */
  SwitchActuator = (function(superClass) {
    extend(SwitchActuator, superClass);

    function SwitchActuator() {
      return SwitchActuator.__super__.constructor.apply(this, arguments);
    }

    SwitchActuator.prototype._state = null;

    SwitchActuator.prototype.actions = {
      turnOn: {
        description: "Turns the switch on"
      },
      turnOff: {
        description: "Turns the switch off"
      },
      changeStateTo: {
        description: "Changes the switch to on or off",
        params: {
          state: {
            type: t.boolean
          }
        }
      },
      toggle: {
        description: "Toggle the state of the switch"
      },
      getState: {
        description: "Returns the current state of the switch",
        returns: {
          state: {
            type: t.boolean
          }
        }
      }
    };

    SwitchActuator.prototype.attributes = {
      state: {
        description: "The current state of the switch",
        type: t.boolean,
        labels: ['on', 'off']
      }
    };

    SwitchActuator.prototype.template = "switch";

    SwitchActuator.prototype.turnOn = function() {
      return this.changeStateTo(true);
    };

    SwitchActuator.prototype.turnOff = function() {
      return this.changeStateTo(false);
    };

    SwitchActuator.prototype.toggle = function() {
      return this.getState().then((function(_this) {
        return function(state) {
          return _this.changeStateTo(!state);
        };
      })(this));
    };

    SwitchActuator.prototype.changeStateTo = function(state) {
      throw new Error("Function \"changeStateTo\" is not implemented!");
    };

    SwitchActuator.prototype.getState = function() {
      return Promise.resolve(this._state);
    };

    SwitchActuator.prototype._setState = function(state) {
      if (this._state === state) {
        return;
      }
      this._state = state;
      return this.emit("state", state);
    };

    return SwitchActuator;

  })(Actuator);

  /*
  PowerSwitch
  ----------
  Just an alias for a SwitchActuator at the moment
   */
  PowerSwitch = (function(superClass) {
    extend(PowerSwitch, superClass);

    function PowerSwitch() {
      return PowerSwitch.__super__.constructor.apply(this, arguments);
    }

    return PowerSwitch;

  })(SwitchActuator);

  /*
  DimmerActuator
  -------------
  Switch with additional dim functionality.
   */
  DimmerActuator = (function(superClass) {
    extend(DimmerActuator, superClass);

    function DimmerActuator() {
      this._setDimlevel = bind(this._setDimlevel, this);
      return DimmerActuator.__super__.constructor.apply(this, arguments);
    }

    DimmerActuator.prototype._dimlevel = null;

    DimmerActuator.prototype.actions = {
      changeDimlevelTo: {
        description: "Sets the level of the dimmer",
        params: {
          dimlevel: {
            type: t.number
          }
        }
      },
      changeStateTo: {
        description: "Changes the switch to on or off",
        params: {
          state: {
            type: t.boolean
          }
        }
      },
      turnOn: {
        description: "Turns the dim level to 100%"
      },
      turnOff: {
        description: "Turns the dim level to 0%"
      },
      toggle: {
        description: "Toggle the state of the dimmer"
      }
    };

    DimmerActuator.prototype.attributes = {
      dimlevel: {
        description: "The current dim level",
        type: t.number,
        unit: "%"
      },
      state: {
        description: "The current state of the switch",
        type: t.boolean,
        labels: ['on', 'off']
      }
    };

    DimmerActuator.prototype.template = "dimmer";

    DimmerActuator.prototype.turnOn = function() {
      return this.changeDimlevelTo(100);
    };

    DimmerActuator.prototype.turnOff = function() {
      return this.changeDimlevelTo(0);
    };

    DimmerActuator.prototype.changeDimlevelTo = function(state) {
      throw new Error("Function \"changeDimlevelTo\" is not implemented!");
    };

    DimmerActuator.prototype.changeStateTo = function(state) {
      if (state) {
        return this.turnOn();
      } else {
        return this.turnOff();
      }
    };

    DimmerActuator.prototype._setDimlevel = function(level) {
      level = parseFloat(level);
      assert(!isNaN(level));
      cassert(level >= 0);
      cassert(level <= 100);
      if (this._dimlevel === level) {
        return;
      }
      this._dimlevel = level;
      this.emit("dimlevel", level);
      return this._setState(level > 0);
    };

    DimmerActuator.prototype.getDimlevel = function() {
      return Promise.resolve(this._dimlevel);
    };

    return DimmerActuator;

  })(SwitchActuator);

  /*
  ShutterController
  -----
  A class for all devices you can move up and down.
   */
  ShutterController = (function(superClass) {
    var rollingTime;

    extend(ShutterController, superClass);

    function ShutterController() {
      return ShutterController.__super__.constructor.apply(this, arguments);
    }

    ShutterController.prototype._position = null;

    rollingTime = null;

    ShutterController.prototype.attributes = {
      position: {
        label: "Position",
        description: "State of the shutter",
        type: t.string,
        "enum": ['up', 'down', 'stopped']
      }
    };

    ShutterController.prototype.actions = {
      moveUp: {
        description: "Raise the shutter"
      },
      moveDown: {
        description: "Lower the shutter"
      },
      stop: {
        description: "Stops the shutter move"
      },
      moveToPosition: {
        description: "Changes the shutter state",
        params: {
          state: {
            type: t.string
          }
        }
      },
      moveByPercentage: {
        description: "Move shutter by percentage relative to current position",
        params: {
          percentage: {
            type: t.number
          }
        }
      }
    };

    ShutterController.prototype.template = "shutter";

    ShutterController.prototype.moveUp = function() {
      return this.moveToPosition('up');
    };

    ShutterController.prototype.moveDown = function() {
      return this.moveToPosition('down');
    };

    ShutterController.prototype.stop = function() {
      throw new Error("Function \"stop\" is not implemented!");
    };

    ShutterController.prototype.moveToPosition = function(position) {
      throw new Error("Function \"moveToPosition\" is not implemented!");
    };

    ShutterController.prototype.moveByPercentage = function(percentage) {
      var duration, promise;
      duration = this._calculateRollingTime(Math.abs(percentage));
      if (duration === 0) {
        return Promise.resolve();
      }
      promise = percentage > 0 ? this.moveUp() : this.moveDown();
      promise = promise.delay(duration + 10).then((function(_this) {
        return function() {
          return _this.stop();
        };
      })(this));
      return promise;
    };

    ShutterController.prototype.getPosition = function() {
      return Promise.resolve(this._position);
    };

    ShutterController.prototype._setPosition = function(position) {
      assert(position === 'up' || position === 'down' || position === 'stopped');
      if (this._position === position) {
        return;
      }
      this._position = position;
      return this.emit("position", position);
    };

    ShutterController.prototype._calculateRollingTime = function(percentage) {
      assert((0 <= percentage && percentage <= 100), "percentage must be between 0 and 100");
      if (this.rollingTime != null) {
        return this.rollingTime * 1000 * percentage / 100;
      }
      throw new Error("No rolling time configured.");
    };

    return ShutterController;

  })(Actuator);

  /*
  Sensor
  ------
   */
  Sensor = (function(superClass) {
    extend(Sensor, superClass);

    function Sensor() {
      return Sensor.__super__.constructor.apply(this, arguments);
    }

    return Sensor;

  })(Device);

  /*
  TemperatureSensor
  ------
   */
  TemperatureSensor = (function(superClass) {
    extend(TemperatureSensor, superClass);

    function TemperatureSensor() {
      return TemperatureSensor.__super__.constructor.apply(this, arguments);
    }

    TemperatureSensor.prototype._temperature = void 0;

    TemperatureSensor.prototype.actions = {
      getTemperature: {
        description: "Returns the current temperature",
        returns: {
          temperature: {
            type: t.number
          }
        }
      }
    };

    TemperatureSensor.prototype.attributes = {
      temperature: {
        description: "The measured temperature",
        type: t.number,
        unit: '°C',
        acronym: 'T'
      }
    };

    TemperatureSensor.prototype._setTemperature = function(value) {
      this._temperature = value;
      return this.emit('temperature', value);
    };

    TemperatureSensor.prototype.getTemperature = function() {
      return Promise.resolve(this._temperature);
    };

    TemperatureSensor.prototype.template = "temperature";

    return TemperatureSensor;

  })(Sensor);

  /*
  PresenceSensor
  ------
   */
  PresenceSensor = (function(superClass) {
    extend(PresenceSensor, superClass);

    function PresenceSensor() {
      return PresenceSensor.__super__.constructor.apply(this, arguments);
    }

    PresenceSensor.prototype._presence = void 0;

    PresenceSensor.prototype.actions = {
      getPresence: {
        description: "Returns the current presence state",
        returns: {
          presence: {
            type: t.boolean
          }
        }
      }
    };

    PresenceSensor.prototype.attributes = {
      presence: {
        description: "Presence of the human/device",
        type: t.boolean,
        labels: ['present', 'absent']
      }
    };

    PresenceSensor.prototype._setPresence = function(value) {
      if (this._presence === value) {
        return;
      }
      this._presence = value;
      return this.emit('presence', value);
    };

    PresenceSensor.prototype.getPresence = function() {
      return Promise.resolve(this._presence);
    };

    PresenceSensor.prototype.template = "presence";

    return PresenceSensor;

  })(Sensor);

  /*
  ContactSensor
  ------
   */
  ContactSensor = (function(superClass) {
    extend(ContactSensor, superClass);

    function ContactSensor() {
      return ContactSensor.__super__.constructor.apply(this, arguments);
    }

    ContactSensor.prototype._contact = void 0;

    ContactSensor.prototype.actions = {
      getContact: {
        description: "Returns the current state of the contact",
        returns: {
          contact: {
            type: t.boolean
          }
        }
      }
    };

    ContactSensor.prototype.attributes = {
      contact: {
        description: "State of the contact",
        type: t.boolean,
        labels: ['closed', 'opened']
      }
    };

    ContactSensor.prototype.template = "contact";

    ContactSensor.prototype._setContact = function(value) {
      if (this._contact === value) {
        return;
      }
      this._contact = value;
      return this.emit('contact', value);
    };

    ContactSensor.prototype.getContact = function() {
      return Promise.resolve(this._contact);
    };

    return ContactSensor;

  })(Sensor);
  upperCaseFirst = function(string) {
    if (string.length !== 0) {
      return string[0].toUpperCase() + string.slice(1);
    } else {
      return "";
    }
  };
  HeatingThermostat = (function(superClass) {
    extend(HeatingThermostat, superClass);

    function HeatingThermostat() {
      return HeatingThermostat.__super__.constructor.apply(this, arguments);
    }

    HeatingThermostat.prototype.attributes = {
      temperatureSetpoint: {
        label: "Temperature Setpoint",
        description: "The temp that should be set",
        type: "number",
        discrete: true,
        unit: "°C"
      },
      valve: {
        description: "Position of the valve",
        type: "number",
        discrete: true,
        unit: "%"
      },
      mode: {
        description: "The current mode",
        type: "string",
        "enum": ["auto", "manu", "boost"]
      },
      battery: {
        description: "Battery status",
        type: "string",
        "enum": ["ok", "low"]
      },
      synced: {
        description: "Pimatic and thermostat in sync",
        type: "boolean"
      }
    };

    HeatingThermostat.prototype.actions = {
      changeModeTo: {
        params: {
          mode: {
            type: "string"
          }
        }
      },
      changeTemperatureTo: {
        params: {
          temperatureSetpoint: {
            type: "number"
          }
        }
      }
    };

    HeatingThermostat.prototype.template = "thermostat";

    HeatingThermostat.prototype._mode = null;

    HeatingThermostat.prototype._temperatureSetpoint = null;

    HeatingThermostat.prototype._valve = null;

    HeatingThermostat.prototype._battery = null;

    HeatingThermostat.prototype._synced = false;

    HeatingThermostat.prototype.getMode = function() {
      return Promise.resolve(this._mode);
    };

    HeatingThermostat.prototype.getTemperatureSetpoint = function() {
      return Promise.resolve(this._temperatureSetpoint);
    };

    HeatingThermostat.prototype.getValve = function() {
      return Promise.resolve(this._valve);
    };

    HeatingThermostat.prototype.getBattery = function() {
      return Promise.resolve(this._battery);
    };

    HeatingThermostat.prototype.getSynced = function() {
      return Promise.resolve(this._synced);
    };

    HeatingThermostat.prototype._setMode = function(mode) {
      if (mode === this._mode) {
        return;
      }
      this._mode = mode;
      return this.emit("mode", this._mode);
    };

    HeatingThermostat.prototype._setSynced = function(synced) {
      if (synced === this._synced) {
        return;
      }
      this._synced = synced;
      return this.emit("synced", this._synced);
    };

    HeatingThermostat.prototype._setSetpoint = function(temperatureSetpoint) {
      if (temperatureSetpoint === this._temperatureSetpoint) {
        return;
      }
      this._temperatureSetpoint = temperatureSetpoint;
      return this.emit("temperatureSetpoint", this._temperatureSetpoint);
    };

    HeatingThermostat.prototype._setValve = function(valve) {
      if (valve === this._valve) {
        return;
      }
      this._valve = valve;
      return this.emit("valve", this._valve);
    };

    HeatingThermostat.prototype._setBattery = function(battery) {
      if (battery === this._battery) {
        return;
      }
      this._battery = battery;
      return this.emit("battery", this._battery);
    };

    HeatingThermostat.prototype.changeModeTo = function(mode) {
      throw new Error("changeModeTo must be implemented by a subclass");
    };

    HeatingThermostat.prototype.changeTemperatureTo = function(temperatureSetpoint) {
      throw new Error("changeTemperatureTo must be implemented by a subclass");
    };

    return HeatingThermostat;

  })(Device);
  AVPlayer = (function(superClass) {
    extend(AVPlayer, superClass);

    function AVPlayer() {
      return AVPlayer.__super__.constructor.apply(this, arguments);
    }

    AVPlayer.prototype.actions = {
      play: {
        description: "starts playing"
      },
      pause: {
        description: "pauses playing"
      },
      stop: {
        description: "stops playing"
      },
      next: {
        description: "play next song"
      },
      previous: {
        description: "play previous song"
      },
      volume: {
        description: "Change volume of player"
      }
    };

    AVPlayer.prototype.attributes = {
      currentArtist: {
        description: "the current playing track artist",
        type: "string"
      },
      currentTitle: {
        description: "the current playing track title",
        type: "string"
      },
      state: {
        description: "the current state of the player",
        type: "string"
      },
      volume: {
        description: "the volume of the player",
        type: "string"
      }
    };

    AVPlayer.prototype._state = null;

    AVPlayer.prototype._currentTitle = null;

    AVPlayer.prototype._currentArtist = null;

    AVPlayer.prototype._volume = null;

    AVPlayer.prototype.template = "musicplayer";

    AVPlayer.prototype._setState = function(state) {
      if (this._state !== state) {
        this._state = state;
        return this.emit('state', state);
      }
    };

    AVPlayer.prototype._setCurrentTitle = function(title) {
      if (this._currentTitle !== title) {
        this._currentTitle = title;
        return this.emit('currentTitle', title);
      }
    };

    AVPlayer.prototype._setCurrentArtist = function(artist) {
      if (this._currentArtist !== artist) {
        this._currentArtist = artist;
        return this.emit('currentArtist', artist);
      }
    };

    AVPlayer.prototype._setVolume = function(volume) {
      if (this._volume !== volume) {
        this._volume = volume;
        return this.emit('volume', volume);
      }
    };

    AVPlayer.prototype.getState = function() {
      return Promise.resolve(this._state);
    };

    AVPlayer.prototype.getCurrentTitle = function() {
      return Promise.resolve(this._currentTitle);
    };

    AVPlayer.prototype.getCurrentArtist = function() {
      return Promise.resolve(this._currentTitle);
    };

    AVPlayer.prototype.getVolume = function() {
      return Promise.resolve(this._volume);
    };

    return AVPlayer;

  })(Device);
  ButtonsDevice = (function(superClass) {
    extend(ButtonsDevice, superClass);

    ButtonsDevice.prototype.attributes = {
      button: {
        description: "The last pressed button",
        type: t.string
      }
    };

    ButtonsDevice.prototype.actions = {
      buttonPressed: {
        params: {
          buttonId: {
            type: t.string
          }
        },
        description: "Press a button"
      }
    };

    ButtonsDevice.prototype.template = "buttons";

    ButtonsDevice.prototype._lastPressedButton = null;

    function ButtonsDevice(config1) {
      this.config = config1;
      this.id = this.config.id;
      this.name = this.config.name;
      ButtonsDevice.__super__.constructor.call(this);
    }

    ButtonsDevice.prototype.getButton = function() {
      return Promise.resolve(this._lastPressedButton);
    };

    ButtonsDevice.prototype.buttonPressed = function(buttonId) {
      var b, i, len, ref;
      ref = this.config.buttons;
      for (i = 0, len = ref.length; i < len; i++) {
        b = ref[i];
        if (b.id === buttonId) {
          this._lastPressedButton = b.id;
          this.emit('button', b.id);
          return Promise.resolve();
        }
      }
      throw new Error("No button with the id " + buttonId + " found");
    };

    ButtonsDevice.prototype.destroy = function() {
      return ButtonsDevice.__super__.destroy.call(this);
    };

    return ButtonsDevice;

  })(Device);
  InputDevice = (function(superClass) {
    extend(InputDevice, superClass);

    InputDevice.prototype._input = "";

    InputDevice.prototype.template = "input";

    InputDevice.prototype.actions = {
      changeInputTo: {
        params: {
          value: {
            type: t.string
          }
        },
        description: "Sets the input value"
      }
    };

    function InputDevice(config1, lastState) {
      var ref;
      this.config = config1;
      this.name = this.config.name;
      this.id = this.config.id;
      this._inputType = this.config.type || "string";
      this.attributes = {
        input: {
          description: "The value of the input field",
          type: this._inputType
        }
      };
      this._defaultValue = this._inputType === "string" ? "" : 0;
      this._input = (lastState != null ? (ref = lastState.input) != null ? ref.value : void 0 : void 0) || this._defaultValue;
      InputDevice.__super__.constructor.call(this);
    }

    InputDevice.prototype.getInput = function() {
      return Promise.resolve(this._input);
    };

    InputDevice.prototype._setInput = function(value) {
      if (this._input !== value) {
        this._input = value;
        return this.emit('input', value);
      }
    };

    InputDevice.prototype.changeInputTo = function(value) {
      if (this.config.type === "number") {
        if (isNaN(value)) {
          throw new Error("Input value is not a number");
        } else {
          this._setInput(parseFloat(value));
        }
      } else {
        this._setInput(value);
      }
      return Promise.resolve();
    };

    InputDevice.prototype.destroy = function() {
      return InputDevice.__super__.destroy.call(this);
    };

    return InputDevice;

  })(Device);
  VariablesDevice = (function(superClass) {
    extend(VariablesDevice, superClass);

    function VariablesDevice(config1, lastState, framework) {
      var fn1, i, len, ref, variable;
      this.config = config1;
      this.framework = framework;
      this.id = this.config.id;
      this.name = this.config.name;
      this._vars = this.framework.variableManager;
      this._exprChangeListeners = [];
      this.attributes = {};
      ref = this.config.variables;
      fn1 = (function(_this) {
        return function(variable) {
          var evaluateExpr, getValue, info, name, onChangedVar, parseExprAndAddListener;
          name = variable.name;
          info = null;
          if (_this.attributes[name] != null) {
            throw new Error("Two variables with the same name in VariablesDevice config \"" + name + "\"");
          }
          _this.attributes[name] = {
            description: name,
            label: (variable.label != null ? variable.label : "$" + name),
            type: variable.type || "string"
          };
          if ((variable.unit != null) && variable.unit.length > 0) {
            _this.attributes[name].unit = variable.unit;
          }
          if (variable.discrete != null) {
            _this.attributes[name].discrete = variable.discrete;
          }
          if (variable.acronym != null) {
            _this.attributes[name].acronym = variable.acronym;
          }
          parseExprAndAddListener = (function() {
            info = _this._vars.parseVariableExpression(variable.expression);
            _this._vars.notifyOnChange(info.tokens, onChangedVar);
            return _this._exprChangeListeners.push(onChangedVar);
          });
          evaluateExpr = (function(varsInEvaluation) {
            if (_this.attributes[name].type === "number") {
              if (!((_this.attributes[name].unit != null) && _this.attributes[name].unit.length > 0)) {
                _this.attributes[name].unit = _this._vars.inferUnitOfExpression(info.tokens);
              }
            }
            switch (info.datatype) {
              case "numeric":
                return _this._vars.evaluateNumericExpression(info.tokens, varsInEvaluation);
              case "string":
                return _this._vars.evaluateStringExpression(info.tokens, varsInEvaluation);
              default:
                return assert(false);
            }
          });
          onChangedVar = (function(changedVar) {
            return evaluateExpr().then(function(val) {
              return _this.emit(name, val);
            });
          });
          getValue = (function(varsInEvaluation) {
            return _this._vars.waitForInit().then(function() {
              if (info == null) {
                parseExprAndAddListener();
              }
              return evaluateExpr(varsInEvaluation);
            }).then(function(val) {
              if (val !== _this._attributesMeta[name].value) {
                _this.emit(name, val);
              }
              return val;
            });
          });
          return _this._createGetter(name, getValue);
        };
      })(this);
      for (i = 0, len = ref.length; i < len; i++) {
        variable = ref[i];
        fn1(variable);
      }
      VariablesDevice.__super__.constructor.call(this);
    }

    VariablesDevice.prototype.destroy = function() {
      var cl, i, len, ref;
      ref = this._exprChangeListeners;
      for (i = 0, len = ref.length; i < len; i++) {
        cl = ref[i];
        this._vars.cancelNotifyOnChange(cl);
      }
      return VariablesDevice.__super__.destroy.call(this);
    };

    return VariablesDevice;

  })(Device);
  VariableInputDevice = (function(superClass) {
    extend(VariableInputDevice, superClass);

    VariableInputDevice.prototype.actions = {
      changeInputTo: {
        params: {
          value: {
            type: t.string
          }
        },
        description: "Sets the variable to the value"
      }
    };

    function VariableInputDevice(config1, lastState, framework) {
      this.config = config1;
      this.framework = framework;
      VariableInputDevice.__super__.constructor.call(this, this.config, lastState);
      this._variableName = (this.config.variable || '').replace(/^[\s\$]+|[\s]$/g, '');
      this.framework.variableManager.on('variableValueChanged', this.changeListener = (function(_this) {
        return function(changedVar, value) {
          if (_this._variableName === changedVar.name) {
            return _this._setInput(value);
          }
        };
      })(this));
    }

    VariableInputDevice.prototype.changeInputTo = function(value) {
      var variable;
      variable = this.framework.variableManager.getVariableByName(this._variableName);
      if (variable == null) {
        throw new Error("Could not find variable with name " + this._variableName);
      }
      this.framework.variableManager.setVariableToValue(this._variableName, value, variable.unit);
      return VariableInputDevice.__super__.changeInputTo.call(this, value);
    };

    VariableInputDevice.prototype.destroy = function() {
      this.framework.variableManager.removeListener('variableValueChanged', this.changeListener);
      return VariableInputDevice.__super__.destroy.call(this);
    };

    return VariableInputDevice;

  })(InputDevice);
  VariableTimeInputDevice = (function(superClass) {
    extend(VariableTimeInputDevice, superClass);

    VariableTimeInputDevice.prototype.template = "inputTime";

    VariableTimeInputDevice.prototype.actions = {
      changeInputTo: {
        params: {
          value: {
            type: t.string
          }
        },
        description: "Sets the variable to the value"
      }
    };

    function VariableTimeInputDevice(config1, lastState, framework) {
      this.config = config1;
      this.framework = framework;
      VariableTimeInputDevice.__super__.constructor.call(this, this.config, lastState, this.framework);
    }

    VariableTimeInputDevice.prototype.changeInputTo = function(value) {
      var hourPattern, timePattern, variable;
      variable = this.framework.variableManager.getVariableByName(this._variableName);
      if (variable == null) {
        throw new Error("Could not find variable with name " + this._variableName);
      }
      this.framework.variableManager.setVariableToValue(this._variableName, value, variable.unit);
      timePattern = /^([01]?[0-9]|2[0-3]):[0-5][0-9]/;
      hourPattern = /^[01]?[0-9]|2[0-3]/;
      if (value.match(timePattern)) {
        this._setInput(value);
      } else {
        if (value.match(hourPattern)) {
          this._setInput(value(textValue + ":00"));
        } else {
          throw new Error("Input value is not a valid time");
        }
      }
      return Promise.resolve();
    };

    VariableTimeInputDevice.prototype.destroy = function() {
      return VariableTimeInputDevice.__super__.destroy.call(this);
    };

    return VariableTimeInputDevice;

  })(VariableInputDevice);
  DummySwitch = (function(superClass) {
    extend(DummySwitch, superClass);

    function DummySwitch(config1, lastState) {
      var ref;
      this.config = config1;
      this.name = this.config.name;
      this.id = this.config.id;
      this._state = (lastState != null ? (ref = lastState.state) != null ? ref.value : void 0 : void 0) || false;
      DummySwitch.__super__.constructor.call(this);
    }

    DummySwitch.prototype.changeStateTo = function(state) {
      this._setState(state);
      return Promise.resolve();
    };

    DummySwitch.prototype.destroy = function() {
      return DummySwitch.__super__.destroy.call(this);
    };

    return DummySwitch;

  })(SwitchActuator);
  DummyDimmer = (function(superClass) {
    extend(DummyDimmer, superClass);

    function DummyDimmer(config1, lastState) {
      var ref, ref1;
      this.config = config1;
      this.name = this.config.name;
      this.id = this.config.id;
      this._dimlevel = (lastState != null ? (ref = lastState.dimlevel) != null ? ref.value : void 0 : void 0) || 0;
      this._state = (lastState != null ? (ref1 = lastState.state) != null ? ref1.value : void 0 : void 0) || false;
      DummyDimmer.__super__.constructor.call(this);
    }

    DummyDimmer.prototype.changeDimlevelTo = function(level) {
      this._setDimlevel(level);
      return Promise.resolve();
    };

    DummyDimmer.prototype.destroy = function() {
      return DummyDimmer.__super__.destroy.call(this);
    };

    return DummyDimmer;

  })(DimmerActuator);
  DummyShutter = (function(superClass) {
    extend(DummyShutter, superClass);

    function DummyShutter(config1, lastState) {
      var ref;
      this.config = config1;
      this.name = this.config.name;
      this.id = this.config.id;
      this.rollingTime = this.config.rollingTime;
      this._position = (lastState != null ? (ref = lastState.position) != null ? ref.value : void 0 : void 0) || 'stopped';
      DummyShutter.__super__.constructor.call(this);
    }

    DummyShutter.prototype.stop = function() {
      this._setPosition('stopped');
      return Promise.resolve();
    };

    DummyShutter.prototype.moveToPosition = function(position) {
      this._setPosition(position);
      return Promise.resolve();
    };

    DummyShutter.prototype.destroy = function() {
      return DummyShutter.__super__.destroy.call(this);
    };

    return DummyShutter;

  })(ShutterController);
  DummyHeatingThermostat = (function(superClass) {
    extend(DummyHeatingThermostat, superClass);

    DummyHeatingThermostat.prototype.actions = {
      changeModeTo: {
        params: {
          mode: {
            type: "string"
          }
        }
      },
      changeTemperatureTo: {
        params: {
          temperatureSetpoint: {
            type: "number"
          }
        }
      },
      changeValveTo: {
        params: {
          valve: {
            type: "number"
          }
        }
      }
    };

    function DummyHeatingThermostat(config1, lastState) {
      var ref, ref1, ref2;
      this.config = config1;
      this.id = this.config.id;
      this.name = this.config.name;
      this._temperatureSetpoint = (lastState != null ? (ref = lastState.temperatureSetpoint) != null ? ref.value : void 0 : void 0) || 20;
      this._mode = (lastState != null ? (ref1 = lastState.mode) != null ? ref1.value : void 0 : void 0) || "auto";
      this._battery = (lastState != null ? (ref2 = lastState.battery) != null ? ref2.value : void 0 : void 0) || "ok";
      this._synced = true;
      DummyHeatingThermostat.__super__.constructor.call(this);
    }

    DummyHeatingThermostat.prototype.changeModeTo = function(mode) {
      this._setMode(mode);
      return Promise.resolve();
    };

    DummyHeatingThermostat.prototype.changeValveTo = function(valve) {
      this._setValve(valve);
      return Promise.resolve();
    };

    DummyHeatingThermostat.prototype.changeTemperatureTo = function(temperatureSetpoint) {
      this._setSetpoint(temperatureSetpoint);
      return Promise.resolve();
    };

    DummyHeatingThermostat.prototype.destroy = function() {
      return DummyHeatingThermostat.__super__.destroy.call(this);
    };

    return DummyHeatingThermostat;

  })(HeatingThermostat);
  DummyPresenceSensor = (function(superClass) {
    extend(DummyPresenceSensor, superClass);

    DummyPresenceSensor.prototype.actions = {
      changePresenceTo: {
        params: {
          presence: {
            type: "boolean"
          }
        }
      }
    };

    function DummyPresenceSensor(config1, lastState) {
      var ref;
      this.config = config1;
      this._resetPresence = bind(this._resetPresence, this);
      this.name = this.config.name;
      this.id = this.config.id;
      this._presence = (lastState != null ? (ref = lastState.presence) != null ? ref.value : void 0 : void 0) || false;
      this._triggerAutoReset();
      DummyPresenceSensor.__super__.constructor.call(this);
    }

    DummyPresenceSensor.prototype.changePresenceTo = function(presence) {
      this._setPresence(presence);
      this._triggerAutoReset();
      return Promise.resolve();
    };

    DummyPresenceSensor.prototype._triggerAutoReset = function() {
      if (this.config.autoReset && this._presence) {
        clearTimeout(this._resetPresenceTimeout);
        return this._resetPresenceTimeout = setTimeout(this._resetPresence, this.config.resetTime);
      }
    };

    DummyPresenceSensor.prototype._resetPresence = function() {
      return this._setPresence(false);
    };

    DummyPresenceSensor.prototype.destroy = function() {
      clearTimeout(this._resetPresenceTimeout);
      return DummyPresenceSensor.__super__.destroy.call(this);
    };

    return DummyPresenceSensor;

  })(PresenceSensor);
  DummyContactSensor = (function(superClass) {
    extend(DummyContactSensor, superClass);

    DummyContactSensor.prototype.actions = {
      changeContactTo: {
        params: {
          contact: {
            type: "boolean"
          }
        }
      }
    };

    function DummyContactSensor(config1, lastState) {
      var ref;
      this.config = config1;
      this.name = this.config.name;
      this.id = this.config.id;
      this._contact = (lastState != null ? (ref = lastState.contact) != null ? ref.value : void 0 : void 0) || false;
      DummyContactSensor.__super__.constructor.call(this);
    }

    DummyContactSensor.prototype.changeContactTo = function(contact) {
      this._setContact(contact);
      return Promise.resolve();
    };

    DummyContactSensor.prototype.destroy = function() {
      return DummyContactSensor.__super__.destroy.call(this);
    };

    return DummyContactSensor;

  })(ContactSensor);
  DummyTemperatureSensor = (function(superClass) {
    extend(DummyTemperatureSensor, superClass);

    DummyTemperatureSensor.prototype._humidity = null;

    DummyTemperatureSensor.prototype.attributes = {
      temperature: {
        description: "The measured temperature",
        type: t.number,
        unit: '°C',
        acronym: 'T'
      },
      humidity: {
        description: "The actual degree of Humidity",
        type: t.number,
        unit: '%'
      }
    };

    DummyTemperatureSensor.prototype.actions = {
      changeTemperatureTo: {
        params: {
          temperature: {
            type: "number"
          }
        }
      },
      changeHumidityTo: {
        params: {
          humidity: {
            type: "number"
          }
        }
      }
    };

    function DummyTemperatureSensor(config1, lastState) {
      var ref, ref1;
      this.config = config1;
      this.id = this.config.id;
      this.name = this.config.name;
      this._temperature = lastState != null ? (ref = lastState.temperature) != null ? ref.value : void 0 : void 0;
      this._humidity = lastState != null ? (ref1 = lastState.humidity) != null ? ref1.value : void 0 : void 0;
      DummyTemperatureSensor.__super__.constructor.call(this);
    }

    DummyTemperatureSensor.prototype._setHumidity = function(value) {
      this._humidity = value;
      return this.emit('humidity', value);
    };

    DummyTemperatureSensor.prototype.getHumidity = function() {
      return Promise.resolve(this._humidity);
    };

    DummyTemperatureSensor.prototype.changeTemperatureTo = function(temperature) {
      this._setTemperature(temperature);
      return Promise.resolve();
    };

    DummyTemperatureSensor.prototype.changeHumidityTo = function(humidity) {
      this._setHumidity(humidity);
      return Promise.resolve();
    };

    DummyTemperatureSensor.prototype.destroy = function() {
      return DummyTemperatureSensor.__super__.destroy.call(this);
    };

    return DummyTemperatureSensor;

  })(TemperatureSensor);
  Timer = (function(superClass) {
    extend(Timer, superClass);

    Timer.prototype.attributes = {
      time: {
        description: "The elapsed time",
        type: "number",
        unit: "s",
        displaySparkline: false
      },
      running: {
        description: "Is the timer running?",
        type: "boolean"
      }
    };

    Timer.prototype.actions = {
      startTimer: {
        description: "Starts the timer"
      },
      stopTimer: {
        description: "stops the timer"
      },
      resetTimer: {
        description: "reset the timer"
      }
    };

    Timer.prototype.template = "timer";

    function Timer(config1, lastState) {
      var ref, ref1;
      this.config = config1;
      this.id = this.config.id;
      this.name = this.config.name;
      this._time = (lastState != null ? (ref = lastState.time) != null ? ref.value : void 0 : void 0) || 0;
      this._running = (lastState != null ? (ref1 = lastState.running) != null ? ref1.value : void 0 : void 0) || false;
      if (typeof _running !== "undefined" && _running !== null) {
        this._setupInterval();
      }
      Timer.__super__.constructor.call(this);
    }

    Timer.prototype.resetTimer = function() {
      if (this._time === 0) {
        return Promise.resolve();
      }
      this._time = 0;
      this.emit('time', 0);
      return Promise.resolve();
    };

    Timer.prototype.startTimer = function() {
      if (this._running) {
        return Promise.resolve();
      }
      this._running = true;
      this.emit('running', true);
      this._setupInterval();
      return Promise.resolve();
    };

    Timer.prototype.stopTimer = function() {
      if (!this._running) {
        return Promise.resolve();
      }
      this._destroyInterval();
      this._running = false;
      this.emit('running', false);
      return Promise.resolve();
    };

    Timer.prototype.getTime = function() {
      return Promise.resolve(this._time);
    };

    Timer.prototype.getRunning = function() {
      return Promise.resolve(this._running);
    };

    Timer.prototype._setupInterval = function() {
      var onTick, res;
      if (this._interval != null) {
        return;
      }
      res = this.config.resolution;
      onTick = (function(_this) {
        return function() {
          _this._time += res;
          return _this.emit('time', _this._time);
        };
      })(this);
      return this._interval = setInterval(onTick, res * 1000);
    };

    Timer.prototype._destroyInterval = function() {
      clearInterval(this._interval);
      return this._interval = null;
    };

    Timer.prototype.destroy = function() {
      this._destroyInterval();
      return Timer.__super__.destroy.call(this);
    };

    return Timer;

  })(Device);
  DeviceConfigExtension = (function() {
    function DeviceConfigExtension() {}

    DeviceConfigExtension.prototype.extendConfigShema = function(schema) {
      var def, name, ref, results;
      if (schema.extensions == null) {
        return;
      }
      ref = this.configSchema;
      results = [];
      for (name in ref) {
        def = ref[name];
        if (indexOf.call(schema.extensions, name) >= 0) {
          results.push(schema.properties[name] = _.clone(def));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    DeviceConfigExtension.prototype.applicable = function(schema) {
      var def, name, ref;
      if (schema.extensions == null) {
        return;
      }
      ref = this.configSchema;
      for (name in ref) {
        def = ref[name];
        if (indexOf.call(schema.extensions, name) >= 0) {
          return true;
        }
      }
      return false;
    };

    return DeviceConfigExtension;

  })();
  ConfirmDeviceConfigExtention = (function(superClass) {
    extend(ConfirmDeviceConfigExtention, superClass);

    function ConfirmDeviceConfigExtention() {
      return ConfirmDeviceConfigExtention.__super__.constructor.apply(this, arguments);
    }

    ConfirmDeviceConfigExtention.prototype.configSchema = {
      xConfirm: {
        description: "Triggering a device action needs a confirmation",
        type: "boolean",
        required: false
      }
    };

    ConfirmDeviceConfigExtention.prototype.apply = function(config, device) {};

    return ConfirmDeviceConfigExtention;

  })(DeviceConfigExtension);
  LinkDeviceConfigExtention = (function(superClass) {
    extend(LinkDeviceConfigExtention, superClass);

    function LinkDeviceConfigExtention() {
      return LinkDeviceConfigExtention.__super__.constructor.apply(this, arguments);
    }

    LinkDeviceConfigExtention.prototype.configSchema = {
      xLink: {
        description: "Open this link if the device label is clicked on the frontend",
        type: "string",
        required: false
      }
    };

    LinkDeviceConfigExtention.prototype.apply = function(config, device) {};

    return LinkDeviceConfigExtention;

  })(DeviceConfigExtension);
  XButtonDeviceConfigExtension = (function(superClass) {
    extend(XButtonDeviceConfigExtension, superClass);

    function XButtonDeviceConfigExtension() {
      return XButtonDeviceConfigExtension.__super__.constructor.apply(this, arguments);
    }

    XButtonDeviceConfigExtension.prototype.configSchema = {
      xButton: {
        description: "Label for xButton device extension",
        type: "string",
        required: false
      }
    };

    XButtonDeviceConfigExtension.prototype.apply = function(config, device) {};

    return XButtonDeviceConfigExtension;

  })(DeviceConfigExtension);
  PresentLabelConfigExtension = (function(superClass) {
    extend(PresentLabelConfigExtension, superClass);

    function PresentLabelConfigExtension() {
      return PresentLabelConfigExtension.__super__.constructor.apply(this, arguments);
    }

    PresentLabelConfigExtension.prototype.configSchema = {
      xPresentLabel: {
        description: "The label for the present state",
        type: "string",
        required: false
      },
      xAbsentLabel: {
        description: "The label for the absent state",
        type: "string",
        required: false
      }
    };

    PresentLabelConfigExtension.prototype.apply = function(config, device) {
      if ((config.xPresentLabel != null) || (config.xAbsentLabel != null)) {
        device.attributes = _.cloneDeep(device.attributes);
        if (config.xPresentLabel != null) {
          device.attributes.presence.labels[0] = config.xPresentLabel;
        }
        if (config.xAbsentLabel != null) {
          return device.attributes.presence.labels[1] = config.xAbsentLabel;
        }
      }
    };

    return PresentLabelConfigExtension;

  })(DeviceConfigExtension);
  SwitchLabelConfigExtension = (function(superClass) {
    extend(SwitchLabelConfigExtension, superClass);

    function SwitchLabelConfigExtension() {
      return SwitchLabelConfigExtension.__super__.constructor.apply(this, arguments);
    }

    SwitchLabelConfigExtension.prototype.configSchema = {
      xOnLabel: {
        description: "The label for the on state",
        type: "string",
        required: false
      },
      xOffLabel: {
        description: "The label for the off state",
        type: "string",
        required: false
      }
    };

    SwitchLabelConfigExtension.prototype.apply = function(config, device) {
      if ((config.xOnLabel != null) || (config.xOffLabel != null)) {
        device.attributes = _.cloneDeep(device.attributes);
        if (config.xOnLabel != null) {
          device.attributes.state.labels[0] = config.xOnLabel;
        }
        if (config.xOffLabel != null) {
          return device.attributes.state.labels[1] = config.xOffLabel;
        }
      }
    };

    return SwitchLabelConfigExtension;

  })(DeviceConfigExtension);
  ContactLabelConfigExtension = (function(superClass) {
    extend(ContactLabelConfigExtension, superClass);

    function ContactLabelConfigExtension() {
      return ContactLabelConfigExtension.__super__.constructor.apply(this, arguments);
    }

    ContactLabelConfigExtension.prototype.configSchema = {
      xClosedLabel: {
        description: "The label for the closed state",
        type: "string",
        required: false
      },
      xOpenedLabel: {
        description: "The label for the opened state",
        type: "string",
        required: false
      }
    };

    ContactLabelConfigExtension.prototype.apply = function(config, device) {
      if ((config.xOpenedLabel != null) || (config.xClosedLabel != null)) {
        device.attributes = _.cloneDeep(device.attributes);
        if (config.xClosedLabel != null) {
          device.attributes.contact.labels[0] = config.xClosedLabel;
        }
        if (config.xOpenedLabel != null) {
          return device.attributes.contact.labels[1] = config.xOpenedLabel;
        }
      }
    };

    return ContactLabelConfigExtension;

  })(DeviceConfigExtension);
  AttributeOptionsConfigExtension = (function(superClass) {
    extend(AttributeOptionsConfigExtension, superClass);

    function AttributeOptionsConfigExtension() {
      return AttributeOptionsConfigExtension.__super__.constructor.apply(this, arguments);
    }

    AttributeOptionsConfigExtension.prototype.configSchema = {
      xAttributeOptions: {
        description: "Extra attribute options for one or more attributes",
        type: "array",
        required: false,
        items: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              description: "Name for the corresponding attribute.",
              type: "string"
            },
            displaySparkline: {
              description: "Show a sparkline behind the numeric attribute",
              type: "boolean",
              required: false
            },
            hidden: {
              description: "Hide the attribute in the gui",
              type: "boolean",
              required: false
            }
          }
        }
      }
    };

    AttributeOptionsConfigExtension.prototype.apply = function(config, device) {
      var attr, attrOpts, i, len, name, ref, results;
      if (config.xAttributeOptions != null) {
        device.attributes = _.cloneDeep(device.attributes);
        ref = config.xAttributeOptions;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          attrOpts = ref[i];
          name = attrOpts.name;
          attr = device.attributes[name];
          if (attr == null) {
            env.logger.warn("Can't apply xAttributeOptions for \"" + name + "\". Device " + device.name + " has no attribute with this name");
            continue;
          }
          if (attrOpts.displaySparkline != null) {
            attr.displaySparkline = attrOpts.displaySparkline;
          }
          if (attrOpts.hidden != null) {
            results.push(attr.hidden = attrOpts.hidden);
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };

    return AttributeOptionsConfigExtension;

  })(DeviceConfigExtension);
  DeviceManager = (function(superClass) {
    extend(DeviceManager, superClass);

    DeviceManager.prototype.devices = {};

    DeviceManager.prototype.deviceClasses = {};

    DeviceManager.prototype.deviceConfigExtensions = [];

    function DeviceManager(framework, devicesConfig) {
      this.framework = framework;
      this.devicesConfig = devicesConfig;
      this.callDeviceActionSocket = bind(this.callDeviceActionSocket, this);
      this.callDeviceActionReq = bind(this.callDeviceActionReq, this);
      this.deviceConfigExtensions.push(new ConfirmDeviceConfigExtention());
      this.deviceConfigExtensions.push(new LinkDeviceConfigExtention());
      this.deviceConfigExtensions.push(new XButtonDeviceConfigExtension());
      this.deviceConfigExtensions.push(new PresentLabelConfigExtension());
      this.deviceConfigExtensions.push(new SwitchLabelConfigExtension());
      this.deviceConfigExtensions.push(new ContactLabelConfigExtension());
      this.deviceConfigExtensions.push(new AttributeOptionsConfigExtension());
    }

    DeviceManager.prototype.registerDeviceClass = function(className, arg1) {
      var configDef, createCallback, extension, i, len, pluginName, prepareConfig, ref;
      configDef = arg1.configDef, createCallback = arg1.createCallback, prepareConfig = arg1.prepareConfig;
      assert(typeof className === "string", "className must be a string");
      assert(typeof configDef === "object", "configDef must be an object");
      assert(typeof createCallback === "function", "createCallback must be a function");
      assert(prepareConfig != null ? typeof prepareConfig === "function" : true);
      assert(typeof configDef.properties === "object", "configDef must have a property \"properties\"");
      configDef.properties.id = {
        description: "The ID for the device",
        type: "string"
      };
      configDef.properties.name = {
        description: "The name for the device",
        type: "string"
      };
      configDef.properties["class"] = {
        description: "The class to use for the device",
        type: "string"
      };
      pluginName = this.framework.pluginManager.getCallingPlugin();
      ref = this.deviceConfigExtensions;
      for (i = 0, len = ref.length; i < len; i++) {
        extension = ref[i];
        extension.extendConfigShema(configDef);
      }
      this.framework._normalizeScheme(configDef);
      return this.deviceClasses[className] = {
        prepareConfig: prepareConfig,
        configDef: configDef,
        createCallback: createCallback,
        pluginName: pluginName
      };
    };

    DeviceManager.prototype.updateDeviceOrder = function(deviceOrder) {
      assert((deviceOrder != null) && Array.isArray(deviceOrder));
      this.framework.config.devices = this.devicesConfig = _.sortBy(this.devicesConfig, (function(_this) {
        return function(device) {
          var index;
          index = deviceOrder.indexOf(device.id);
          if (index === -1) {
            return 99999;
          } else {
            return index;
          }
        };
      })(this));
      this.framework.saveConfig();
      this.framework._emitDeviceOrderChanged(deviceOrder);
      return deviceOrder;
    };

    DeviceManager.prototype.registerDevice = function(device, isNew) {
      var attr, attrName, classInfo, deviceLogger, fn1, i, len, pluginName, ref, ref1, reservedWord;
      if (isNew == null) {
        isNew = true;
      }
      assert(device != null);
      assert(device instanceof env.devices.Device);
      assert(device._constructorCalled);
      if (device.logger == null) {
        classInfo = this.deviceClasses[device.config["class"]];
        if (classInfo != null) {
          pluginName = classInfo.pluginName;
        } else {
          pluginName = this.framework.pluginManager.getCallingPlugin();
        }
        deviceLogger = env.logger.base.createSublogger([pluginName, device.config["class"]]);
        device.logger = deviceLogger;
      }
      if (isNew && (this.devices[device.id] != null)) {
        throw new Error("Duplicate device id \"" + device.id + "\"");
      }
      if (!device.id.match(/^[a-z0-9\-_]+$/i)) {
        env.logger.warn("The id of " + device.id + " contains a non alphanumeric letter or symbol.\nThis could lead to errors.");
      }
      ref = [" and ", " or "];
      for (i = 0, len = ref.length; i < len; i++) {
        reservedWord = ref[i];
        if (device.name.indexOf(reservedWord) !== -1) {
          env.logger.warn("Name of device \"" + device.id + "\" contains an \"" + reservedWord + "\".\nThis could lead to errors in rules.");
        }
      }
      if (!(device instanceof ErrorDevice)) {
        if (isNew) {
          env.logger.info("New device \"" + device.name + "\"...");
        } else {
          env.logger.info("Recreating \"" + device.name + "\"...");
        }
      }
      this.devices[device.id] = device;
      ref1 = device.attributes;
      fn1 = (function(_this) {
        return function(attrName, attr) {
          var onChange;
          return device.on(attrName, onChange = function(value) {
            return _this.framework._emitDeviceAttributeEvent(device, attrName, attr, new Date(), value);
          });
        };
      })(this);
      for (attrName in ref1) {
        attr = ref1[attrName];
        fn1(attrName, attr);
      }
      this._checkDestroyFunction(device);
      device.afterRegister();
      if (isNew) {
        this.framework._emitDeviceAdded(device);
      }
      return device;
    };

    DeviceManager.prototype._loadDevice = function(deviceConfig, lastDeviceState, oldDevice) {
      var classInfo, device, deviceLogger, extension, i, isNew, len, meta, name, ref, valueAndTime, warnings;
      if (oldDevice == null) {
        oldDevice = null;
      }
      isNew = oldDevice == null;
      classInfo = this.deviceClasses[deviceConfig["class"]];
      if (classInfo == null) {
        throw new Error("Unknown device class \"" + deviceConfig["class"] + "\"");
      }
      warnings = [];
      if (classInfo.prepareConfig != null) {
        classInfo.prepareConfig(deviceConfig);
      }
      this.framework._normalizeScheme(classInfo.configDef);
      this.framework._validateConfig(deviceConfig, classInfo.configDef, "config of device \"" + deviceConfig.id + "\"");
      deviceConfig = declapi.enhanceJsonSchemaWithDefaults(classInfo.configDef, deviceConfig);
      deviceLogger = env.logger.base.createSublogger([classInfo.pluginName, deviceConfig["class"]]);
      if ((oldDevice != null) && !oldDevice._destroyed) {
        oldDevice.destroy();
        assert(oldDevice._destroyed, "The device subclass " + oldDevice.config["class"] + " did not call super() in destroy()");
      }
      device = classInfo.createCallback(deviceConfig, lastDeviceState, deviceLogger);
      device.logger = deviceLogger;
      assert(deviceConfig === device.config, "You must assign the config to your device in the the constructor function of your device:\n\"@config = config\"");
      for (name in lastDeviceState) {
        valueAndTime = lastDeviceState[name];
        if (device.attributes[name] != null) {
          meta = device._attributesMeta[name];
          if (meta == null) {
            continue;
          }
          meta.history = [
            {
              t: valueAndTime.time,
              v: valueAndTime.value
            }
          ];
        }
      }
      ref = this.deviceConfigExtensions;
      for (i = 0, len = ref.length; i < len; i++) {
        extension = ref[i];
        if (extension.applicable(classInfo.configDef)) {
          extension.apply(device.config, device);
        }
      }
      return this.registerDevice(device, isNew);
    };

    DeviceManager.prototype._loadErrorDevice = function(deviceConfig, error) {
      return this.registerDevice(new ErrorDevice(deviceConfig, error));
    };

    DeviceManager.prototype.loadDevices = function() {
      return Promise.each(this.devicesConfig, (function(_this) {
        return function(deviceConfig) {
          return _this.framework.database.getLastDeviceState(deviceConfig.id).then(function(lastDeviceState) {
            var classInfo, e;
            classInfo = _this.deviceClasses[deviceConfig["class"]];
            if (classInfo != null) {
              try {
                return _this._loadDevice(deviceConfig, lastDeviceState);
              } catch (error1) {
                e = error1;
                env.logger.error("Error loading device \"" + deviceConfig.id + "\": " + e.message);
                env.logger.debug(e.stack);
                return _this._loadErrorDevice(deviceConfig, e.message);
              }
            } else {
              env.logger.warn("No plugin found for device \"" + deviceConfig.id + "\" of class \"" + deviceConfig["class"] + "\"!");
              return _this._loadErrorDevice(deviceConfig, "Plugin not loaded");
            }
          });
        };
      })(this));
    };

    DeviceManager.prototype.getDeviceById = function(id) {
      return this.devices[id];
    };

    DeviceManager.prototype.getDevices = function() {
      var device, id, ref, results;
      ref = this.devices;
      results = [];
      for (id in ref) {
        device = ref[id];
        results.push(device);
      }
      return results;
    };

    DeviceManager.prototype.getDeviceClasses = function() {
      var className, results;
      results = [];
      for (className in this.deviceClasses) {
        results.push(className);
      }
      return results;
    };

    DeviceManager.prototype.getDeviceConfigSchema = function(className) {
      var ref;
      return (ref = this.deviceClasses[className]) != null ? ref.configDef : void 0;
    };

    DeviceManager.prototype.addDeviceByConfig = function(deviceConfig) {
      var device;
      assert(deviceConfig.id != null);
      assert(deviceConfig["class"] != null);
      if (this.isDeviceInConfig(deviceConfig.id)) {
        throw new Error("A device with the ID \"" + deviceConfig.id + "\" is already in the config.");
      }
      device = this._loadDevice(deviceConfig, {});
      this.addDeviceToConfig(deviceConfig);
      return device;
    };

    DeviceManager.prototype._checkDestroyFunction = function(device) {
      var deviceClass;
      if (device.destroy === Device.prototype.destroy) {
        deviceClass = device.config["class"];
        if (this._alreadyWarnedFor == null) {
          this._alreadyWarnedFor = {};
        }
        if (this._alreadyWarnedFor[deviceClass] != null) {
          return;
        }
        this._alreadyWarnedFor[deviceClass] = true;
        return env.logger.warn("The device type " + deviceClass + " does not implement a destroy function");
      }
    };

    DeviceManager.prototype.recreateDevice = function(oldDevice, newDeviceConfig) {
      return this.framework.database.getLastDeviceState(oldDevice.id).then((function(_this) {
        return function(lastDeviceState) {
          var err, loadDeviceError, logger, newDevice;
          loadDeviceError = null;
          try {
            newDevice = _this._loadDevice(newDeviceConfig, lastDeviceState, oldDevice);
          } catch (error1) {
            err = error1;
            loadDeviceError = err;
            if (oldDevice._destroyed) {
              try {
                newDevice = _this._loadDevice(oldDevice.config, lastDeviceState, oldDevice);
              } catch (error1) {
                err = error1;
                logger = oldDevice.logger || env.logger;
                logger.error("Error restoring changed device " + oldDevice.id + ": " + err.message);
                logger.debug(err.stack);
                throw loadDeviceError;
              }
            } else {
              throw loadDeviceError;
            }
          }
          _this.framework._emitDeviceChanged(newDevice);
          oldDevice.emit('changed', newDevice);
          _this.emit('deviceChanged', newDevice);
          if (loadDeviceError != null) {
            throw loadDeviceError;
          }
          return newDevice;
        };
      })(this));
    };

    DeviceManager.prototype.discoverDevices = function(time) {
      if (time == null) {
        time = 20000;
      }
      env.logger.info("Starting device discovery for " + time + "ms.");
      return this.emit('discover', {
        time: time
      });
    };

    DeviceManager.prototype.discoverMessage = function(pluginName, message) {
      env.logger.info(pluginName + ": " + message);
      return this.emit('discoverMessage', {
        pluginName: pluginName,
        message: message
      });
    };

    DeviceManager.prototype.discoveredDevice = function(pluginName, deviceName, config) {
      env.logger.info("Device discovered: " + pluginName + ": " + deviceName);
      return this.emit('deviceDiscovered', {
        pluginName: pluginName,
        deviceName: deviceName,
        config: config
      });
    };

    DeviceManager.prototype.updateDeviceByConfig = function(deviceConfig) {
      var device;
      if (deviceConfig.id == null) {
        throw new Error("No id given");
      }
      device = this.getDeviceById(deviceConfig.id);
      if (device == null) {
        throw new Error('device not found');
      }
      return this.recreateDevice(device, deviceConfig);
    };

    DeviceManager.prototype.removeDevice = function(deviceId) {
      var device;
      device = this.getDeviceById(deviceId);
      if (device == null) {
        return;
      }
      delete this.devices[deviceId];
      this.emit('deviceRemoved', device);
      device.emit('remove');
      device.destroy();
      assert(device._destroyed, "The device subclass " + device.config["class"] + " did not call super() in destroy()");
      device.emit('destroyed');
      return device;
    };

    DeviceManager.prototype.addDeviceToConfig = function(deviceConfig) {
      var present;
      assert(deviceConfig.id != null);
      assert(deviceConfig["class"] != null);
      present = this.isDeviceInConfig(deviceConfig.id);
      if (present) {
        throw new Error("An device with the ID " + deviceConfig.id + " is already in the config");
      }
      this.devicesConfig.push(deviceConfig);
      return this.framework.saveConfig();
    };

    DeviceManager.prototype.callDeviceActionReq = function(params, req) {
      var action, actionName, device, deviceId;
      deviceId = req.params.deviceId;
      actionName = req.params.actionName;
      device = this.getDeviceById(deviceId);
      if (device == null) {
        throw new Error('device not found');
      }
      if (!device.hasAction(actionName)) {
        throw new Error('device hasn\'t that action');
      }
      action = device.actions[actionName];
      return declapi.callActionFromReq(actionName, action, device, req);
    };

    DeviceManager.prototype.callDeviceActionSocket = function(params, call) {
      var action, actionName, device, deviceId;
      deviceId = call.params.deviceId;
      actionName = call.params.actionName;
      device = this.getDeviceById(deviceId);
      if (device == null) {
        throw new Error('device not found');
      }
      if (!device.hasAction(actionName)) {
        throw new Error('device hasn\'t that action');
      }
      action = device.actions[actionName];
      call = _.clone(call);
      call.action = actionName;
      return declapi.callActionFromSocket(device, action, call);
    };

    DeviceManager.prototype.isDeviceInConfig = function(id) {
      var d, i, len, ref;
      assert(id != null);
      ref = this.devicesConfig;
      for (i = 0, len = ref.length; i < len; i++) {
        d = ref[i];
        if (d.id === id) {
          return true;
        }
      }
      return false;
    };

    DeviceManager.prototype.initDevices = function() {
      var defaultDevices, deviceClass, deviceConfigDef, i, len, results;
      deviceConfigDef = require("../device-config-schema");
      defaultDevices = [env.devices.ButtonsDevice, env.devices.InputDevice, env.devices.VariablesDevice, env.devices.VariableInputDevice, env.devices.VariableTimeInputDevice, env.devices.DummySwitch, env.devices.DummyDimmer, env.devices.DummyShutter, env.devices.DummyHeatingThermostat, env.devices.DummyContactSensor, env.devices.DummyPresenceSensor, env.devices.DummyTemperatureSensor, env.devices.Timer];
      results = [];
      for (i = 0, len = defaultDevices.length; i < len; i++) {
        deviceClass = defaultDevices[i];
        results.push((function(_this) {
          return function(deviceClass) {
            return _this.registerDeviceClass(deviceClass.name, {
              configDef: deviceConfigDef[deviceClass.name],
              createCallback: function(config, lastState) {
                return new deviceClass(config, lastState, _this.framework);
              }
            });
          };
        })(this)(deviceClass));
      }
      return results;
    };

    return DeviceManager;

  })(events.EventEmitter);
  return exports = {
    DeviceManager: DeviceManager,
    Device: Device,
    ErrorDevice: ErrorDevice,
    Actuator: Actuator,
    SwitchActuator: SwitchActuator,
    PowerSwitch: PowerSwitch,
    DimmerActuator: DimmerActuator,
    ShutterController: ShutterController,
    Sensor: Sensor,
    TemperatureSensor: TemperatureSensor,
    PresenceSensor: PresenceSensor,
    ContactSensor: ContactSensor,
    HeatingThermostat: HeatingThermostat,
    ButtonsDevice: ButtonsDevice,
    InputDevice: InputDevice,
    VariablesDevice: VariablesDevice,
    VariableInputDevice: VariableInputDevice,
    VariableTimeInputDevice: VariableTimeInputDevice,
    AVPlayer: AVPlayer,
    DummySwitch: DummySwitch,
    DummyDimmer: DummyDimmer,
    DummyShutter: DummyShutter,
    DummyHeatingThermostat: DummyHeatingThermostat,
    DummyContactSensor: DummyContactSensor,
    DummyPresenceSensor: DummyPresenceSensor,
    DummyTemperatureSensor: DummyTemperatureSensor,
    Timer: Timer,
    DeviceConfigExtension: DeviceConfigExtension
  };
};
