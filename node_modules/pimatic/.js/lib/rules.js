
/*
Rule System
===========

This file handles the parsing and executing of rules. 

What's a rule
------------
A rule is a string that has the format: "when _this_ then _that_". The _this_ part will be called 
the condition of the rule and the _that_ the actions of the rule.

__Examples:__

  * when its 10pm then turn the tv off
  * when its friday and its 8am then turn the light on
  * when [music is playing or the light is on] and somebody is present then turn the speaker on
  * when temperature of living room is below 15Â°C for 5 minutes then log "its getting cold"

__The condition and predicates__

The condition of a rule consists of one or more predicates. The predicates can be combined with
"and", "or" and can be grouped by parentheses ('[' and ']'). A predicate is either true or false at 
a given time. There are special predicates, called event-predicates, that represent events. 
These predicate are just true in the moment a special event happen.

Each predicate is handled by a Predicate Provider. Take a look at the 
[predicates file](predicates.html) for more details.

__for-suffix__

A predicate can have a "for" as a suffix like in "music is playing for 5 seconds" or 
"tv is on for 2 hours". If the predicate has a for-suffix then the rule action is only triggered,
when the predicate stays true the given time. Predicates that represent one time events like "10pm"
can't have a for-suffix because the condition can never hold.

__The actions__

The actions of a rule can consists of one or more actions. Each action describes a command that 
should be executed when the condition of the rule is true. Take a look at the 
[actions.coffee](actions.html) for more details.
 */
var M, Promise, S, _, assert, milliseconds, rulesAst, util,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

assert = require('cassert');

util = require('util');

Promise = require('bluebird');

_ = require('lodash');

S = require('string');

M = require('./matcher');

require("date-format-lite");

milliseconds = require('./milliseconds');

rulesAst = require('./rules-ast-builder');

module.exports = function(env) {
  var Rule, RuleManager, exports;
  Rule = (function() {
    Rule.prototype.id = null;

    Rule.prototype.name = null;

    Rule.prototype.string = null;

    Rule.prototype.active = null;

    Rule.prototype.valid = null;

    Rule.prototype.logging = null;

    Rule.prototype.conditionToken = null;

    Rule.prototype.actionsToken = null;

    Rule.prototype.predicates = null;

    Rule.prototype.tokens = null;

    Rule.prototype.actions = null;

    Rule.prototype.error = null;

    Rule.prototype.lastExecuteTime = null;

    Rule.prototype.conditionExprTree = null;

    function Rule(id1, name1, string) {
      this.id = id1;
      this.name = name1;
      this.string = string;
      assert(typeof this.id === "string");
      assert(typeof this.name === "string");
      assert(typeof this.string === "string");
    }

    Rule.prototype.update = function(fromRule) {
      assert(this.id === fromRule.id);
      this.name = fromRule.name;
      this.string = fromRule.string;
      this.active = fromRule.active;
      this.valid = fromRule.valid;
      this.logging = fromRule.logging;
      this.conditionToken = fromRule.conditionToken;
      this.actionsToken = fromRule.actionsToken;
      this.predicates = fromRule.predicates;
      this.tokens = fromRule.tokens;
      this.actions = fromRule.actions;
      this.error = fromRule.error;
      this.lastExecuteTime = fromRule.lastExecuteTime;
      return this.conditionExprTree = fromRule.conditionExprTree;
    };

    Rule.prototype.toJson = function() {
      return {
        id: this.id,
        name: this.name,
        string: this.string,
        active: this.active,
        valid: this.valid,
        logging: this.logging,
        conditionToken: this.conditionToken,
        actionsToken: this.actionsToken,
        error: this.error
      };
    };

    return Rule;

  })();

  /*
  The Rule Manager
  ----------------
  The Rule Manager holds a collection of rules. Rules can be added to this collection. When a rule
  is added, the rule is parsed by the Rule Manager and for each predicate a Predicate Provider will
  be searched. Predicate Provider that should be considered can be added to the Rule Manager.
  
  If all predicates of the added rule can be handled by a Predicate Provider, for each action of a
  rule's action an Action Handler is searched. Action Handler can be added to the
  Rule Manager, too.
   */
  RuleManager = (function(superClass) {
    extend(RuleManager, superClass);

    RuleManager.prototype.rules = {};

    RuleManager.prototype.actionProviders = [];

    RuleManager.prototype.predicateProviders = [];

    function RuleManager(framework) {
      this.framework = framework;
      this.executeAction = bind(this.executeAction, this);
      this._scheduleAction = bind(this._scheduleAction, this);
      this._executeRestoreAction = bind(this._executeRestoreAction, this);
      this._executeAction = bind(this._executeAction, this);
      this._evaluateTimeExpr = bind(this._evaluateTimeExpr, this);
      this.whenPredicateIsTrue = bind(this.whenPredicateIsTrue, this);
      this._parseAction = bind(this._parseAction, this);
      this._parsePredicate = bind(this._parsePredicate, this);
    }

    RuleManager.prototype.addActionProvider = function(ah) {
      return this.actionProviders.push(ah);
    };

    RuleManager.prototype.addPredicateProvider = function(pv) {
      return this.predicateProviders.push(pv);
    };

    RuleManager.prototype._parseRuleString = function(id, name, ruleString, context) {
      var rule;
      assert((id != null) && typeof id === "string" && id.length !== 0);
      assert((name != null) && typeof name === "string");
      assert((ruleString != null) && typeof ruleString === "string");
      rule = new Rule(id, name, ruleString);
      return Promise["try"]((function(_this) {
        return function() {

          /*
          First take the string apart, so that
           
              parts = ["", "its 10pm and light is on", "turn the light off"].
           */
          var parts, result;
          parts = ruleString.split(/^when\s|\sthen\s/);
          switch (false) {
            case !(parts.length < 3):
              throw new Error('The rule must start with "when" and contain a "then" part!');
              break;
            case !(parts.length > 3):
              throw new Error('The rule must exactly contain one "when" and one "then" part!');
          }

          /*
          Then extract the condition and actions from the rule 
           
              rule.conditionToken = "its 10pm and light is on"
              rule.actions = "turn the light off"
           */
          rule.conditionToken = parts[1].trim();
          rule.actionsToken = parts[2].trim();
          if (rule.conditionToken.length === 0) {
            throw new Error("Condition part of rule " + id + " is empty.");
          }
          if (rule.actionsToken.length === 0) {
            throw new Error("Actions part of rule " + id + " is empty.");
          }
          result = _this._parseRuleCondition(id, rule.conditionToken, context);
          rule.predicates = result.predicates;
          rule.tokens = result.tokens;
          if (!context.hasErrors()) {
            result = _this._parseRuleActions(id, rule.actionsToken, context);
            rule.actions = result.actions;
            rule.actionToken = result.tokens;
            rule.conditionExprTree = (new rulesAst.BoolExpressionTreeBuilder()).build(rule.tokens, rule.predicates);
          }
          return rule;
        };
      })(this));
    };

    RuleManager.prototype._parseRuleCondition = function(id, conditionString, context) {
      var i, justCondition, lastToken, m, nextInput, onMatch, openedParentheseCount, possibleTokens, predId, predicate, predicates, ref, success, token, tokens;
      assert(typeof id === "string" && id.length !== 0);
      assert(typeof conditionString === "string");
      assert(context != null);

      /*
      Split the condition in a token stream.
      For example: 
        
          "12:30 and temperature > 10"
       
      becomes 
       
          ['12:30', 'and', 'temperature > 30 C']
       
      Then we replace all predicates with tokens of the following form
       
          tokens = ['predicate', '(', 0, ')', 'and', 'predicate', '(', 1, ')']
       
      and remember the predicates:
       
          predicates = [ {token: '12:30'}, {token: 'temperature > 10'}]
       */
      predicates = [];
      tokens = [];
      nextInput = conditionString;
      success = true;
      openedParentheseCount = 0;
      justCondition = false;
      while ((!context.hasErrors()) && nextInput.length !== 0) {
        M(nextInput, context).matchOpenParenthese('[', (function(_this) {
          return function(next, ptokens) {
            tokens = tokens.concat(ptokens);
            openedParentheseCount += ptokens.length;
            return nextInput = next.getRemainingInput();
          };
        })(this));
        i = predicates.length;
        predId = "prd-" + id + "-" + i;
        ref = this._parsePredicate(predId, nextInput, context, null, justCondition), predicate = ref.predicate, token = ref.token, nextInput = ref.nextInput;
        if (!context.hasErrors()) {
          predicates.push(predicate);
          tokens = tokens.concat(["predicate", "(", i, ")"]);
          M(nextInput, context).matchCloseParenthese(']', openedParentheseCount, (function(_this) {
            return function(next, ptokens) {
              tokens = tokens.concat(ptokens);
              openedParentheseCount -= ptokens.length;
              return nextInput = next.getRemainingInput();
            };
          })(this));
          possibleTokens = [' and if ', ' and ', ' or when ', ' or '];
          onMatch = (function(_this) {
            return function(m, s) {
              token = s.trim();
              if (token === 'and if') {
                justCondition = true;
              } else if (token === 'or when') {
                justCondition = false;
              }
              return tokens.push(token);
            };
          })(this);
          m = M(nextInput, context).match(possibleTokens, onMatch);
          if (nextInput.length !== 0) {
            if (m.hadNoMatch()) {
              context.addError("Expected one of: \"and\", \"or\", \"]\".");
            } else {
              token = m.getFullMatch();
              assert(S(nextInput.toLowerCase()).startsWith(token.toLowerCase()));
              nextInput = nextInput.substring(token.length);
            }
          }
        }
      }
      if (tokens.length > 0) {
        lastToken = tokens[tokens.length - 1];
        if (lastToken === "and" || lastToken === "or" || lastToken === "and if" || lastToken === "or when") {
          context.addError("Expected a new predicate after last \"" + lastToken + "\".");
        }
      }
      if (openedParentheseCount > 0) {
        context.addError("Expected closing parenthese (\"]\") at end.");
      }
      return {
        predicates: predicates,
        tokens: tokens
      };
    };

    RuleManager.prototype._parsePredicate = function(predId, nextInput, context, predicateProviderClass, justCondition) {
      var j, len, m, match, parseResult, parseResults, predProvider, predicate, ref, timeParseResult, token;
      assert(typeof predId === "string" && predId.length !== 0);
      assert(typeof nextInput === "string");
      assert(context != null);
      predicate = {
        id: predId,
        token: null,
        handler: null,
        "for": null,
        justTrigger: false,
        justCondition: justCondition
      };
      token = '';
      m = M(nextInput, context).match(["trigger: "]);
      if (m.hadMatch()) {
        match = m.getFullMatch();
        token += match;
        nextInput = nextInput.substring(match.length);
        predicate.justTrigger = match === "trigger: ";
      }
      parseResults = [];
      ref = this.predicateProviders;
      for (j = 0, len = ref.length; j < len; j++) {
        predProvider = ref[j];
        if (predicateProviderClass != null) {
          if (predProvider.constructor.name !== predicateProviderClass) {
            continue;
          }
        }
        context.elements = {};
        parseResult = predProvider.parsePredicate(nextInput, context);
        if (parseResult != null) {
          assert((parseResult.token != null) && parseResult.token.length > 0);
          assert((parseResult.nextInput != null) && typeof parseResult.nextInput === "string");
          assert(parseResult.predicateHandler != null);
          assert(parseResult.predicateHandler instanceof env.predicates.PredicateHandler);
          parseResult.elements = context.elements[parseResult.token];
          parseResults.push(parseResult);
        }
      }
      switch (parseResults.length) {
        case 0:
          context.addError("Could not find an provider that decides next predicate of \"" + nextInput + "\".");
          break;
        case 1:
          parseResult = parseResults[0];
          token += parseResult.token;
          assert(parseResult.token != null);
          predicate.token = parseResult.token;
          nextInput = parseResult.nextInput;
          predicate.handler = parseResult.predicateHandler;
          context.elements = {};
          timeParseResult = this._parseTimePart(nextInput, " for ", context);
          if (timeParseResult != null) {
            token += timeParseResult.token;
            nextInput = timeParseResult.nextInput;
            predicate["for"] = {
              token: timeParseResult.timeToken,
              exprTokens: timeParseResult.timeExprTokens,
              unit: timeParseResult.unit
            };
          }
          if (predicate.justTrigger && (predicate["for"] != null)) {
            context.addError("\"" + token + "\" is marked as trigger, it can't be true for \"" + predicate.token + "\".");
          }
          if (predicate.handler.getType() === 'event' && (predicate["for"] != null)) {
            context.addError("\"" + token + "\" is an event it can't be true for \"" + predicate["for"].token + "\".");
          }
          if (predicate.handler.getType() === 'event' && predicate.justCondition) {
            context.addError("\"" + token + "\" is an event it can't be used with \"... and if ...\".");
          }
          break;
        default:
          context.addError("Next predicate of \"" + nextInput + "\" is ambiguous.");
      }
      return {
        predicate: predicate,
        token: token,
        nextInput: nextInput,
        elements: parseResult != null ? parseResult.elements : void 0,
        forElements: timeParseResult != null ? timeParseResult.elements : void 0
      };
    };

    RuleManager.prototype._parseTimePart = function(nextInput, prefixToken, context, options) {
      var elements, m, onTimeduration, timeExprTokens, timeToken, token, unit, varsAndFuns;
      if (options == null) {
        options = null;
      }
      timeExprTokens = null;
      unit = null;
      onTimeduration = (function(_this) {
        return function(m, tp) {
          timeExprTokens = tp.tokens;
          return unit = tp.unit;
        };
      })(this);
      varsAndFuns = this.framework.variableManager.getVariablesAndFunctions();
      m = M(nextInput, context).match(prefixToken, options).matchTimeDurationExpression(varsAndFuns, onTimeduration);
      if (!m.hadNoMatch()) {
        token = m.getFullMatch();
        assert(S(nextInput).startsWith(token));
        timeToken = S(token).chompLeft(prefixToken).s;
        nextInput = nextInput.substring(token.length);
        elements = m.elements;
        return {
          token: token,
          nextInput: nextInput,
          timeToken: timeToken,
          timeExprTokens: timeExprTokens,
          unit: unit,
          elements: elements
        };
      } else {
        return null;
      }
    };

    RuleManager.prototype._parseRuleActions = function(id, nextInput, context) {
      var action, actionId, actions, i, m, onMatch, openedParentheseCount, ref, success, token, tokens;
      assert(typeof id === "string" && id.length !== 0);
      assert(typeof nextInput === "string");
      assert(context != null);
      actions = [];
      tokens = [];
      success = true;
      openedParentheseCount = 0;
      while ((!context.hasErrors()) && nextInput.length !== 0) {
        i = actions.length;
        actionId = "act-" + id + "-" + i;
        ref = this._parseAction(actionId, nextInput, context), action = ref.action, token = ref.token, nextInput = ref.nextInput;
        if (!context.hasErrors()) {
          actions.push(action);
          tokens = tokens.concat(['action', '(', i, ')']);
          onMatch = (function(_this) {
            return function(m, s) {
              return tokens.push(s.trim());
            };
          })(this);
          m = M(nextInput, context).match([' and '], onMatch);
          if (nextInput.length !== 0) {
            if (m.hadNoMatch()) {
              context.addError("Expected: \"and\", got \"" + nextInput + "\"");
            } else {
              token = m.getFullMatch();
              assert(S(nextInput.toLowerCase()).startsWith(token.toLowerCase()));
              nextInput = nextInput.substring(token.length);
            }
          }
        }
      }
      return {
        actions: actions,
        tokens: tokens
      };
    };

    RuleManager.prototype._parseAction = function(actionId, nextInput, context) {
      var actProvider, action, forSuffixAllowed, j, len, parseAfter, parseResult, parseResults, ref, timeParseResult, token;
      assert(typeof nextInput === "string");
      assert(context != null);
      token = null;
      action = {
        id: actionId,
        token: null,
        handler: null,
        after: null,
        "for": null
      };
      parseAfter = (function(_this) {
        return function(type) {
          var prefixToken, timeParseResult;
          prefixToken = (type === "prefix" ? "after " : " after ");
          timeParseResult = _this._parseTimePart(nextInput, prefixToken, context);
          if (timeParseResult != null) {
            nextInput = timeParseResult.nextInput;
            if (type === 'prefix') {
              if (nextInput.length > 0 && nextInput[0] === ' ') {
                nextInput = nextInput.substring(1);
              }
            }
            return action.after = {
              token: timeParseResult.timeToken,
              exprTokens: timeParseResult.timeExprTokens,
              unit: timeParseResult.unit
            };
          }
        };
      })(this);
      parseAfter('prefix');
      parseResults = [];
      ref = this.actionProviders;
      for (j = 0, len = ref.length; j < len; j++) {
        actProvider = ref[j];
        parseResult = actProvider.parseAction(nextInput, context);
        if (parseResult != null) {
          assert((parseResult.token != null) && parseResult.token.length > 0);
          assert((parseResult.nextInput != null) && typeof parseResult.nextInput === "string");
          assert(parseResult.actionHandler != null);
          assert(parseResult.actionHandler instanceof env.actions.ActionHandler);
          parseResults.push(parseResult);
        }
      }
      switch (parseResults.length) {
        case 0:
          context.addError("Could not find an provider that provides the next action of \"" + nextInput + "\".");
          break;
        case 1:
          parseResult = parseResults[0];
          token = parseResult.token;
          assert(token != null);
          assert(S(nextInput.toLowerCase()).startsWith(parseResult.token.toLowerCase()));
          action.token = token;
          nextInput = parseResult.nextInput;
          action.handler = parseResult.actionHandler;
          if (action.after == null) {
            parseAfter('suffix');
          }
          forSuffixAllowed = action.handler.hasRestoreAction();
          timeParseResult = this._parseTimePart(nextInput, " for ", context, {
            acFilter: (function(_this) {
              return function() {
                return forSuffixAllowed;
              };
            })(this)
          });
          if (timeParseResult != null) {
            nextInput = timeParseResult.nextInput;
            action["for"] = {
              token: timeParseResult.timeToken,
              exprTokens: timeParseResult.timeExprTokens,
              unit: timeParseResult.unit
            };
          }
          if ((action["for"] != null) && forSuffixAllowed === false) {
            context.addError("Action \"" + action.token + "\" can't have a \"for\"-Suffix.");
          }
          break;
        default:
          context.addError("Next action of \"" + nextInput + "\" is ambiguous.");
      }
      return {
        action: action,
        token: token,
        nextInput: nextInput
      };
    };

    RuleManager.prototype.whenPredicateIsTrue = function(rule, predicateId, state) {
      var knownPredicates;
      assert(rule != null);
      assert((predicateId != null) && typeof predicateId === "string" && predicateId.length !== 0);
      assert(state === 'event' || state === true);
      if (!rule.active) {
        return;
      }
      knownPredicates = {};
      knownPredicates[predicateId] = true;
      this._evaluateConditionOfRule(rule, knownPredicates).then((function(_this) {
        return function(isTrue) {
          if (isTrue) {
            return _this._executeRuleActionsAndLogResult(rule);
          }
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          env.logger.error("Error on evaluation of rule condition of rule " + rule.id + ": " + error.message);
          return env.logger.debug(error);
        };
      })(this));
    };

    RuleManager.prototype._addPredicateChangeListener = function(rule) {
      var j, len, p, ref, results, setupTime;
      assert(rule != null);
      assert(rule.predicates != null);
      setupTime = (new Date()).getTime();
      ref = rule.predicates;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        results.push((function(_this) {
          return function(p) {
            var changeListener, recreateListener;
            assert(p.changeListener == null);
            p.lastChange = setupTime;
            p.handler.setup();
            if (p["for"]) {
              p.timeAchived = false;
            }
            p.handler.on('change', changeListener = function(state) {
              assert(state === 'event' || state === true || state === false);
              p.lastChange = (new Date()).getTime();
              if (!p.justCondition) {
                if (p["for"] != null) {
                  if (state === false) {
                    clearTimeout(p.forTimeout);
                    p.forTimeout = void 0;
                    p.timeAchived = false;
                  }
                  if (state === true) {
                    if (p.forTimeout != null) {
                      return;
                    }
                    return _this._evaluateTimeExpr(p["for"].exprTokens, p["for"].unit).then(function(ms) {
                      if (p.forTimeout != null) {
                        return;
                      }
                      return p.forTimeout = setTimeout((function() {
                        p.timeAchived = true;
                        return _this.whenPredicateIsTrue(rule, p.id, state);
                      }), ms);
                    })["catch"](function(err) {
                      env.logger.error("Error evaluating time expr for predicate: " + err.message);
                      return env.logger.debug(error);
                    });
                  }
                } else {
                  if (state === true || state === 'event') {
                    return _this.whenPredicateIsTrue(rule, p.id, state);
                  }
                }
              }
            });
            p.changeListener = changeListener;
            if (p["for"] != null) {
              p.handler.getValue().then(function(val) {
                if (val === true) {
                  if (p.forTimeout != null) {
                    return;
                  }
                  return _this._evaluateTimeExpr(p["for"].exprTokens, p["for"].unit).then(function(ms) {
                    if (p.forTimeout != null) {
                      return;
                    }
                    return p.forTimeout = setTimeout((function() {
                      return p.timeAchived = true;
                    }), ms);
                  });
                }
              });
            }
            p.handler.on('recreate', recreateListener = function() {
              return _this.recreateRule(rule);
            });
            return p.ready = true;
          };
        })(this)(p));
      }
      return results;
    };

    RuleManager.prototype._removePredicateChangeListener = function(rule) {
      var j, len, p, ref, results;
      assert(rule != null);
      if (rule.valid) {
        ref = rule.predicates;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          p = ref[j];
          results.push((function(_this) {
            return function(p) {
              if (p.ready) {
                assert(typeof p.changeListener === "function");
                p.handler.removeListener('change', p.changeListener);
                delete p.changeListener;
                p.handler.removeAllListeners('recreate');
                p.handler.destroy();
                clearTimeout(p.forTimeout);
                return p.ready = false;
              }
            };
          })(this)(p));
        }
        return results;
      }
    };

    RuleManager.prototype._setupActions = function(rule) {
      var action, j, len, recreateListener, ref, results;
      ref = rule.actions;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        action = ref[j];
        action.handler.setup();
        action.handler.on('recreate', recreateListener = (function(_this) {
          return function() {
            return _this.recreateRule(rule);
          };
        })(this));
        results.push(action.ready = true);
      }
      return results;
    };

    RuleManager.prototype._destroyActionsAndCancelSheduledActions = function(rule) {
      var action, j, len, ref, results;
      assert(rule != null);
      if (rule.valid) {
        ref = rule.actions;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          action = ref[j];
          results.push((function(_this) {
            return function(action) {
              if (action.ready) {
                action.handler.destroy();
                action.handler.removeAllListeners('recreate');
                action.ready = false;
                if (action.scheduled != null) {
                  return action.scheduled.cancel("canceling schedule of action " + action.token);
                }
              }
            };
          })(this)(action));
        }
        return results;
      }
    };

    RuleManager.prototype.addRuleByString = function(id, arg, force) {
      var active, context, logging, name, ruleString;
      name = arg.name, ruleString = arg.ruleString, active = arg.active, logging = arg.logging;
      if (force == null) {
        force = false;
      }
      assert((id != null) && typeof id === "string" && id.length !== 0);
      assert((name != null) && typeof name === "string");
      assert((ruleString != null) && typeof ruleString === "string");
      assert((active != null ? typeof active === "boolean" : true));
      assert((logging != null ? typeof logging === "boolean" : true));
      assert((force != null ? typeof force === "boolean" : true));
      if (active == null) {
        active = true;
      }
      if (logging == null) {
        logging = true;
      }
      if (!id.match(/^[a-z0-9\-_]+$/i)) {
        throw new Error("Rule ID must only contain " + "alpha numerical symbols, \"-\" and  \"_\"");
      }
      if (this.rules[id] != null) {
        throw new Error("There is already a rule with the ID \"" + id + "\"");
      }
      context = this._createParseContext();
      return this._parseRuleString(id, name, ruleString, context).then((function(_this) {
        return function(rule) {
          var error;
          rule.logging = logging;
          if (context.hasErrors()) {
            error = new Error(context.getErrorsAsString());
            error.rule = rule;
            error.context = context;
            throw error;
          }
          _this._addPredicateChangeListener(rule);
          _this._setupActions(rule);
          rule.active = active;
          rule.valid = true;
          _this.rules[id] = rule;
          _this.emit("ruleAdded", rule);
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          var rule;
          if (force) {
            if (error.rule != null) {
              rule = error.rule;
              rule.error = error.message;
              rule.active = false;
              rule.valid = false;
              _this.rules[id] = rule;
              _this.emit('ruleAdded', rule);
            } else {
              env.logger.error('Could not force add rule, because error has no rule attribute.');
              env.logger.debug(error.stack);
            }
          }
          throw error;
        };
      })(this));
    };

    RuleManager.prototype.removeRule = function(id) {
      var rule;
      assert((id != null) && typeof id === "string" && id.length !== 0);
      if (this.rules[id] == null) {
        throw new Error("Invalid ruleId: \"" + id + "\"");
      }
      rule = this.rules[id];
      this._removePredicateChangeListener(rule);
      this._destroyActionsAndCancelSheduledActions(rule);
      delete this.rules[id];
      this.emit("ruleRemoved", rule);
    };

    RuleManager.prototype.updateRuleByString = function(id, arg) {
      var active, context, logging, name, rule, ruleString;
      name = arg.name, ruleString = arg.ruleString, active = arg.active, logging = arg.logging;
      assert((id != null) && typeof id === "string" && id.length !== 0);
      assert((name != null ? typeof name === "string" : true));
      assert((ruleString != null ? typeof ruleString === "string" : true));
      assert((active != null ? typeof active === "boolean" : true));
      assert((logging != null ? typeof logging === "boolean" : true));
      if (this.rules[id] == null) {
        throw new Error("Invalid ruleId: \"" + id + "\"");
      }
      rule = this.rules[id];
      if (name == null) {
        name = rule.name;
      }
      if (ruleString == null) {
        ruleString = rule.string;
      }
      context = this._createParseContext();
      return this._parseRuleString(id, name, ruleString, context).then((function(_this) {
        return function(newRule) {
          var error;
          if (context.hasErrors()) {
            error = new Error(context.getErrorsAsString());
            error.rule = newRule;
            error.context = context;
            throw error;
          }
          newRule.valid = true;
          newRule.active = active != null ? active : rule.active;
          newRule.logging = logging != null ? logging : rule.logging;
          if (rule !== _this.rules[id]) {
            throw new Error("Rule " + rule.id + " was removed while updating");
          }
          _this._removePredicateChangeListener(rule);
          _this._destroyActionsAndCancelSheduledActions(rule);
          rule.update(newRule);
          _this._addPredicateChangeListener(rule);
          _this._setupActions(rule);
          return _this.emit("ruleChanged", rule);
        };
      })(this));
    };

    RuleManager.prototype.recreateRule = function(rule) {
      if (rule.recreating) {
        return;
      }
      rule.recreating = true;
      return this.updateRuleByString(rule.id, {}).then((function(_this) {
        return function() {
          return rule.recreating = false;
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          _this._removePredicateChangeListener(rule);
          _this._destroyActionsAndCancelSheduledActions(rule);
          rule.active = false;
          rule.valid = false;
          rule.recreating = false;
          env.logger.error("Error in rule " + rule.id + ": " + error.message);
          env.logger.debug(error.stack);
          return _this.emit("ruleChanged", rule);
        };
      })(this)).done();
    };

    RuleManager.prototype._evaluateConditionOfRule = function(rule, knownPredicates) {
      if (knownPredicates == null) {
        knownPredicates = {};
      }
      assert((rule != null) && rule instanceof Object);
      assert((knownPredicates != null) && knownPredicates instanceof Object);
      return rule.conditionExprTree.evaluate(knownPredicates);
    };

    RuleManager.prototype._executeRuleActionsAndLogResult = function(rule) {
      var actionResult, actionResults, currentTime, delta, j, len, logMessageForResult;
      currentTime = (new Date).getTime();
      if (rule.lastExecuteTime != null) {
        delta = currentTime - rule.lastExecuteTime;
        if (delta <= 500) {
          env.logger.debug("Suppressing rule " + rule.id + " execute because it was executed recently.");
          return Promise.resolve();
        }
      }
      rule.lastExecuteTime = currentTime;
      actionResults = this._executeRuleActions(rule, false);
      logMessageForResult = (function(_this) {
        return function(actionResult) {
          return actionResult.then(function(result) {
            var message, next, ref;
            ref = (typeof result === "string" ? [result, null] : (assert(Array.isArray(result)), assert(result.length === 2), result)), message = ref[0], next = ref[1];
            if (rule.logging) {
              env.logger.info("rule " + rule.id + ": " + message);
            }
            if (next != null) {
              assert(next.then != null);
              next = logMessageForResult(next);
            }
            return [message, next];
          })["catch"](function(error) {
            var ref;
            env.logger.error("rule " + rule.id + " error executing an action: " + ((ref = error.message) != null ? ref : error));
            if (error.stack != null) {
              return env.logger.debug(error.stack);
            }
          });
        };
      })(this);
      for (j = 0, len = actionResults.length; j < len; j++) {
        actionResult = actionResults[j];
        actionResult = logMessageForResult(actionResult);
      }
      return Promise.all(actionResults);
    };

    RuleManager.prototype._executeRuleActions = function(rule, simulate) {
      var action, actionResults, fn, j, len, ref;
      assert(rule != null);
      assert(rule.actions != null);
      assert((simulate != null) && typeof simulate === "boolean");
      actionResults = [];
      ref = rule.actions;
      fn = (function(_this) {
        return function(action) {
          var promise;
          promise = null;
          if (action.after != null) {
            if (!simulate) {
              if (action.scheduled != null) {
                action.scheduled.cancel("reschedule action " + action.token + " in " + action.after.token);
              }
              promise = _this._evaluateTimeExpr(action.after.exprTokens, action.after.unit).then(function(ms) {
                return _this._scheduleAction(action, ms);
              });
            } else {
              promise = _this._executeAction(action, simulate).then(function(message) {
                return message + " after " + action.after.token;
              });
            }
          } else {
            promise = _this._executeAction(action);
          }
          assert(promise.then != null);
          return actionResults.push(promise);
        };
      })(this);
      for (j = 0, len = ref.length; j < len; j++) {
        action = ref[j];
        fn(action);
      }
      return actionResults;
    };

    RuleManager.prototype._evaluateTimeExpr = function(exprTokens, unit) {
      return this.framework.variableManager.evaluateNumericExpression(exprTokens).then((function(_this) {
        return function(time) {
          return milliseconds.parse(time + " " + unit);
        };
      })(this));
    };

    RuleManager.prototype._executeAction = function(action, simulate) {
      return Promise["try"]((function(_this) {
        return function() {
          var promise;
          promise = action.handler.executeAction(simulate);
          if (action["for"] != null) {
            promise = promise.then(function(message) {
              var restoreActionPromise;
              restoreActionPromise = _this._evaluateTimeExpr(action["for"].exprTokens, action["for"].unit).then(function(ms) {
                return _this._scheduleAction(action, ms, true);
              });
              return [message, restoreActionPromise];
            });
          }
          return promise;
        };
      })(this));
    };

    RuleManager.prototype._executeRestoreAction = function(action, simulate) {
      return Promise["try"]((function(_this) {
        return function() {
          return action.handler.executeRestoreAction(simulate);
        };
      })(this));
    };

    RuleManager.prototype._scheduleAction = function(action, ms, isRestore) {
      if (isRestore == null) {
        isRestore = false;
      }
      assert(action != null);
      if (action.scheduled != null) {
        action.scheduled.cancel("clearing scheduled action");
      }
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var timeoutHandle;
          timeoutHandle = setTimeout((function() {
            var promise;
            promise = (!isRestore ? _this._executeAction(action, false) : _this._executeRestoreAction(action, false));
            resolve(promise);
            return delete action.scheduled;
          }), ms);
          return action.scheduled = {
            startDate: new Date(),
            cancel: function(reason) {
              clearTimeout(timeoutHandle);
              delete action.scheduled;
              return resolve(reason);
            }
          };
        };
      })(this));
    };

    RuleManager.prototype._createParseContext = function() {
      var functions, ref, variables;
      ref = this.framework.variableManager.getVariablesAndFunctions(), variables = ref.variables, functions = ref.functions;
      return M.createParseContext(variables, functions);
    };

    RuleManager.prototype.getRules = function() {
      var id, r, rules, rulesInConfig;
      rules = (function() {
        var ref, results;
        ref = this.rules;
        results = [];
        for (id in ref) {
          r = ref[id];
          results.push(r);
        }
        return results;
      }).call(this);
      rulesInConfig = _.map(this.framework.config.rules, (function(_this) {
        return function(r) {
          return r.id;
        };
      })(this));
      return _.sortBy(rules, (function(_this) {
        return function(r) {
          return rulesInConfig.indexOf(r.id);
        };
      })(this));
    };

    RuleManager.prototype.getRuleById = function(ruleId) {
      return this.rules[ruleId];
    };

    RuleManager.prototype.getRuleActionsHints = function(actionsInput) {
      var a, context, j, len, ref, result;
      context = null;
      result = null;
      context = this._createParseContext();
      result = this._parseRuleActions("id", actionsInput, context);
      context.finalize();
      ref = result.actions;
      for (j = 0, len = ref.length; j < len; j++) {
        a = ref[j];
        delete a.handler;
      }
      return {
        tokens: result.tokens,
        actions: result.actions,
        autocomplete: context.autocomplete,
        errors: context.errors,
        format: context.format,
        warnings: context.warnings
      };
    };

    RuleManager.prototype.getRuleConditionHints = function(conditionInput) {
      var context, j, len, p, ref, result, tree;
      context = null;
      result = null;
      context = this._createParseContext();
      result = this._parseRuleCondition("id", conditionInput, context);
      context.finalize();
      ref = result.predicates;
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        delete p.handler;
      }
      tree = null;
      if (context.errors.length === 0) {
        tree = (new rulesAst.BoolExpressionTreeBuilder()).build(result.tokens, result.predicates);
      }
      return {
        tokens: result.tokens,
        predicates: result.predicates,
        tree: tree,
        autocomplete: context.autocomplete,
        errors: context.errors,
        format: context.format,
        warnings: context.warnings
      };
    };

    RuleManager.prototype.getPredicatePresets = function() {
      var d, j, k, len, len1, p, presets, ref, ref1;
      presets = [];
      ref = this.predicateProviders;
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        if (p.presets != null) {
          ref1 = p.presets;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            d = ref1[k];
            d.predicateProviderClass = p.constructor.name;
            presets.push(d);
          }
        }
      }
      return presets;
    };

    RuleManager.prototype.getPredicateInfo = function(input, predicateProviderClass) {
      var context, ref, result, timeParseResult;
      context = this._createParseContext();
      result = this._parsePredicate("id", input, context, predicateProviderClass, false);
      if ((result != null ? result.predicate : void 0) != null) {
        if (!(result.predicate.justTrigger || ((ref = result.predicate.handler) != null ? ref.getType() : void 0) === "event")) {
          if (result.forElements == null) {
            timeParseResult = this._parseTimePart(" for 5 minutes", " for ", context);
            result.forElements = timeParseResult.elements;
          }
        }
        delete result.predicate.handler;
      }
      context.finalize();
      result.errors = context.errors;
      return result;
    };

    RuleManager.prototype.executeAction = function(actionString, simulate, logging) {
      var context, parseResult;
      if (simulate == null) {
        simulate = false;
      }
      if (logging == null) {
        logging = true;
      }
      context = this._createParseContext();
      parseResult = this._parseAction('custom-action', actionString, context);
      context.finalize();
      if (context.hasErrors()) {
        return Promise.reject(new Error(context.errors));
      }
      return this._executeAction(parseResult.action, simulate).then((function(_this) {
        return function(message) {
          if (logging) {
            env.logger.info("execute action: " + message);
          }
          return message;
        };
      })(this));
    };

    RuleManager.prototype.updateRuleOrder = function(ruleOrder) {
      assert((ruleOrder != null) && Array.isArray(ruleOrder));
      this.framework.config.rules = _.sortBy(this.framework.config.rules, (function(_this) {
        return function(rule) {
          var index;
          index = ruleOrder.indexOf(rule.id);
          if (index === -1) {
            return 99999;
          } else {
            return index;
          }
        };
      })(this));
      this.framework.saveConfig();
      this.framework._emitRuleOrderChanged(ruleOrder);
      return ruleOrder;
    };

    return RuleManager;

  })(require('events').EventEmitter);
  return exports = {
    RuleManager: RuleManager
  };
};
