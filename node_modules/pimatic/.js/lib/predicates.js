
/*
Predicate Provider
=================
A Predicate Provider provides a predicate for the Rule System. For predicate and rule explanations
take a look at the [rules file](rules.html). A predicate is a string that describes a state. A
predicate is either true or false at a given time. There are special predicates, 
called event-predicates, that represent events. These predicate are just true in the moment a 
special event happen.
 */
var M, Promise, S, _, __, assert, types,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

__ = require("i18n").__;

Promise = require('bluebird');

S = require('string');

assert = require('cassert');

_ = require('lodash');

M = require('./matcher');

types = require('decl-api').types;

module.exports = function(env) {

  /*
  The Predicate Provider
  ----------------
  This is the base class for all predicate provider.
   */
  var ButtonPredicateHandler, ButtonPredicateProvider, ContactPredicateHandler, ContactPredicateProvider, DeviceAttributePredicateHandler, DeviceAttributePredicateProvider, DeviceAttributeWatchdogPredicateHandler, DeviceAttributeWatchdogProvider, PredicateHandler, PredicateProvider, PresencePredicateHandler, PresencePredicateProvider, StartupPredicateHandler, StartupPredicateProvider, SwitchPredicateHandler, SwitchPredicateProvider, VariablePredicateHandler, VariablePredicateProvider, VariableUpdatedPredicateHandler, VariableUpdatedPredicateProvider, exports;
  PredicateProvider = (function() {
    function PredicateProvider() {}

    PredicateProvider.prototype.parsePredicate = function(input, context) {
      throw new Error("You must implement parsePredicate");
    };

    return PredicateProvider;

  })();
  PredicateHandler = (function(superClass) {
    extend(PredicateHandler, superClass);

    function PredicateHandler() {
      return PredicateHandler.__super__.constructor.apply(this, arguments);
    }

    PredicateHandler.prototype.getType = function() {
      throw new Error("You must implement getType");
    };

    PredicateHandler.prototype.getValue = function() {
      throw new Error("You must implement getValue");
    };

    PredicateHandler.prototype.setup = function() {
      if (this._setupCalled) {
        throw new Error("Setup already called!");
      }
      return this._setupCalled = true;
    };

    PredicateHandler.prototype.destroy = function() {
      if (!this._setupCalled) {
        throw new Error("Destroy called, but setup was not called!");
      }
      delete this._setupCalled;
      this.emit("destroy");
      return this.removeAllListeners();
    };

    PredicateHandler.prototype.dependOnDevice = function(device) {
      var recreateEmitter;
      recreateEmitter = ((function(_this) {
        return function() {
          return _this.emit("recreate");
        };
      })(this));
      device.on("changed", recreateEmitter);
      device.on("destroyed", recreateEmitter);
      return this.on('destroy', (function(_this) {
        return function() {
          device.removeListener("changed", recreateEmitter);
          return device.removeListener("destroyed", recreateEmitter);
        };
      })(this));
    };

    PredicateHandler.prototype.dependOnVariable = function(variableManager, varName) {
      var recreateEmitter;
      recreateEmitter = ((function(_this) {
        return function(variable) {
          if (variable.name !== varName) {
            return;
          }
          return _this.emit("recreate");
        };
      })(this));
      variableManager.on("variableRemoved", recreateEmitter);
      return this.on('destroy', (function(_this) {
        return function() {
          return variableManager.removeListener("variableRemoved", recreateEmitter);
        };
      })(this));
    };

    return PredicateHandler;

  })(require('events').EventEmitter);

  /*
  The Switch Predicate Provider
  ----------------
  Provides predicates for the state of switch devices like:
  
  * _device_ is on|off
  * _device_ is switched on|off
  * _device_ is turned on|off
   */
  SwitchPredicateProvider = (function(superClass) {
    extend(SwitchPredicateProvider, superClass);

    SwitchPredicateProvider.prototype.presets = [
      {
        name: "switch turned on/off",
        input: "{device} is turned on"
      }
    ];

    function SwitchPredicateProvider(framework) {
      this.framework = framework;
    }

    SwitchPredicateProvider.prototype.parsePredicate = function(input, context) {
      var device, match, state, stateAcFilter, switchDevices;
      switchDevices = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAttribute('state');
        };
      })(this)).value();
      device = null;
      state = null;
      match = null;
      stateAcFilter = (function(_this) {
        return function(v) {
          return v.trim() !== 'is switched';
        };
      })(this);
      M(input, context).matchDevice(switchDevices, (function(_this) {
        return function(next, d) {
          return next.match([' is', ' is turned', ' is switched'], {
            acFilter: stateAcFilter,
            type: 'static'
          }).match([' on', ' off'], {
            param: 'state',
            type: 'select'
          }, function(next, s) {
            if ((device != null) && device.id !== d.id) {
              if (context != null) {
                context.addError("\"" + (input.trim()) + "\" is ambiguous.");
              }
              return;
            }
            assert(d != null);
            assert(s === ' on' || s === ' off');
            device = d;
            state = s.trim() === 'on';
            return match = next.getFullMatch();
          });
        };
      })(this));
      if (match != null) {
        assert(device != null);
        assert(state != null);
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          predicateHandler: new SwitchPredicateHandler(device, state)
        };
      } else {
        return null;
      }
    };

    return SwitchPredicateProvider;

  })(PredicateProvider);
  SwitchPredicateHandler = (function(superClass) {
    extend(SwitchPredicateHandler, superClass);

    function SwitchPredicateHandler(device1, state1) {
      this.device = device1;
      this.state = state1;
      this.dependOnDevice(this.device);
    }

    SwitchPredicateHandler.prototype.setup = function() {
      this.stateListener = (function(_this) {
        return function(s) {
          return _this.emit('change', s === _this.state);
        };
      })(this);
      this.device.on('state', this.stateListener);
      return SwitchPredicateHandler.__super__.setup.call(this);
    };

    SwitchPredicateHandler.prototype.getValue = function() {
      return this.device.getUpdatedAttributeValue('state').then((function(_this) {
        return function(s) {
          return s === _this.state;
        };
      })(this));
    };

    SwitchPredicateHandler.prototype.destroy = function() {
      this.device.removeListener("state", this.stateListener);
      return SwitchPredicateHandler.__super__.destroy.call(this);
    };

    SwitchPredicateHandler.prototype.getType = function() {
      return 'state';
    };

    return SwitchPredicateHandler;

  })(PredicateHandler);

  /*
  The Presence Predicate Provider
  ----------------
  Handles predicates of presence devices like
  
  * _device_ is present
  * _device_ is not present
  * _device_ is absent
   */
  PresencePredicateProvider = (function(superClass) {
    extend(PresencePredicateProvider, superClass);

    PresencePredicateProvider.prototype.presets = [
      {
        name: "device is present/absent",
        input: "{device} is present"
      }
    ];

    function PresencePredicateProvider(framework) {
      this.framework = framework;
    }

    PresencePredicateProvider.prototype.parsePredicate = function(input, context) {
      var device, match, negated, presenceDevices, stateAcFilter;
      presenceDevices = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAttribute('presence');
        };
      })(this)).value();
      device = null;
      negated = null;
      match = null;
      stateAcFilter = (function(_this) {
        return function(v) {
          return v.trim() !== 'not present';
        };
      })(this);
      M(input, context).matchDevice(presenceDevices, (function(_this) {
        return function(next, d) {
          return next.match([' is', ' reports', ' signals'], {
            type: "static"
          }).match([' present', ' absent', ' not present'], {
            acFilter: stateAcFilter,
            type: "select",
            param: "state"
          }, function(m, s) {
            if ((device != null) && device.id !== d.id) {
              if (context != null) {
                context.addError("\"" + (input.trim()) + "\" is ambiguous.");
              }
              return;
            }
            device = d;
            negated = s.trim() !== "present";
            return match = m.getFullMatch();
          });
        };
      })(this));
      if (match != null) {
        assert(device != null);
        assert(negated != null);
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          predicateHandler: new PresencePredicateHandler(device, negated)
        };
      } else {
        return null;
      }
    };

    return PresencePredicateProvider;

  })(PredicateProvider);
  PresencePredicateHandler = (function(superClass) {
    extend(PresencePredicateHandler, superClass);

    function PresencePredicateHandler(device1, negated1) {
      this.device = device1;
      this.negated = negated1;
      this.dependOnDevice(this.device);
    }

    PresencePredicateHandler.prototype.setup = function() {
      this.presenceListener = (function(_this) {
        return function(p) {
          return _this.emit('change', (_this.negated ? !p : p));
        };
      })(this);
      this.device.on('presence', this.presenceListener);
      return PresencePredicateHandler.__super__.setup.call(this);
    };

    PresencePredicateHandler.prototype.getValue = function() {
      return this.device.getUpdatedAttributeValue('presence').then((function(_this) {
        return function(p) {
          if (_this.negated) {
            return !p;
          } else {
            return p;
          }
        };
      })(this));
    };

    PresencePredicateHandler.prototype.destroy = function() {
      this.device.removeListener("presence", this.presenceListener);
      return PresencePredicateHandler.__super__.destroy.call(this);
    };

    PresencePredicateHandler.prototype.getType = function() {
      return 'state';
    };

    return PresencePredicateHandler;

  })(PredicateHandler);

  /*
  The Contact Predicate Provider
  ----------------
  Handles predicates of contact devices like
  
  * _device_ is opened
  * _device_ is closed
   */
  ContactPredicateProvider = (function(superClass) {
    extend(ContactPredicateProvider, superClass);

    ContactPredicateProvider.prototype.presets = [
      {
        name: "device is opened/closed",
        input: "{device} is opened"
      }
    ];

    function ContactPredicateProvider(framework) {
      this.framework = framework;
    }

    ContactPredicateProvider.prototype.parsePredicate = function(input, context) {
      var contactAcFilter, contactDevices, device, match, negated;
      contactDevices = _(this.framework.deviceManager.devices).values().filter((function(_this) {
        return function(device) {
          return device.hasAttribute('contact');
        };
      })(this)).value();
      device = null;
      negated = null;
      match = null;
      contactAcFilter = (function(_this) {
        return function(v) {
          var ref;
          return (ref = v.trim()) === 'opened' || ref === 'closed';
        };
      })(this);
      M(input, context).matchDevice(contactDevices, (function(_this) {
        return function(next, d) {
          return next.match(' is', {
            type: "static"
          }).match([' open', ' close', ' opened', ' closed'], {
            acFilter: contactAcFilter,
            type: "select"
          }, function(m, s) {
            var ref;
            if ((device != null) && device.id !== d.id) {
              if (context != null) {
                context.addError("\"" + (input.trim()) + "\" is ambiguous.");
              }
              return;
            }
            device = d;
            negated = ((ref = s.trim()) === "opened" || ref === 'open');
            return match = m.getFullMatch();
          });
        };
      })(this));
      if (match != null) {
        assert(device != null);
        assert(negated != null);
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          predicateHandler: new ContactPredicateHandler(device, negated)
        };
      } else {
        return null;
      }
    };

    return ContactPredicateProvider;

  })(PredicateProvider);
  ContactPredicateHandler = (function(superClass) {
    extend(ContactPredicateHandler, superClass);

    function ContactPredicateHandler(device1, negated1) {
      this.device = device1;
      this.negated = negated1;
      this.dependOnDevice(this.device);
    }

    ContactPredicateHandler.prototype.setup = function() {
      this.contactListener = (function(_this) {
        return function(p) {
          return _this.emit('change', (_this.negated ? !p : p));
        };
      })(this);
      this.device.on('contact', this.contactListener);
      return ContactPredicateHandler.__super__.setup.call(this);
    };

    ContactPredicateHandler.prototype.getValue = function() {
      return this.device.getUpdatedAttributeValue('contact').then((function(_this) {
        return function(p) {
          if (_this.negated) {
            return !p;
          } else {
            return p;
          }
        };
      })(this));
    };

    ContactPredicateHandler.prototype.destroy = function() {
      this.device.removeListener("contact", this.contactListener);
      return ContactPredicateHandler.__super__.destroy.call(this);
    };

    ContactPredicateHandler.prototype.getType = function() {
      return 'state';
    };

    return ContactPredicateHandler;

  })(PredicateHandler);

  /*
  The Device-Attribute Predicate Provider
  ----------------
  Handles predicates for comparing device attributes like sensor values or other states:
  
  * _attribute_ of _device_ is equal to _value_
  * _attribute_ of _device_ equals _value_
  * _attribute_ of _device_ is not _value_
  * _attribute_ of _device_ is less than _value_
  * _attribute_ of _device_ is lower than _value_
  * _attribute_ of _device_ is greater than _value_
  * _attribute_ of _device_ is higher than _value_
   */
  DeviceAttributePredicateProvider = (function(superClass) {
    extend(DeviceAttributePredicateProvider, superClass);

    DeviceAttributePredicateProvider.prototype.presets = [
      {
        name: "attribute of a device",
        input: "{attribute} of {device} is equal to {value}"
      }
    ];

    function DeviceAttributePredicateProvider(framework) {
      this.framework = framework;
    }

    DeviceAttributePredicateProvider.prototype.parsePredicate = function(input, context) {
      var allAttributes, match, matches, result;
      allAttributes = _(this.framework.deviceManager.getDevices()).map((function(_this) {
        return function(device) {
          return _.keys(device.attributes);
        };
      })(this)).flatten().uniq().value();
      result = null;
      matches = [];
      M(input, context).match(allAttributes, {
        param: "attribute",
        wildcard: "{attribute}"
      }, (function(_this) {
        return function(m, attr) {
          var devices, info;
          info = {
            device: null,
            attributeName: null,
            comparator: null,
            referenceValue: null
          };
          info.attributeName = attr;
          devices = _(_this.framework.deviceManager.devices).values().filter(function(device) {
            return device.hasAttribute(attr);
          }).value();
          return m.match(' of ').matchDevice(devices, function(next, device) {
            var attribute, autocompleteFilter, end, possibleUnits, setComparator, setRefValue;
            info.device = device;
            if (!device.hasAttribute(attr)) {
              return;
            }
            attribute = device.attributes[attr];
            setComparator = function(m, c) {
              return info.comparator = c;
            };
            setRefValue = function(m, v) {
              return info.referenceValue = v;
            };
            end = function() {
              return matchCount++;
            };
            if (attribute.type === types.boolean) {
              m = next.matchComparator('boolean', setComparator).match(attribute.labels, {
                wildcard: '{value}'
              }, function(m, v) {
                if (v === attribute.labels[0]) {
                  return setRefValue(m, true);
                } else if (v === attribute.labels[1]) {
                  return setRefValue(m, false);
                } else {
                  return assert(false);
                }
              });
            } else if (attribute.type === types.number) {
              m = next.matchComparator('number', setComparator).matchNumber({
                wildcard: '{value}'
              }, function(m, v) {
                return setRefValue(m, parseFloat(v));
              });
              if ((attribute.unit != null) && attribute.unit.length > 0) {
                possibleUnits = _.uniq([" " + attribute.unit, "" + attribute.unit, "" + (attribute.unit.toLowerCase()), " " + (attribute.unit.toLowerCase()), "" + (attribute.unit.replace('°', '')), " " + (attribute.unit.replace('°', '')), "" + (attribute.unit.toLowerCase().replace('°', '')), " " + (attribute.unit.toLowerCase().replace('°', ''))]);
                autocompleteFilter = function(v) {
                  return v === (" " + attribute.unit);
                };
                m = m.match(possibleUnits, {
                  optional: true,
                  acFilter: autocompleteFilter
                });
              }
            } else if (attribute.type === types.string) {
              m = next.matchComparator('string', setComparator).or([
                (function(m) {
                  return m.matchString({
                    wildcard: '{value}'
                  }, setRefValue);
                }), (function(m) {
                  if (attribute["enum"] != null) {
                    return m.match(attribute["enum"], {
                      wildcard: '{value}'
                    }, setRefValue);
                  } else {
                    return M(null);
                  }
                })
              ]);
            }
            if (m.hadMatch()) {
              matches.push(m.getFullMatch());
              if (result != null) {
                if (result.device.id !== info.device.id || result.attributeName !== info.attributeName) {
                  if (context != null) {
                    context.addError("\"" + (input.trim()) + "\" is ambiguous.");
                  }
                }
              }
              return result = info;
            }
          });
        };
      })(this));
      if (result != null) {
        assert(result.device != null);
        assert(result.attributeName != null);
        assert(result.comparator != null);
        assert(result.referenceValue != null);
        match = _(matches).sortBy((function(_this) {
          return function(s) {
            return s.length;
          };
        })(this)).last();
        assert(typeof match === "string");
        return {
          token: match,
          nextInput: input.substring(match.length),
          predicateHandler: new DeviceAttributePredicateHandler(result.device, result.attributeName, result.comparator, result.referenceValue)
        };
      }
      return null;
    };

    return DeviceAttributePredicateProvider;

  })(PredicateProvider);
  DeviceAttributePredicateHandler = (function(superClass) {
    extend(DeviceAttributePredicateHandler, superClass);

    function DeviceAttributePredicateHandler(device1, attribute1, comparator1, referenceValue1) {
      this.device = device1;
      this.attribute = attribute1;
      this.comparator = comparator1;
      this.referenceValue = referenceValue1;
      this.dependOnDevice(this.device);
    }

    DeviceAttributePredicateHandler.prototype.setup = function() {
      var lastState;
      lastState = null;
      this.attributeListener = (function(_this) {
        return function(value) {
          var state;
          state = _this._compareValues(_this.comparator, value, _this.referenceValue);
          if (state !== lastState) {
            lastState = state;
            return _this.emit('change', state);
          }
        };
      })(this);
      this.device.on(this.attribute, this.attributeListener);
      return DeviceAttributePredicateHandler.__super__.setup.call(this);
    };

    DeviceAttributePredicateHandler.prototype.getValue = function() {
      return this.device.getUpdatedAttributeValue(this.attribute).then((function(_this) {
        return function(value) {
          return _this._compareValues(_this.comparator, value, _this.referenceValue);
        };
      })(this));
    };

    DeviceAttributePredicateHandler.prototype.destroy = function() {
      this.device.removeListener(this.attribute, this.attributeListener);
      return DeviceAttributePredicateHandler.__super__.destroy.call(this);
    };

    DeviceAttributePredicateHandler.prototype.getType = function() {
      return 'state';
    };


    /*
    Does the comparison.
     */

    DeviceAttributePredicateHandler.prototype._compareValues = function(comparator, value, referenceValue) {
      var result;
      if (typeof referenceValue === "number") {
        value = parseFloat(value);
      }
      result = (function() {
        switch (comparator) {
          case '==':
            return value === referenceValue;
          case '!=':
            return value !== referenceValue;
          case '<':
            return value < referenceValue;
          case '>':
            return value > referenceValue;
          case '<=':
            return value <= referenceValue;
          case '>=':
            return value >= referenceValue;
          default:
            throw new Error("Unknown comparator: " + comparator);
        }
      })();
      return result;
    };

    return DeviceAttributePredicateHandler;

  })(PredicateHandler);

  /*
  The Device-Attribute Watchdog Provider
  ----------------
  Handles predicates that will become true if a attribute of a device was not updated for a
  certain time.
  
  * _attribute_ of _device_ was not updated for _time_
   */
  DeviceAttributeWatchdogProvider = (function(superClass) {
    extend(DeviceAttributeWatchdogProvider, superClass);

    DeviceAttributeWatchdogProvider.prototype.presets = [
      {
        name: "attribute of a device not updated",
        input: "{attribute} of {device} was not updated for {duration} minutes"
      }
    ];

    function DeviceAttributeWatchdogProvider(framework) {
      this.framework = framework;
    }

    DeviceAttributeWatchdogProvider.prototype.parsePredicate = function(input, context) {
      var allAttributes, match, result;
      allAttributes = _(this.framework.deviceManager.getDevices()).map((function(_this) {
        return function(device) {
          return _.keys(device.attributes);
        };
      })(this)).flatten().uniq().value();
      result = null;
      match = null;
      M(input, context).match(allAttributes, {
        wildcard: "{attribute}",
        type: "select"
      }, (function(_this) {
        return function(m, attr) {
          var devices, info;
          info = {
            device: null,
            attributeName: null,
            timeMs: null
          };
          info.attributeName = attr;
          devices = _(_this.framework.deviceManager.devices).values().filter(function(device) {
            return device.hasAttribute(attr);
          }).value();
          return m.match(' of ').matchDevice(devices, function(m, device) {
            var attribute;
            info.device = device;
            if (!device.hasAttribute(attr)) {
              return;
            }
            attribute = device.attributes[attr];
            return m.match(' was not updated for ', {
              type: "static"
            }).matchTimeDuration({
              wildcard: "{duration}",
              type: "text"
            }, function(m, arg) {
              var time, timeMs, unit;
              time = arg.time, unit = arg.unit, timeMs = arg.timeMs;
              info.timeMs = timeMs;
              result = info;
              return match = m.getFullMatch();
            });
          });
        };
      })(this));
      if (result != null) {
        assert(result.device != null);
        assert(result.attributeName != null);
        assert(result.timeMs != null);
        return {
          token: match,
          nextInput: input.substring(match.length),
          predicateHandler: new DeviceAttributeWatchdogPredicateHandler(result.device, result.attributeName, result.timeMs)
        };
      }
      return null;
    };

    return DeviceAttributeWatchdogProvider;

  })(PredicateProvider);
  DeviceAttributeWatchdogPredicateHandler = (function(superClass) {
    extend(DeviceAttributeWatchdogPredicateHandler, superClass);

    function DeviceAttributeWatchdogPredicateHandler(device1, attribute1, timeMs1) {
      this.device = device1;
      this.attribute = attribute1;
      this.timeMs = timeMs1;
      this.dependOnDevice(this.device);
    }

    DeviceAttributeWatchdogPredicateHandler.prototype.setup = function() {
      this._state = false;
      this._rescheduleTimeout();
      this.attributeListener = ((function(_this) {
        return function() {
          if (_this._state === true) {
            _this._state = false;
            _this.emit('change', false);
          }
          return _this._rescheduleTimeout();
        };
      })(this));
      this.device.on(this.attribute, this.attributeListener);
      return DeviceAttributeWatchdogPredicateHandler.__super__.setup.call(this);
    };

    DeviceAttributeWatchdogPredicateHandler.prototype.getValue = function() {
      return Promise.resolve(this._state);
    };

    DeviceAttributeWatchdogPredicateHandler.prototype.destroy = function() {
      this.device.removeListener(this.attribute, this.attributeListener);
      clearTimeout(this._timer);
      return DeviceAttributeWatchdogPredicateHandler.__super__.destroy.call(this);
    };

    DeviceAttributeWatchdogPredicateHandler.prototype.getType = function() {
      return 'state';
    };

    DeviceAttributeWatchdogPredicateHandler.prototype._rescheduleTimeout = function() {
      clearTimeout(this._timer);
      return this._timer = setTimeout(((function(_this) {
        return function() {
          _this._state = true;
          return _this.emit('change', true);
        };
      })(this)), this.timeMs);
    };

    return DeviceAttributeWatchdogPredicateHandler;

  })(PredicateHandler);

  /*
  The Variable Predicate Provider
  ----------------
  Handles comparison of variables
   */
  VariablePredicateProvider = (function(superClass) {
    extend(VariablePredicateProvider, superClass);

    VariablePredicateProvider.prototype.presets = [
      {
        name: "Variable comparison",
        input: "{expr} = {expr}"
      }
    ];

    function VariablePredicateProvider(framework) {
      this.framework = framework;
    }

    VariablePredicateProvider.prototype.parsePredicate = function(input, context) {
      var i, len, ref, ref1, result, v, variables;
      result = null;
      M(input, context).matchAnyExpression((function(_this) {
        return function(next, leftTokens) {
          return next.matchComparator('number', function(next, comparator) {
            return next.matchAnyExpression(function(next, rightTokens) {
              return result = {
                leftTokens: leftTokens,
                rightTokens: rightTokens,
                comparator: comparator,
                match: next.getFullMatch()
              };
            });
          });
        };
      })(this));
      if (result != null) {
        assert(Array.isArray(result.leftTokens));
        assert(Array.isArray(result.rightTokens));
        assert((ref = result.comparator) === '==' || ref === '!=' || ref === '<' || ref === '>' || ref === '<=' || ref === '>=');
        assert(typeof result.match === "string");
        variables = this.framework.variableManager.extractVariables(result.leftTokens.concat(result.rightTokens));
        ref1 = variables != null;
        for (i = 0, len = ref1.length; i < len; i++) {
          v = ref1[i];
          if (!this.framework.variableManager.isVariableDefined(v)) {
            context.addError("Variable $" + v + " is not defined.");
            return null;
          }
        }
        return {
          token: result.match,
          nextInput: input.substring(result.match.length),
          predicateHandler: new VariablePredicateHandler(this.framework, result.leftTokens, result.rightTokens, result.comparator)
        };
      } else {
        return null;
      }
    };

    return VariablePredicateProvider;

  })(PredicateProvider);
  VariablePredicateHandler = (function(superClass) {
    extend(VariablePredicateHandler, superClass);

    function VariablePredicateHandler(framework, leftTokens1, rightTokens1, comparator1) {
      this.framework = framework;
      this.leftTokens = leftTokens1;
      this.rightTokens = rightTokens1;
      this.comparator = comparator1;
    }

    VariablePredicateHandler.prototype.setup = function() {
      var i, len, ref, variable;
      this.lastState = null;
      this.variables = this.framework.variableManager.extractVariables(this.leftTokens.concat(this.rightTokens));
      ref = this.variables;
      for (i = 0, len = ref.length; i < len; i++) {
        variable = ref[i];
        this.dependOnVariable(this.framework.variableManager, variable);
      }
      this.changeListener = (function(_this) {
        return function(variable, value) {
          var evalPromise, ref1;
          if (ref1 = variable.name, indexOf.call(_this.variables, ref1) < 0) {
            return;
          }
          evalPromise = _this._evaluate();
          return evalPromise.then(function(state) {
            if (state !== _this.lastState) {
              _this.lastState = state;
              return _this.emit('change', state);
            }
          })["catch"](function(error) {
            env.logger.error("Error in VariablePredicateHandler:", error.message);
            return env.logger.debug(error);
          });
        };
      })(this);
      this.framework.variableManager.on("variableValueChanged", this.changeListener);
      return VariablePredicateHandler.__super__.setup.call(this);
    };

    VariablePredicateHandler.prototype.getValue = function() {
      return this._evaluate();
    };

    VariablePredicateHandler.prototype.destroy = function() {
      this.framework.variableManager.removeListener("variableValueChanged", this.changeListener);
      return VariablePredicateHandler.__super__.destroy.call(this);
    };

    VariablePredicateHandler.prototype.getType = function() {
      return 'state';
    };

    VariablePredicateHandler.prototype._evaluate = function() {
      var leftPromise, rightPromise;
      leftPromise = this.framework.variableManager.evaluateExpression(this.leftTokens);
      rightPromise = this.framework.variableManager.evaluateExpression(this.rightTokens);
      return Promise.all([leftPromise, rightPromise]).then((function(_this) {
        return function(arg) {
          var leftValue, rightValue, state;
          leftValue = arg[0], rightValue = arg[1];
          return state = _this._compareValues(leftValue, rightValue);
        };
      })(this));
    };


    /*
    Does the comparison.
     */

    VariablePredicateHandler.prototype._compareValues = function(left, right) {
      var ref;
      if ((ref = this.comparator) === "<" || ref === ">" || ref === "<=" || ref === ">=") {
        if (typeof left === "string") {
          if (isNaN(left)) {
            throw new Error("Can not compare strings with " + this.comparator + "!");
          }
          left = parseFloat(left);
        }
        if (typeof right === "string") {
          if (isNaN(right)) {
            throw new Error("Can not compare strings with " + this.comparator + "!");
          }
          right = parseFloat(right);
        }
      }
      switch (this.comparator) {
        case '==':
          return left === right;
        case '!=':
          return left !== right;
        case '<':
          return left < right;
        case '>':
          return left > right;
        case '<=':
          return left <= right;
        case '>=':
          return left >= right;
        default:
          throw new Error("Unknown comparator: " + this.comparator);
      }
    };

    return VariablePredicateHandler;

  })(PredicateHandler);
  VariableUpdatedPredicateProvider = (function(superClass) {
    extend(VariableUpdatedPredicateProvider, superClass);

    VariableUpdatedPredicateProvider.prototype.presets = [
      {
        name: "Variable changes",
        input: "{variable} changes"
      }, {
        name: "Variable increased/decreased",
        input: "{variable} increased"
      }
    ];

    function VariableUpdatedPredicateProvider(framework) {
      this.framework = framework;
    }

    VariableUpdatedPredicateProvider.prototype.parsePredicate = function(input, context) {
      var m, match, mode, setMode, setVariableName, variableName;
      variableName = null;
      mode = null;
      setVariableName = (function(_this) {
        return function(next, name) {
          return variableName = name.substring(1);
        };
      })(this);
      setMode = (function(_this) {
        return function(next, match) {
          return mode = match.trim();
        };
      })(this);
      m = M(input, context).matchVariable(setVariableName).match([" changes", " gets updated", " increased", " decreased", " is increasing", " is decreasing"], setMode);
      if (m.hadMatch()) {
        match = m.getFullMatch();
        assert(typeof variableName === "string");
        assert(mode != null);
        return {
          token: match,
          nextInput: input.substring(match.length),
          predicateHandler: new VariableUpdatedPredicateHandler(this.framework, variableName, mode)
        };
      } else {
        return null;
      }
    };

    return VariableUpdatedPredicateProvider;

  })(PredicateProvider);
  VariableUpdatedPredicateHandler = (function(superClass) {
    extend(VariableUpdatedPredicateHandler, superClass);

    function VariableUpdatedPredicateHandler(framework, variableName1, mode1) {
      this.framework = framework;
      this.variableName = variableName1;
      this.mode = mode1;
    }

    VariableUpdatedPredicateHandler.prototype.setup = function() {
      this.lastValue = null;
      this.state = false;
      this.dependOnVariable(this.framework.variableManager, this.variableName);
      this.changeListener = (function(_this) {
        return function(variable, value) {
          if (variable.name !== _this.variableName) {
            return;
          }
          switch (_this.mode) {
            case 'changes':
              if (_this.lastValue !== value) {
                _this.emit('change', "event");
              }
              break;
            case 'gets updated':
              _this.emit('change', "event");
              break;
            case 'increased':
              if (value > _this.lastValue) {
                _this.emit('change', "event");
              }
              break;
            case 'decreased':
              if (value < _this.lastValue) {
                _this.emit('change', "event");
              }
              break;
            case 'is increasing':
              if (value > _this.lastValue) {
                if (!_this.state) {
                  _this.state = true;
                  _this.emit('change', true);
                }
              } else {
                if (_this.state) {
                  _this.state = false;
                  _this.emit('change', false);
                }
              }
              break;
            case 'is decreasing':
              if (value < _this.lastValue) {
                if (!_this.state) {
                  _this.state = true;
                  _this.emit('change', true);
                }
              } else {
                if (_this.state) {
                  _this.state = false;
                  _this.emit('change', false);
                }
              }
          }
          return _this.lastValue = value;
        };
      })(this);
      this.framework.variableManager.on("variableValueChanged", this.changeListener);
      return VariableUpdatedPredicateHandler.__super__.setup.call(this);
    };

    VariableUpdatedPredicateHandler.prototype.getValue = function() {
      return Promise.resolve(this.state);
    };

    VariableUpdatedPredicateHandler.prototype.destroy = function() {
      this.framework.variableManager.removeListener("variableValueChanged", this.changeListener);
      return VariableUpdatedPredicateHandler.__super__.destroy.call(this);
    };

    VariableUpdatedPredicateHandler.prototype.getType = function() {
      switch (this.mode) {
        case 'is increasing':
        case 'is decreasing':
          return 'state';
        default:
          return 'event';
      }
    };

    return VariableUpdatedPredicateHandler;

  })(PredicateHandler);
  ButtonPredicateProvider = (function(superClass) {
    extend(ButtonPredicateProvider, superClass);

    ButtonPredicateProvider.prototype.presets = [
      {
        name: "Button pressed",
        input: "{button} is pressed"
      }
    ];

    function ButtonPredicateProvider(framework) {
      this.framework = framework;
    }

    ButtonPredicateProvider.prototype.parsePredicate = function(input, context) {
      var b, buttonsWithId, d, end, i, id, len, m, match, matchCount, matchingButtonId, matchingDevice, onButtonMatch, ref, ref1;
      matchCount = 0;
      matchingDevice = null;
      matchingButtonId = null;
      end = (function(_this) {
        return function() {
          return matchCount++;
        };
      })(this);
      onButtonMatch = (function(_this) {
        return function(m, arg) {
          var buttonId, device;
          device = arg.device, buttonId = arg.buttonId;
          matchingDevice = device;
          return matchingButtonId = buttonId;
        };
      })(this);
      buttonsWithId = [];
      ref = this.framework.deviceManager.devices;
      for (id in ref) {
        d = ref[id];
        if (!(d instanceof env.devices.ButtonsDevice)) {
          continue;
        }
        ref1 = d.config.buttons;
        for (i = 0, len = ref1.length; i < len; i++) {
          b = ref1[i];
          buttonsWithId.push([
            {
              device: d,
              buttonId: b.id
            }, b.id
          ]);
          if (b.id !== b.text) {
            buttonsWithId.push([
              {
                device: d,
                buttonId: b.id
              }, b.text
            ]);
          }
        }
      }
      m = M(input, context).match('the ', {
        optional: true
      }).match(buttonsWithId, {
        wildcard: "{button}"
      }, onButtonMatch).match(' button', {
        optional: true
      }).match(' is', {
        optional: true
      }).match(' pressed');
      if (m.hadMatch()) {
        match = m.getFullMatch();
        return {
          token: match,
          nextInput: input.substring(match.length),
          predicateHandler: new ButtonPredicateHandler(this, matchingDevice, matchingButtonId)
        };
      }
      return null;
    };

    return ButtonPredicateProvider;

  })(PredicateProvider);
  ButtonPredicateHandler = (function(superClass) {
    extend(ButtonPredicateHandler, superClass);

    function ButtonPredicateHandler(provider, device1, buttonId1) {
      this.provider = provider;
      this.device = device1;
      this.buttonId = buttonId1;
      assert((this.device != null) && this.device instanceof env.devices.ButtonsDevice);
      assert((this.buttonId != null) && typeof this.buttonId === "string");
      this.dependOnDevice(this.device);
    }

    ButtonPredicateHandler.prototype.setup = function() {
      this.buttonPressedListener = ((function(_this) {
        return function(id) {
          if (id === _this.buttonId) {
            return _this.emit('change', 'event');
          }
        };
      })(this));
      this.device.on('button', this.buttonPressedListener);
      return ButtonPredicateHandler.__super__.setup.call(this);
    };

    ButtonPredicateHandler.prototype.getValue = function() {
      return Promise.resolve(false);
    };

    ButtonPredicateHandler.prototype.destroy = function() {
      this.device.removeListener('button', this.buttonPressedListener);
      return ButtonPredicateHandler.__super__.destroy.call(this);
    };

    ButtonPredicateHandler.prototype.getType = function() {
      return 'event';
    };

    return ButtonPredicateHandler;

  })(PredicateHandler);
  StartupPredicateProvider = (function(superClass) {
    extend(StartupPredicateProvider, superClass);

    StartupPredicateProvider.prototype.presets = [
      {
        name: "pimatic is starting",
        input: "pimatic is starting"
      }
    ];

    function StartupPredicateProvider(framework) {
      this.framework = framework;
    }

    StartupPredicateProvider.prototype.parsePredicate = function(input, context) {
      var m, match;
      m = M(input, context).match(["pimatic is starting"]);
      if (m.hadMatch()) {
        match = m.getFullMatch();
        return {
          token: match,
          nextInput: input.substring(match.length),
          predicateHandler: new StartupPredicateHandler(this.framework)
        };
      } else {
        return null;
      }
    };

    return StartupPredicateProvider;

  })(PredicateProvider);
  StartupPredicateHandler = (function(superClass) {
    extend(StartupPredicateHandler, superClass);

    function StartupPredicateHandler(framework) {
      this.framework = framework;
    }

    StartupPredicateHandler.prototype.setup = function() {
      this.framework.once("after init", (function(_this) {
        return function() {
          return _this.emit('change', "event");
        };
      })(this));
      return StartupPredicateHandler.__super__.setup.call(this);
    };

    StartupPredicateHandler.prototype.getValue = function() {
      return Promise.resolve(false);
    };

    StartupPredicateHandler.prototype.getType = function() {
      return 'event';
    };

    return StartupPredicateHandler;

  })(PredicateHandler);
  return exports = {
    PredicateProvider: PredicateProvider,
    PredicateHandler: PredicateHandler,
    PresencePredicateProvider: PresencePredicateProvider,
    SwitchPredicateProvider: SwitchPredicateProvider,
    DeviceAttributePredicateProvider: DeviceAttributePredicateProvider,
    VariablePredicateProvider: VariablePredicateProvider,
    VariableUpdatedPredicateProvider: VariableUpdatedPredicateProvider,
    ContactPredicateProvider: ContactPredicateProvider,
    ButtonPredicateProvider: ButtonPredicateProvider,
    DeviceAttributeWatchdogProvider: DeviceAttributeWatchdogProvider,
    StartupPredicateProvider: StartupPredicateProvider
  };
};
